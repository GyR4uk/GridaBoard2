[{"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\index.js":"1","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\serviceWorker.js":"2","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\client\\Root.js":"3","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\shared\\App.js":"4","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\theme.js":"5","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\rootReducer.ts":"6","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\pointerTracer.js":"7","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\authorization.js":"8","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\ui.js":"9","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Home.tsx":"10","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\InkStorage.ts":"11","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\UpperNav.tsx":"12","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PrintButton.tsx":"13","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\CalibrationMenual.tsx":"14","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\FileLoad.tsx":"15","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\TracePointButton.tsx":"16","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FullScreenButton.tsx":"17","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ZoomButton.tsx":"18","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\RotateButton.tsx":"19","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PageNumbering.tsx":"20","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\BackgroundButton.tsx":"21","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FitButton.tsx":"22","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\ColorButtons.tsx":"23","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ConnectButton.tsx":"24","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\PenTypeButton.tsx":"25","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\index.ts":"26","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\EventSystem.ts":"27","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\PenManager.ts":"28","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\UtilsFunc.ts":"29","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\ThemeManager.ts":"30","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\neosmartpen.ts":"31","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\PaperInfo.ts":"32","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\NoteserverClient.ts":"33","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\MixedPageView.tsx":"34","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\types\\index.js":"35","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\DefaultOption.ts":"36","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintDataTypes.ts":"37","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Locales\\i18n.ts":"38","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderer.tsx":"39","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\Upload.js":"40","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\CanvasColorConverter.ts":"41","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\index.ts":"42","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\RenderWorkerBase.tsx":"43","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Save\\SavePdf.tsx":"44","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowserButton.tsx":"45","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PdfPrintButton.tsx":"46","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationButton.tsx":"47","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\Enums.ts":"48","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\JsUtils.js":"49","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\Modal\\PrintOptionDialog.tsx":"50","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\index.ts":"51","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoDot.ts":"52","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\NeoPdfViewer.tsx":"53","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfManager.ts":"54","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoStroke.ts":"55","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\DrawCurves.ts":"56","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm.ts":"57","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowser.tsx":"58","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderWorker.tsx":"59","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintPdfMain.tsx":"60","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationDialog.tsx":"61","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_event.ts":"62","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfDocument.ts":"63","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_const.ts":"64","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pen_util_func.ts":"65","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\Page.tsx":"66","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_enum.ts":"67","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_base.ts":"68","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\UtilFunc.ts":"69","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceSplitter.ts":"70","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PagesForPrint.tsx":"71","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageOrientation.jsx":"72","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingItem.ts":"73","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingStorage.ts":"74","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfPage.ts":"75","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\DataStructure\\Structures.ts":"76","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\index.ts":"77","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceInfo.ts":"78","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeRasterizer.tsx":"79","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageForPrint.tsx":"80","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeConstans.ts":"81","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\index.ts":"82","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeSurfaceDataJson.ts":"83","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeFetcher.ts":"84","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\index.ts":"85","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\DataTypes.ts":"86","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\CoordinateTanslater.ts":"87","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\SolveTransform.ts":"88","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\EchelonMatrix.ts":"89","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\GaussianElimination.ts":"90","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Posts.tsx":"91","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderWorker.tsx":"92","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderer.tsx":"93","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\index.ts":"94","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\constants.ts":"95","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\index.tsx":"96","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Post.tsx":"97","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\About.tsx":"98"},{"size":829,"mtime":1607317176919,"results":"99","hashOfConfig":"100"},{"size":5227,"mtime":1607317176967,"results":"101","hashOfConfig":"100"},{"size":930,"mtime":1607317176722,"results":"102","hashOfConfig":"100"},{"size":660,"mtime":1607317176968,"results":"103","hashOfConfig":"100"},{"size":1203,"mtime":1607317176984,"results":"104","hashOfConfig":"100"},{"size":402,"mtime":1607317176975,"results":"105","hashOfConfig":"100"},{"size":530,"mtime":1607317176974,"results":"106","hashOfConfig":"100"},{"size":1129,"mtime":1607319735934,"results":"107","hashOfConfig":"100"},{"size":4388,"mtime":1607317176975,"results":"108","hashOfConfig":"100"},{"size":9258,"mtime":1607333846663,"results":"109","hashOfConfig":"100"},{"size":9839,"mtime":1607324815358,"results":"110","hashOfConfig":"100"},{"size":690,"mtime":1607317176737,"results":"111","hashOfConfig":"100"},{"size":736,"mtime":1607319611270,"results":"112","hashOfConfig":"100"},{"size":725,"mtime":1607317176731,"results":"113","hashOfConfig":"100"},{"size":1497,"mtime":1607322959888,"results":"114","hashOfConfig":"100"},{"size":1720,"mtime":1607329726682,"results":"115","hashOfConfig":"100"},{"size":1594,"mtime":1607329130893,"results":"116","hashOfConfig":"100"},{"size":881,"mtime":1607329130902,"results":"117","hashOfConfig":"100"},{"size":1895,"mtime":1607329130897,"results":"118","hashOfConfig":"100"},{"size":2848,"mtime":1607322959883,"results":"119","hashOfConfig":"100"},{"size":3463,"mtime":1607329130889,"results":"120","hashOfConfig":"100"},{"size":4150,"mtime":1607322959915,"results":"121","hashOfConfig":"100"},{"size":8836,"mtime":1607322959894,"results":"122","hashOfConfig":"100"},{"size":3068,"mtime":1607331794052,"results":"123","hashOfConfig":"100"},{"size":11766,"mtime":1607322959907,"results":"124","hashOfConfig":"100"},{"size":808,"mtime":1607318826548,"results":"125","hashOfConfig":"100"},{"size":3336,"mtime":1607324316034,"results":"126","hashOfConfig":"100"},{"size":7539,"mtime":1607324316034,"results":"127","hashOfConfig":"100"},{"size":2999,"mtime":1607329536928,"results":"128","hashOfConfig":"100"},{"size":5627,"mtime":1607329529982,"results":"129","hashOfConfig":"100"},{"size":15065,"mtime":1607324815358,"results":"130","hashOfConfig":"100"},{"size":6464,"mtime":1607323506473,"results":"131","hashOfConfig":"100"},{"size":5612,"mtime":1607324337388,"results":"132","hashOfConfig":"100"},{"size":4067,"mtime":1607329709386,"results":"133","hashOfConfig":"100"},{"size":24,"mtime":1607317594439,"results":"134","hashOfConfig":"100"},{"size":870,"mtime":1607317176690,"results":"135","hashOfConfig":"100"},{"size":2522,"mtime":1607318820677,"results":"136","hashOfConfig":"100"},{"size":1201,"mtime":1607317176689,"results":"137","hashOfConfig":"100"},{"size":13265,"mtime":1607333846598,"results":"138","hashOfConfig":"100"},{"size":9624,"mtime":1607331794236,"results":"139","hashOfConfig":"100"},{"size":3185,"mtime":1607317176701,"results":"140","hashOfConfig":"100"},{"size":271,"mtime":1607317176924,"results":"141","hashOfConfig":"100"},{"size":18596,"mtime":1607332282179,"results":"142","hashOfConfig":"100"},{"size":1410,"mtime":1607329743138,"results":"143","hashOfConfig":"100"},{"size":1492,"mtime":1607318826548,"results":"144","hashOfConfig":"100"},{"size":7839,"mtime":1607330881825,"results":"145","hashOfConfig":"100"},{"size":754,"mtime":1607333748074,"results":"146","hashOfConfig":"100"},{"size":863,"mtime":1607323077606,"results":"147","hashOfConfig":"100"},{"size":286,"mtime":1607317176960,"results":"148","hashOfConfig":"100"},{"size":15313,"mtime":1607317176692,"results":"149","hashOfConfig":"100"},{"size":62,"mtime":1607317176937,"results":"150","hashOfConfig":"100"},{"size":528,"mtime":1607317176922,"results":"151","hashOfConfig":"100"},{"size":2862,"mtime":1607333893074,"results":"152","hashOfConfig":"100"},{"size":2396,"mtime":1607317176711,"results":"153","hashOfConfig":"100"},{"size":2645,"mtime":1607323506478,"results":"154","hashOfConfig":"100"},{"size":7529,"mtime":1607324815358,"results":"155","hashOfConfig":"100"},{"size":28941,"mtime":1607324178359,"results":"156","hashOfConfig":"100"},{"size":2599,"mtime":1607317176709,"results":"157","hashOfConfig":"100"},{"size":14814,"mtime":1607325076022,"results":"158","hashOfConfig":"100"},{"size":8496,"mtime":1607317176698,"results":"159","hashOfConfig":"100"},{"size":5823,"mtime":1607329052826,"results":"160","hashOfConfig":"100"},{"size":1813,"mtime":1607324178360,"results":"161","hashOfConfig":"100"},{"size":8004,"mtime":1607329747021,"results":"162","hashOfConfig":"100"},{"size":513,"mtime":1607317176933,"results":"163","hashOfConfig":"100"},{"size":1404,"mtime":1607317176930,"results":"164","hashOfConfig":"100"},{"size":7150,"mtime":1607333846599,"results":"165","hashOfConfig":"100"},{"size":461,"mtime":1607323792452,"results":"166","hashOfConfig":"100"},{"size":9241,"mtime":1607323753733,"results":"167","hashOfConfig":"100"},{"size":741,"mtime":1607329786188,"results":"168","hashOfConfig":"100"},{"size":7031,"mtime":1607333846598,"results":"169","hashOfConfig":"100"},{"size":3510,"mtime":1607327666928,"results":"170","hashOfConfig":"100"},{"size":322,"mtime":1607317176694,"results":"171","hashOfConfig":"100"},{"size":2343,"mtime":1607317176718,"results":"172","hashOfConfig":"100"},{"size":4694,"mtime":1607331794051,"results":"173","hashOfConfig":"100"},{"size":4375,"mtime":1607329737683,"results":"174","hashOfConfig":"100"},{"size":3704,"mtime":1607317176685,"results":"175","hashOfConfig":"100"},{"size":27,"mtime":1607317176700,"results":"176","hashOfConfig":"100"},{"size":4666,"mtime":1607329756411,"results":"177","hashOfConfig":"100"},{"size":19766,"mtime":1607333846599,"results":"178","hashOfConfig":"100"},{"size":15371,"mtime":1607327081604,"results":"179","hashOfConfig":"100"},{"size":905,"mtime":1607317176702,"results":"180","hashOfConfig":"100"},{"size":120,"mtime":1607317176683,"results":"181","hashOfConfig":"100"},{"size":2644,"mtime":1607317176705,"results":"182","hashOfConfig":"100"},{"size":3614,"mtime":1607329812291,"results":"183","hashOfConfig":"100"},{"size":220,"mtime":1607317176708,"results":"184","hashOfConfig":"100"},{"size":3007,"mtime":1607317176679,"results":"185","hashOfConfig":"100"},{"size":7212,"mtime":1607329795268,"results":"186","hashOfConfig":"100"},{"size":3929,"mtime":1607329819676,"results":"187","hashOfConfig":"100"},{"size":1068,"mtime":1607317176680,"results":"188","hashOfConfig":"100"},{"size":2144,"mtime":1607317176681,"results":"189","hashOfConfig":"100"},{"size":897,"mtime":1607331645289,"results":"190","hashOfConfig":"100"},{"size":33055,"mtime":1607333846599,"results":"191","hashOfConfig":"100"},{"size":10895,"mtime":1607332706285,"results":"192","hashOfConfig":"100"},{"size":1421,"mtime":1607333512688,"results":"193","hashOfConfig":"100"},{"size":854,"mtime":1607333395769,"results":"194","hashOfConfig":"100"},{"size":176,"mtime":1607333466116,"results":"195","hashOfConfig":"100"},{"size":198,"mtime":1607333540791,"results":"196","hashOfConfig":"100"},{"size":378,"mtime":1607333516955,"results":"197","hashOfConfig":"100"},{"filePath":"198","messages":"199","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},"jvpguv",{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"203","messages":"204","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"205","usedDeprecatedRules":"200"},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"208","messages":"209","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"210","usedDeprecatedRules":"200"},{"filePath":"211","messages":"212","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"216","messages":"217","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"218","messages":"219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"220","messages":"221","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"222","messages":"223","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"224","messages":"225","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"226","messages":"227","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"228","messages":"229","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"232","usedDeprecatedRules":"213"},{"filePath":"233","messages":"234","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"235","usedDeprecatedRules":"213"},{"filePath":"236","messages":"237","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"238","usedDeprecatedRules":"213"},{"filePath":"239","messages":"240","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"241","usedDeprecatedRules":"213"},{"filePath":"242","messages":"243","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"244","usedDeprecatedRules":"213"},{"filePath":"245","messages":"246","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"247","usedDeprecatedRules":"213"},{"filePath":"248","messages":"249","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"250","usedDeprecatedRules":"213"},{"filePath":"251","messages":"252","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"253","usedDeprecatedRules":"213"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"256","usedDeprecatedRules":"213"},{"filePath":"257","messages":"258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"259","messages":"260","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"261","usedDeprecatedRules":"213"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"264","messages":"265","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"266","usedDeprecatedRules":"213"},{"filePath":"267","messages":"268","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"269","usedDeprecatedRules":"213"},{"filePath":"270","messages":"271","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"272","messages":"273","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"274","messages":"275","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"276","usedDeprecatedRules":"213"},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"279","messages":"280","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"281","usedDeprecatedRules":"213"},{"filePath":"282","messages":"283","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"284","usedDeprecatedRules":"213"},{"filePath":"285","messages":"286","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"287","messages":"288","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"289","messages":"290","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"291","messages":"292","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"293","messages":"294","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"295","usedDeprecatedRules":"213"},{"filePath":"296","messages":"297","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"298","usedDeprecatedRules":"200"},{"filePath":"299","messages":"300","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"301","usedDeprecatedRules":"213"},{"filePath":"302","messages":"303","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"304","messages":"305","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"306","usedDeprecatedRules":"213"},{"filePath":"307","messages":"308","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"309","messages":"310","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"311","messages":"312","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"313","messages":"314","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"315","messages":"316","errorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"317","usedDeprecatedRules":"213"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"320","messages":"321","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"322","usedDeprecatedRules":"213"},{"filePath":"323","messages":"324","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"325","messages":"326","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"327","messages":"328","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"329","messages":"330","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"331","messages":"332","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"333","messages":"334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"337","messages":"338","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"339","usedDeprecatedRules":"213"},{"filePath":"340","messages":"341","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"342","usedDeprecatedRules":"213"},{"filePath":"343","messages":"344","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":1,"source":"345","usedDeprecatedRules":"213"},{"filePath":"346","messages":"347","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"348","usedDeprecatedRules":"213"},{"filePath":"349","messages":"350","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"351","messages":"352","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"353","usedDeprecatedRules":"213"},{"filePath":"354","messages":"355","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"356","messages":"357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"358","messages":"359","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"360","usedDeprecatedRules":"213"},{"filePath":"361","messages":"362","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"363","usedDeprecatedRules":"213"},{"filePath":"364","messages":"365","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"366","usedDeprecatedRules":"213"},{"filePath":"367","messages":"368","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"369","usedDeprecatedRules":"213"},{"filePath":"370","messages":"371","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"372","usedDeprecatedRules":"213"},{"filePath":"373","messages":"374","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":1,"source":"375","usedDeprecatedRules":"213"},{"filePath":"376","messages":"377","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"200"},{"filePath":"378","messages":"379","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"380","messages":"381","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"382","usedDeprecatedRules":"213"},{"filePath":"383","messages":"384","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"385","usedDeprecatedRules":"213"},{"filePath":"386","messages":"387","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"388","messages":"389","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"390","messages":"391","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":6,"source":"392","usedDeprecatedRules":"213"},{"filePath":"393","messages":"394","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"395","usedDeprecatedRules":"213"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"398","usedDeprecatedRules":"213"},{"filePath":"399","messages":"400","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"401","messages":"402","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"403","messages":"404","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"405","messages":"406","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":1,"source":"407","usedDeprecatedRules":"213"},{"filePath":"408","messages":"409","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"410","messages":"411","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"412","messages":"413","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"414","messages":"415","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"416","messages":"417","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"418","messages":"419","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"420","messages":"421","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"422","messages":"423","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"424","usedDeprecatedRules":"213"},{"filePath":"425","messages":"426","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"427","usedDeprecatedRules":"213"},{"filePath":"428","messages":"429","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"430","messages":"431","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"213"},{"filePath":"432","messages":"433","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"434","messages":"435","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"436","messages":"437","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\index.js",[],[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\serviceWorker.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\client\\Root.js",["438"],"import React from \"react\";\r\nimport App from \"../shared/App\";\r\nimport thunk from 'redux-thunk';\r\nimport {applyMiddleware, combineReducers, compose, createStore} from 'redux';\r\nimport rootReducer from \"../store/rootReducer\";\r\nimport { Provider } from \"react-redux\";\r\nimport { theme } from \"../styles/theme\";\r\nimport {\r\n  // Backdrop,\r\n  // Button,\r\n  // CircularProgress,\r\n  // Dialog,\r\n  // DialogActions,\r\n  // DialogContent,\r\n  // DialogContentText,\r\n  // DialogTitle,\r\n  // Fade,\r\n  // IconButton,\r\n  MuiThemeProvider,\r\n  // Snackbar,\r\n} from \"@material-ui/core\";\r\n\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\n\r\nexport const store = createStore(rootReducer, composeEnhancers(applyMiddleware(thunk)));\r\n\r\nconst Root = () => (\r\n  <Provider store={store}>\r\n    <MuiThemeProvider theme={theme}>\r\n      <App theme={theme} />\r\n    </MuiThemeProvider>\r\n  </Provider>\r\n);\r\n\r\nexport default Root;\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\shared\\App.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\theme.js",["439"],"import { createMuiTheme } from '@material-ui/core';\r\nimport Colors from '../styles/colors.scss';\r\nimport { colors } from '@material-ui/core';\r\nimport { koKR } from '@material-ui/core/locale';\r\n// import { Button, Typography } from \"@material-ui/core\";\r\n\r\nconst prev_palette = {\r\n  type: 'light',\r\n  primary: {\r\n    main: Colors.primary\r\n  },\r\n  secondary: {\r\n    main: Colors.secondary\r\n  },\r\n  error: {\r\n    main: Colors.error\r\n  },\r\n  warning: {\r\n    main: Colors.warning\r\n  },\r\n  info: {\r\n    main: Colors.info\r\n  },\r\n  success: {\r\n    main: Colors.success\r\n  },\r\n  contrastThreshold: 3,\r\n  tonalOffset: 0.2\r\n};\r\n\r\nconst palette = {\r\n  myColor: {\r\n    main: colors.blue[500]\r\n  },\r\n  primary: {\r\n    main: \"#7D89EF\",\r\n  },\r\n  secondary: {\r\n    main: \"#B3DDED\",\r\n  },\r\n  error: {\r\n    main: \"#FF7777\",\r\n  },\r\n  warning: {\r\n    main:  \"#FFC569\",\r\n  },\r\n  info: {\r\n    main: \"#65BEFF\",\r\n  },\r\n  success: {\r\n    main: \"#87C651\",\r\n  },\r\n  contrastThreshold: 3,\r\n  tonalOffset: 0.2\r\n};\r\n\r\nexport const theme = createMuiTheme({\r\n  palette,\r\n  // drawer 폭, 넓이\r\n  props: {\r\n    drawerWidth: 200,\r\n  },\r\n\r\n  typography: {\r\n    useNextVariants: true,\r\n    fontFamily: '\"Noto Sans KR\"'\r\n  },\r\n}, koKR);\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\rootReducer.ts",[],[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\pointerTracer.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\authorization.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\ui.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Home.tsx",["440"],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\InkStorage.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\UpperNav.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PrintButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\CalibrationMenual.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\FileLoad.tsx",["441"],"import React from 'react';\r\nimport '../../styles/main.css';\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\n\r\nconst PdfFileTooltip = withStyles((theme: Theme) => ({\r\n  tooltip: {\r\n      backgroundColor: '#f5f5f9',\r\n      color: 'rgba(0, 0, 0, 0.87)',\r\n      maxWidth: 240,\r\n      fontSize: theme.typography.pxToRem(12),\r\n      border: '1px solid #dadde9',\r\n  },\r\n}))(Tooltip);\r\n\r\nclass fileLoad extends React.Component {\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        <button id=\"btn_file_open\" type=\"button\" className=\"btn btn-neo \" title=\"Open a file\">\r\n          <PdfFileTooltip placement=\"top\" title={\r\n            <React.Fragment>\r\n                <Typography color=\"inherit\">PDF File Open</Typography>\r\n                <em>{\"배경으로 쓸 PDF 파일을 엽니다. 스마트 플레이트로 조작하거나, 인쇄하여 덧필기할 수 있습니다.\"}</em>\r\n                <br></br>\r\n                <b>{\"키보드 버튼 Ctrl + O으로 이동 가능합니다\"}</b>\r\n            </React.Fragment>\r\n                }>\r\n            <div className=\"c2\">\r\n                <img src={require('../../icons/icon_file_n.png')} className=\"normal-image\"></img>\r\n                <img src={require('../../icons/icon_file_p.png')} className=\"hover-image\"></img>\r\n            </div>\r\n          </PdfFileTooltip>\r\n        </button>\r\n      </React.Fragment>\r\n    )\r\n  }\r\n}\r\n\r\nexport default fileLoad;","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\TracePointButton.tsx",["442","443","444","445"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport { connect, useSelector, useDispatch } from 'react-redux';\r\nimport { setPointerTracer } from '../../store/reducers/pointerTracer';\r\nimport $ from \"jquery\";\r\nimport { RootState } from '../../store/rootReducer';\r\n\r\nimport icon_point_d from \"../../icons/icon_point_d.png\";\r\nimport icon_point_p from \"../../icons/icon_point_p.png\";\r\nimport icon_point_n from \"../../icons/icon_point_n.png\";\r\n\r\n\r\nconst TracePointButton = () => {\r\n  const isTrace = useSelector((state:RootState) => state.pointerTracer.isTrace)\r\n  const dispatch = useDispatch();\r\n\r\n  const setEnable = (elem_name: string, sw: boolean) => {\r\n    const $elem = $(`#${elem_name}`);\r\n    if (sw) {\r\n        const $elem = $(\"#btn_tracepoint\").find(\".c2\");\r\n        $elem.addClass(\"checked\");\r\n    } else {\r\n        const $elem = $(\"#btn_tracepoint\").find(\".c2\");\r\n        $elem.removeClass(\"checked\");\r\n    }\r\n  }\r\n  \r\n  const onTogglePointerTracer = () => {\r\n    dispatch(setPointerTracer(!isTrace));\r\n    setEnable(\"btn_tracepoint\", isTrace);\r\n  }\r\n\r\n    return (\r\n      <button id=\"btn_tracepoint\" type=\"button\" className=\"btn btn-neo btn-neo-vertical\" title=\"Trace Point\"\r\n      onClick = {() => onTogglePointerTracer()}>\r\n          <div className=\"c2 checked\">\r\n              <img src={icon_point_d} className=\"toggle-off normal-image\"></img>\r\n              <img src={icon_point_p} className=\"toggle-off hover-image\"></img>\r\n              <img src={icon_point_n} className=\"toggle-on normal-image\"></img>\r\n              <img src={icon_point_p} className=\"toggle-on hover-image\"></img>\r\n          </div>\r\n      </button>\r\n    );\r\n}\r\nexport default TracePointButton;","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FullScreenButton.tsx",["446","447","448"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\nimport ThemeManager from \"../../styles/ThemeManager\";\r\n\r\nimport icon_fullscreen_n from \"../../icons/icon_fullscreen_n.png\";\r\nimport icon_fullscreen_p from \"../../icons/icon_fullscreen_p.png\";\r\n\r\nconst FullscreenTooltip = withStyles((theme: Theme) => ({\r\n  tooltip: {\r\n      backgroundColor: '#f5f5f9',\r\n      color: 'rgba(0, 0, 0, 0.87)',\r\n      maxWidth: 240,\r\n      fontSize: theme.typography.pxToRem(12),\r\n      border: '1px solid #dadde9',\r\n  },\r\n}))(Tooltip);\r\n\r\nexport default class FullScreenButton extends React.Component {\r\n  render() {\r\n    return (\r\n      <button id=\"btn_fullscreen\" type=\"button\" className=\"btn btn-neo btn-neo-vertical\" title=\"Fullscreen\"\r\n      onClick = {() => ThemeManager.getInstance().toggleFullScreen()}>\r\n          <FullscreenTooltip placement=\"left\" title={\r\n          <React.Fragment>\r\n              <Typography color=\"inherit\">Fullscreen</Typography>\r\n              <em>{\"전체 화면으로 표시합니다. \"}</em>\r\n              <br></br>\r\n              <b>{\"돌아가려면 [ESC]키를 눌러야 합니다.\"}</b>\r\n          </React.Fragment>\r\n              }>\r\n          <div className=\"c2\">\r\n              <img src={icon_fullscreen_n} className=\"normal-image\"></img>\r\n              <img src={icon_fullscreen_p} className=\"hover-image\"></img>\r\n          </div>\r\n        </FullscreenTooltip>\r\n      </button>\r\n      );\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ZoomButton.tsx",["449","450"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\n\r\nimport icon_zoom_n from \"../../icons/icon_zoom_n.png\";\r\nimport icon_zoom_p from \"../../icons/icon_zoom_p.png\";\r\nexport default class ZoomButton extends React.Component {\r\n  render() {\r\n    return (\r\n      <button id=\"btn_zoom\" type=\"button\" disabled className=\"btn btn-neo has-badge\" title=\"Zoom\" data-container=\"body\"\r\n          data-toggle=\"popover\" data-placement=\"left\" data-trigger=\"focus\" data-html=\"true\"\r\n          data-target=\"#my-popover-content\">\r\n          <div className=\"c2 disabled\">\r\n              <img src={ icon_zoom_n } className=\"normal-image\"></img>\r\n              <img src={ icon_zoom_p } className=\"hover-image\"></img>\r\n          </div>\r\n          <span id=\"zoom-ratio\" className=\"zoom-badge badge badge-pill badge-info\">100%</span>\r\n      </button>\r\n      );\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\RotateButton.tsx",["451","452","453"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\nimport icon_portrait_n from '../../icons/icon_portrait_n.png';\r\nimport icon_portrait_p from \"../../icons/icon_portrait_p.png\";\r\nimport icon_landscape_n from \"../../icons/icon_landscape_n.png\";\r\nimport icon_landscape_p from \"../../icons/icon_landscape_p.png\";\r\n\r\nconst RotateTooltip = withStyles((theme: Theme) => ({\r\n  tooltip: {\r\n      backgroundColor: '#f5f5f9',\r\n      color: 'rgba(0, 0, 0, 0.87)',\r\n      maxWidth: 240,\r\n      fontSize: theme.typography.pxToRem(12),\r\n      border: '1px solid #dadde9',\r\n  },\r\n}))(Tooltip);\r\n\r\nexport default class RotateButton extends React.Component {\r\n  render() {\r\n    return (\r\n      <div className=\"btn-group dropright\" role=\"group\">\r\n      <button type=\"button\" id=\"btn_rotate\" title=\"Rotate\" className=\"btn btn-neo btn-neo-vertical\">\r\n        <RotateTooltip placement=\"left\" title={\r\n            <React.Fragment>\r\n                <Typography color=\"inherit\">Rotate</Typography>\r\n                <em>{\"종이 또는 스마트 플레이트의 입력이 회전되어 반영될지 아닐지를 선택합니다.\"}</em>\r\n                <br></br>\r\n                <b>{\"TAB 가로쓰기/세로쓰기 전환\"}</b>\r\n            </React.Fragment>\r\n                }>\r\n            <div className=\"c2\">\r\n              <img src= {icon_portrait_n} className=\"toggle-off normal-image\"></img>\r\n              <img src= {icon_portrait_p} className=\"toggle-off hover-image\"></img>\r\n              <img src= {icon_landscape_n} className=\"toggle-on normal-image\"></img>\r\n              <img src= {icon_landscape_p} className=\"toggle-on hover-image\"></img>\r\n            </div>\r\n        </RotateTooltip>\r\n      </button>\r\n    </div>\r\n      );\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PageNumbering.tsx",["454"],"import React from 'react';\r\nimport '../../styles/main.css';\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\n\r\nconst PageTooltip = withStyles((theme: Theme) => ({\r\n  tooltip: {\r\n      backgroundColor: '#f5f5f9',\r\n      color: 'rgba(0, 0, 0, 0.87)',\r\n      maxWidth: 240,\r\n      fontSize: theme.typography.pxToRem(12),\r\n      border: '1px solid #dadde9',\r\n  },\r\n}))(Tooltip);\r\n\r\nclass pageNumbering extends React.Component {\r\n  render() {\r\n    return (\r\n      // <div className=\"navbar-menu d-flex justify-content-center align-items-center neo_shadow\">\r\n      <React.Fragment>\r\n        <button id=\"btn_prevpage\" type=\"button\" className=\"btn btn-neo \" title=\"Previous page\">\r\n          <PageTooltip placement=\"top\" title={\r\n            <React.Fragment>\r\n                <Typography color=\"inherit\">Pre Page</Typography>\r\n                <em>{\"현재 필기 중인 페이지를, 앞쪽 페이지로 이동시킵니다.\"}</em>\r\n                <br></br>\r\n                <b>{\"키보드 버튼 Page Up으로 이동 가능합니다\"}</b>\r\n            </React.Fragment>\r\n                }>\r\n            <div className=\"c2\">\r\n              <img src={require('../../icons/icon_prev_n.png')} className=\"normal-image\"></img>\r\n              <img src={require('../../icons/icon_prev_p.png')} className=\"hover-image\"></img>\r\n            </div>\r\n          </PageTooltip>\r\n        </button>\r\n        <input type=\"text\" className=\"form-control-plaintext form-control-sm neo-form-pdf-number\" placeholder=\".form-control-sm\"\r\n            value=\"Page:\" readOnly />\r\n        <input id=\"curr_page_num\" type=\"text\" className=\"form-control form-control-sm neo-form-pdf-number\"\r\n            placeholder=\".form-control-sm\" value=\" \" />\r\n        <input id=\"page_count\" type=\"text\" className=\"form-control-plaintext form-control-sm neo-form-pdf-number\"\r\n            placeholder=\".form-control-sm\" value=\"/\" readOnly />\r\n        <button id=\"btn_nextpage\" type=\"button\" className=\"btn btn-neo \" title=\"Next page\">\r\n        <PageTooltip placement=\"top\" title={\r\n          <React.Fragment>\r\n                <Typography color=\"inherit\">Next Page</Typography>\r\n                <em>{\"현재 필기 중인 페이지를, 뒤쪽 페이지로 이동시킵니다.\"}</em>\r\n                <br></br>\r\n                <b>{\"키보드 버튼 Page Down으로 이동 가능합니다\"}</b>\r\n            </React.Fragment>\r\n                }>\r\n            <div className=\"c2\">\r\n                <img src={require('../../icons/icon_next_n.png')} className=\"normal-image\"></img>\r\n                <img src={require('../../icons/icon_next_p.png')} className=\"hover-image\"></img>\r\n            </div>\r\n          </PageTooltip>\r\n        </button>\r\n      </React.Fragment>\r\n    )\r\n  }\r\n}\r\n\r\nexport default pageNumbering;","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\BackgroundButton.tsx",["455","456"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport ThemeManager from \"../../styles/ThemeManager\";\r\n\r\nimport icon_background_n from \"../../icons/icon_background_n.png\";\r\nimport icon_background_p from \"../../icons/icon_background_p.png\";\r\nimport icon_bg_gd01_n from \"../../icons/icon_bg_gd01_n.png\";\r\nimport icon_bg_gd01_p from \"../../icons/icon_bg_gd01_p.png\";\r\nimport icon_bg_gd02_n from \"../../icons/icon_bg_gd02_n.png\";\r\nimport icon_bg_gd02_p from \"../../icons/icon_bg_gd02_p.png\";\r\n\r\nimport icon_bg_wh_n from \"../../icons/icon_bg_wh_n.png\";\r\nimport icon_bg_wh_p from \"../../icons/icon_bg_wh_p.png\";\r\nimport icon_bg_bk_n from \"../../icons/icon_bg_bk_n.png\";\r\nimport icon_bg_bk_p from \"../../icons/icon_bg_bk_p.png\";\r\n\r\n\r\nconst themeManager: ThemeManager = ThemeManager.getInstance();\r\n\r\nexport default class BackgroundButton extends React.Component {\r\n  render() {\r\n    return (\r\n        <div className=\"btn-group dropright\" role=\"group\">\r\n          <button type=\"button\" id=\"btn_background\" title=\"Backgrounds\" className=\"btn btn-neo btn-neo-vertical\"\r\n              data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\r\n              <div className=\"c2\">\r\n                  <img src={icon_background_n} className=\"normal-image\"></img>\r\n                  <img src={icon_background_p} className=\"hover-image\"></img>\r\n              </div>\r\n          </button>\r\n\r\n          <div className=\"dropdown-menu p-0 border border-0 \" aria-labelledby=\"btn_background\">\r\n            <a className=\"dropdown-item\" href=\"#\">\r\n\r\n              <a id=\"btn_bg_gd\" className=\"dropdown-item\" href=\"javascript:void(0)\"\r\n              onClick={() => themeManager.setT1()}>\r\n                  <div className=\"c2\">\r\n                      <img src={icon_bg_gd01_n} className=\"normal-image\"></img>\r\n                      <img src={icon_bg_gd01_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\">Gurodong</span>\r\n                  </div>\r\n              </a>\r\n\r\n              <a id=\"btn_bg_avan\" className=\"dropdown-item\" href=\"javascript:void(0)\"\r\n              onClick={() => themeManager.setT2()}>\r\n                  <div className=\"c2\">\r\n                      <img src={icon_bg_gd02_n} className=\"normal-image\"></img>\r\n                      <img src={icon_bg_gd02_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\">Aubergine</span>\r\n                  </div>\r\n              </a>\r\n\r\n              <a id=\"btn_bg_white\" className=\"dropdown-item\" href=\"javascript:void(0)\"\r\n              onClick={() => themeManager.setT4()}>\r\n                  <div className=\"c2\">\r\n                      <img src={icon_bg_wh_n} className=\"normal-image\"></img>\r\n                      <img src={icon_bg_wh_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\">White</span>\r\n                  </div>\r\n              </a>\r\n\r\n              <a id=\"btn_bg_black\" className=\"dropdown-item\" href=\"javascript:void(0)\" \r\n              onClick={() => themeManager.setT5()}>\r\n                  <div className=\"c2\">\r\n                      <img src={icon_bg_bk_n} className=\"normal-image\"></img>\r\n                      <img src={icon_bg_bk_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\">Black</span>\r\n                  </div>\r\n              </a>\r\n            </a>  \r\n          </div> \r\n        </div>\r\n      );\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FitButton.tsx",["457","458","459"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\n\r\nimport icon_ratio_n from \"../../icons/icon_ratio_n.png\";\r\nimport icon_ratio_p from \"../../icons/icon_ratio_p.png\";\r\nimport icon_fit_width_n from \"../../icons/icon_fit_width_n.png\";\r\nimport icon_fit_width_p from \"../../icons/icon_fit_width_p.png\";\r\nimport icon_fit_height_n from \"../../icons/icon_fit_height_n.png\";\r\nimport icon_fit_height_p from \"../../icons/icon_fit_height_p.png\";\r\nimport icon_fit_canvas_n from \"../../icons/icon_fit_canvas_n.png\";\r\nimport icon_fit_canvas_p from \"../../icons/icon_fit_canvas_p.png\";\r\nimport icon_fit_paper_n from \"../../icons/icon_fit_paper_n.png\";\r\nimport icon_fit_paper_p from \"../../icons/icon_fit_paper_p.png\";\r\n\r\nconst FitTooltip = withStyles((theme: Theme) => ({\r\n  tooltip: {\r\n      backgroundColor: '#f5f5f9',\r\n      color: 'rgba(0, 0, 0, 0.87)',\r\n      maxWidth: 240,\r\n      fontSize: theme.typography.pxToRem(12),\r\n      border: '1px solid #dadde9',\r\n  },\r\n}))(Tooltip);\r\n\r\nexport default class FitButton extends React.Component {\r\n  render() {\r\n    return (\r\n    <React.Fragment>\r\n      <div className=\"btn-group dropright\" role=\"group\">\r\n          <button type=\"button\" id=\"btn_fit\" title=\"Fit\" className=\"btn btn-neo btn-neo-vertical\" data-toggle=\"dropdown\"\r\n              aria-haspopup=\"true\" aria-expanded=\"false\">\r\n              <FitTooltip placement=\"left\" title={\r\n                <React.Fragment>\r\n                    <Typography color=\"inherit\">Fit</Typography>\r\n                    <em>{\"용지의 크기를 맞추는 여러 옵션 중 하나를 선택합니다.\"}</em>\r\n                    <br></br>\r\n                    <b>{\"Z 폭 맞춤, X 높이 맞춤, C 전체 페이지, V 100%\"}</b>\r\n                </React.Fragment>\r\n                    }>\r\n                <div className=\"c2\">\r\n                  <img src={icon_ratio_n} className=\"normal-image\"></img>\r\n                  <img src={icon_ratio_p} className=\"hover-image\"></img>\r\n                </div>\r\n            </FitTooltip>\r\n          </button>\r\n          <div className=\"dropdown-menu p-0 border border-0 \" aria-labelledby=\"btn_eraser\">\r\n              <a id=\"btn_fit_width\" className=\"dropdown-item\" href=\"javascript:void(0)\">\r\n                  <div className=\"c2\">\r\n                      <img src={icon_fit_width_n} className=\"normal-image\"></img>\r\n                      <img src={icon_fit_width_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\" data-l10n-id=\"page_scale_width\">Fit to width</span>\r\n                  </div>\r\n              </a>\r\n              <a id=\"btn_fit_height\" className=\"dropdown-item\" href=\"javascript:void(0)\">\r\n                  <div className=\"c2\">\r\n                      <img src={icon_fit_height_n} className=\"normal-image\"></img>\r\n                      <img src={icon_fit_height_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\" data-l10n-id=\"page_scale_fit\">Fit to height</span>\r\n                  </div>\r\n              </a>\r\n              <a id=\"btn_fit_canvas\" className=\"dropdown-item\" href=\"javascript:void(0)\">\r\n                  <div className=\"c2\">\r\n                      <img src={icon_fit_canvas_n} className=\"normal-image\"></img>\r\n                      <img src={icon_fit_canvas_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\" data-l10n-id=\"page_scale_auto\">Fit to full page</span>\r\n                  </div>\r\n              </a>\r\n              <a id=\"btn_fit_paper\" className=\"dropdown-item\" href=\"javascript:void(0)\">\r\n                  <div className=\"c2\">\r\n                      <img src={icon_fit_paper_n} className=\"normal-image\"></img>\r\n                      <img src={icon_fit_paper_p} className=\"hover-image\"></img>\r\n                      <span className=\"bg-dropmenu\" data-l10n-id=\"page_scale_actual\">Fit to 100%</span>\r\n                  </div>\r\n              </a>\r\n          </div>\r\n      </div>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\ColorButtons.tsx",["460"],"import React from 'react';\r\nimport '../../styles/main.css';\r\nimport PenManager from \"../../neosmartpen/pencomm/PenManager\";\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\n\r\nconst manager: PenManager = PenManager.getInstance();\r\n\r\nconst PenColorTooltip = withStyles((theme: Theme) => ({\r\n    tooltip: {\r\n        backgroundColor: '#f5f5f9',\r\n        color: 'rgba(0, 0, 0, 0.87)',\r\n        maxWidth: 240,\r\n        fontSize: theme.typography.pxToRem(12),\r\n        border: '1px solid #dadde9',\r\n    },\r\n}))(Tooltip);\r\n\r\nconst ColorButtons = () => {\r\n    \r\n    return (\r\n        // <div className=\"color_bar neo_shadow float-left bottom_text color_bar\">\r\n        <React.Fragment>\r\n          <div className=\"btn-group\">\r\n              <button id=\"clr_1\" type=\"button\" className=\"btn btn-neo color_btn othercolors\" title=\"color 1\" \r\n                onClick={() => manager.setColor(1)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [RED]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 1로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_1\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n\r\n              <button id=\"clr_2\" type=\"button\" className=\"btn btn-neo color_btn\" title=\"Pen color\"\r\n                onClick={() => manager.setColor(2)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [YELLOW]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 2로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_2\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_3\" type=\"button\" className=\"btn btn-neo color_btn othercolors\" title=\"color 3\"\r\n                onClick={() => manager.setColor(3)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [NAVY]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 3로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_3\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_4\" type=\"button\" className=\"btn btn-neo color_btn othercolors\" title=\"color 4\"\r\n                onClick={() => manager.setColor(4)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [BLACK]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 4로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_4\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_5\" type=\"button\" className=\"btn btn-neo  color_btn othercolors\" title=\"color 5\"\r\n                onClick={() => manager.setColor(5)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [LIGHT_GRAY]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 5로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_5\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_6\" type=\"button\" className=\"btn btn-neo  color_btn othercolors\" title=\"color 6\"\r\n                onClick={() => manager.setColor(6)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [ORANGE]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 6로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_6\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_7\" type=\"button\" className=\"btn btn-neo  color_btn othercolors\" title=\"color 7\"\r\n                onClick={() => manager.setColor(7)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [GREEN]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 7로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_7\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_8\" type=\"button\" className=\"btn btn-neo  color_btn othercolors\" title=\"color 8\"\r\n                onClick={() => manager.setColor(8)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [BLUE]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 8로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_8\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_9\" type=\"button\" className=\"btn btn-neo  color_btn othercolors\" title=\"color 9\"\r\n                onClick={() => manager.setColor(9)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [PURPLE]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 9로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_9\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n              <button id=\"clr_0\" type=\"button\" className=\"btn btn-neo color_btn othercolors\" title=\"color 0\"\r\n                onClick={() => manager.setColor(0)}>\r\n                  <PenColorTooltip placement=\"top\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Color [DARK_GRAY]</Typography>\r\n                            <em>{\"표시되는 펜의 색상을 선택합니다\"}</em>\r\n                            <br></br>\r\n                            <b>{\"키보드 버튼 0로 선택 가능합니다\"}</b>\r\n                        </React.Fragment>\r\n                    }>\r\n                        <div className=\"color_icon color_0\">\r\n                        </div>\r\n                    </PenColorTooltip>\r\n              </button>\r\n          </div>\r\n      {/* </div> */}\r\n      </React.Fragment>\r\n    );\r\n  }\r\nexport default ColorButtons;","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ConnectButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\PenTypeButton.tsx",["461","462","463","464","465"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport Tooltip, { TooltipProps } from '@material-ui/core/Tooltip';\r\nimport { Theme, Typography, withStyles } from '@material-ui/core';\r\nimport PenManager from \"../../neosmartpen/pencomm/PenManager\";\r\nimport { IBrushType } from \"../../neosmartpen/DataStructure\";\r\n\r\nconst PenTypeTooltip = withStyles((theme: Theme) => ({\r\n    tooltip: {\r\n        backgroundColor: '#f5f5f9',\r\n        color: 'rgba(0, 0, 0, 0.87)',\r\n        maxWidth: 240,\r\n        fontSize: theme.typography.pxToRem(12),\r\n        border: '1px solid #dadde9',\r\n    },\r\n}))(Tooltip);\r\n\r\nconst manager: PenManager = PenManager.getInstance();\r\n\r\nexport default class PenTypeButton extends React.Component {\r\n  shouldComponentUpdate(nextProps: any, nextState: any) {\r\n    return false;\r\n  }\r\n    \r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n            <button id=\"btn_brush\" disabled type=\"button\" title=\"Pen type\"\r\n                className=\"bind-popover btn btn-neo btn-neo-vertical\" data-toggle=\"dropdown\" aria-haspopup=\"true\"\r\n                aria-expanded=\"false\">\r\n                <PenTypeTooltip placement=\"left\" title={\r\n                    <React.Fragment>\r\n                        <Typography color=\"inherit\">Pen Type</Typography>\r\n                        <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                        <br></br>\r\n                        <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                    </React.Fragment>\r\n                        }>\r\n                    <div className=\"c2 disabled state_0\">\r\n                        <img src={require(\"../../icons/icon_pen_n.png\")} className=\"state_0 normal-image\"></img>\r\n                        <img src={require(\"../../icons/icon_pen_p.png\")} className=\"state_0 hover-image\"></img>\r\n\r\n                        <img src={require(\"../../icons/icon_highlight_n.png\")} className=\"state_1 normal-image\"></img>\r\n                        <img src={require(\"../../icons/icon_highlight_p.png\")} className=\"state_1 hover-image\"></img>\r\n\r\n                        <img src={require(\"../../icons/icon_eraser_n.png\")} className=\"state_2 normal-image\"></img>\r\n                        <img src={require(\"../../icons/icon_eraser_p.png\")} className=\"state_2 hover-image\"></img>\r\n\r\n                        <span id=\"thickness_num\" className=\"thickness-badge badge badge-pill badge-secondary\">2</span>\r\n                    </div>\r\n                </PenTypeTooltip>\r\n            </button>\r\n\r\n            <div className=\"dropdown-menu dropdown-menu-right p-0 border border-0\" aria-labelledby=\"btn_brush\">\r\n                {/* 펜/형광펜 */}\r\n                <div className=\"btn-group\">\r\n                    <button id=\"btn_pen\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\"\r\n                    onClick={() => manager.setPenRendererType(IBrushType.PEN)}>\r\n                    <PenTypeTooltip placement=\"left\" title={\r\n                        <React.Fragment>\r\n                            <Typography color=\"inherit\">Pen Type</Typography>\r\n                            <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                            <br></br>\r\n                            <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                        </React.Fragment>\r\n                            }>\r\n                        <div className=\"c2\">\r\n                            <img src = { require(\"../../icons/icon_pen_n.png\") } className=\"normal-image\"></img>\r\n                            <img src = { require(\"../../icons/icon_pen_p.png\") } className=\"hover-image\"></img>\r\n                        </div>\r\n                    </PenTypeTooltip>\r\n                    </button>\r\n                    <button id=\"btn_marker\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" \r\n                    onClick={() => manager.setPenRendererType(IBrushType.MARKER)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src= { require(\"../../icons/icon_highlight_n.png\") } className=\"normal-image\"></img>\r\n                                <img src= { require(\"../../icons/icon_highlight_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip>\r\n                    </button>\r\n                    <button id=\"btn_eraser\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" \r\n                    onClick={() => manager.setPenRendererType(IBrushType.ERASER)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src = { require(\"../../icons/icon_eraser_n.png\") } className=\"normal-image\"></img>\r\n                                <img src = { require(\"../../icons/icon_eraser_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip>\r\n                    </button>\r\n                </div>\r\n\r\n                {/* 선 굵기 */}\r\n                <div className=\"dropdown-divider\"></div>\r\n                <div className=\"btn-group\">\r\n                    <button id=\"btn_thick_1\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" onClick={() => manager.setThickness(1)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src = { require(\"../../icons/icon_thickness_01_n.png\") } className=\"normal-image\"></img>\r\n                                <img src = { require(\"../../icons/icon_thickness_01_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip>\r\n                    </button>\r\n                    <button id=\"btn_thick_2\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" onClick={() => manager.setThickness(2)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src = { require(\"../../icons/icon_thickness_02_n.png\") } className=\"normal-image\"></img>\r\n                                <img src = { require(\"../../icons/icon_thickness_02_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip> \r\n                    </button>\r\n                    <button id=\"btn_thick_3\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" onClick={() => manager.setThickness(3)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src = { require(\"../../icons/icon_thickness_03_n.png\") } className=\"normal-image\"></img>\r\n                                <img src = { require(\"../../icons/icon_thickness_03_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip> \r\n                    </button>\r\n                    <button id=\"btn_thick_4\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" onClick={() => manager.setThickness(4)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src = { require(\"../../icons/icon_thickness_04_n.png\") } className=\"normal-image\"></img>\r\n                                <img src = { require(\"../../icons/icon_thickness_04_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip> \r\n                    </button>\r\n                    <button id=\"btn_thick_5\" type=\"button\" className=\"btn btn-neo btn-neo-dropdown\" onClick={() => manager.setThickness(5)}>\r\n                        <PenTypeTooltip placement=\"left\" title={\r\n                            <React.Fragment>\r\n                                <Typography color=\"inherit\">Pen Type</Typography>\r\n                                <em>{\"펜과 형광펜, 지우개 중 하나를 선택하는 버튼입니다.\"}</em>\r\n                                <br></br>\r\n                                <b>{\"Q 펜, W 형광펜, E 지우개, A~G 굵기 선택\"}</b>\r\n                            </React.Fragment>\r\n                                }>\r\n                            <div className=\"c2\">\r\n                                <img src = { require(\"../../icons/icon_thickness_05_n.png\") } className=\"normal-image\"></img>\r\n                                <img src = { require(\"../../icons/icon_thickness_05_p.png\") } className=\"hover-image\"></img>\r\n                            </div>\r\n                        </PenTypeTooltip> \r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\EventSystem.ts",["466"],"export type EventCallbackType = (data) => void;\r\n\r\nexport interface PenEventFilter {\r\n  mac: string[] | undefined;\r\n  allowAll: boolean;\r\n}\r\n\r\ninterface CallbackItem {\r\n  callback: EventCallbackType;\r\n  filter: PenEventFilter;\r\n}\r\n\r\nclass DispatcherEvent {\r\n  eventName: string;\r\n  callbacks: CallbackItem[];\r\n\r\n  constructor(eventName) {\r\n    this.eventName = eventName;\r\n    this.callbacks = [];\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {function} callback\r\n   * @param {{mac:string}=} filter\r\n   */\r\n  registerCallback(callback: EventCallbackType, filter?: PenEventFilter) {\r\n    if (!filter) {\r\n      filter = { mac: undefined, allowAll: true };\r\n    }\r\n\r\n    this.callbacks.push({ callback, filter });\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {function} callback\r\n   * @return {boolean}\r\n   */\r\n  unregisterCallback(callback: EventCallbackType): boolean {\r\n    // Get the index of the callback in the callbacks array\r\n    // const index = this.callbacks.indexOf(callback);\r\n    const index = this.callbacks.findIndex((item) => item.callback === callback);\r\n\r\n    // If the callback is in the array then remove it\r\n    if (index > -1) {\r\n      this.callbacks.splice(index, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {object} data - which can have \"mac\" property to filter\r\n   */\r\n  fire(data: any) {\r\n    // We loop over a cloned version of the callbacks array\r\n    // in case the original array is spliced while looping\r\n    const callbacks = this.callbacks.slice(0);\r\n\r\n    // loop through the callbacks and call each one\r\n    callbacks.forEach((item) => {\r\n      const filter = item.filter;\r\n      if (!data.mac || filter.allowAll || !filter.mac || filter.mac === data.mac || filter.mac.indexOf(data.mac) > -1) {\r\n        item.callback(data);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport default class EventDispatcher {\r\n  events: { [key: string]: DispatcherEvent };\r\n\r\n  constructor() {\r\n    this.events = {};\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {string} eventName\r\n   * @param {any} data\r\n   */\r\n  dispatch(eventName: string, data: any) {\r\n    // First we grab the event\r\n    const event = this.events[eventName];\r\n    // If the event exists then we fire it!\r\n    if (event) {\r\n      event.fire(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {string} eventName\r\n   * @param {function} callback\r\n   * @param {{mac:string}=} filter\r\n   */\r\n  on(eventName: string, callback: EventCallbackType, filter: PenEventFilter) {\r\n    // First we grab the event from this.events\r\n    let event = this.events[eventName];\r\n\r\n    // If the event does not exist then we should create it!\r\n    if (!event) {\r\n      event = new DispatcherEvent(eventName);\r\n      this.events[eventName] = event;\r\n    }\r\n    // Now we add the callback to the event\r\n    event.registerCallback(callback, filter);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {string} eventName\r\n   * @param {function} callback\r\n   */\r\n  off(eventName: string, callback: EventCallbackType) {\r\n    const event = this.events[eventName];\r\n\r\n    // Check that the event exists and it has the callback registered\r\n    if (!event) return;\r\n\r\n    const flag = event.unregisterCallback(callback);\r\n    if (flag) {\r\n      // if the event has no callbacks left, delete the event\r\n      if (event.callbacks.length === 0) {\r\n        delete this.events[eventName];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\PenManager.ts",["467"],"import { NeoSmartpen } from \"./neosmartpen\";\r\nimport { IPenEvent } from \"../DataStructure/Structures\";\r\nimport { IBrushType } from \"../DataStructure/Enums\"\r\n// import PenBasedRenderer from \"../renderer/pageviewer/PenBasedRenderer\";\r\nimport ThemeManager from \"../../styles/ThemeManager\"\r\nimport $ from \"jquery\";\r\n\r\nlet _penmanager_instance = null;\r\nlet _active_pen: NeoSmartpen = null;\r\n\r\nexport const DEFAULT_PEN_COLOR_NUM = 2;\r\nexport const DEFAULT_PEN_THICKNESS = 2;\r\nexport const DEFAULT_PEN_RENDERER_TYPE: IBrushType = IBrushType.PEN;\r\n\r\nexport default class PenManager {\r\n  /** @type {Array.<{id:string, mac:string, pen:NeoSmartpen, connected:boolean}>} */\r\n  penArray = new Array(0);\r\n\r\n  /** @type {Array.<StorageRenderer>} */\r\n  render = [];\r\n\r\n  pen_colors: string[] = [\r\n    \"rgb(169, 169, 169)\", // 0 DARK_GARY #FFAAAAAA #A9A9A9\r\n    \"rgb(255, 0, 0)\", // 1 RED #FFFF0200 #FF0000  rgb(255, 0, 0, 0)\r\n    \"rgb(255, 255, 2)\", // 2 YELLOW #FFFFD001 #FFFF02\r\n    \"rgb(0, 0, 128)\", // 3 NAVY #FF012EE2 #000080\r\n\r\n    \"rgb(0, 0, 0)\", // 4 BLACK #FF000000 #000000\r\n\r\n    \"rgb(211, 211, 211)\", // 5 LIGHT_GRAY #FFE5E5E5 #D3D3D3\r\n    \"rgb(255, 165, 0)\", // 6 ORANGE #FFFF6500 #FFA500\r\n    \"rgb(0, 128, 0)\", // 7 GREEN #FF3CDD00 #008000\r\n\r\n    \"rgb(0, 0, 255)\", // 8 BLUE #FF00ABEB #0000FF\r\n    \"rgb(128, 0, 128)\", // 9 PURPLE #FF6C00E2 #800080\r\n    \"rgb(169, 169, 169)\" // 10 DARK_GARY #FFAAAAAA #A9A9A9\r\n  ];\r\n\r\n  marker_colors: string[] = [\r\n    \"rgb(217, 217, 224)\", // 0 \r\n    \"rgb(232, 155, 162)\", // 1 \r\n    \"rgb(244, 244, 175)\", // 2 \r\n    \"rgb(166, 166, 212)\", // 3 \r\n\r\n    \"rgb(167, 167, 174)\", // 4\r\n\r\n    \"rgb(231, 231, 238)\", // 5\r\n    \"rgb(241, 214, 171)\", // 6\r\n    \"rgb(166, 205, 173)\", // 7\r\n\r\n    \"rgb(167, 167, 251)\", // 8\r\n    \"rgb(205, 166, 212)\", // 9\r\n    \"rgb(217, 217, 224)\" // 10\r\n  ];\r\n\r\n  color: string = this.pen_colors[DEFAULT_PEN_COLOR_NUM];\r\n  thickness: number = DEFAULT_PEN_THICKNESS;\r\n  penRendererType: IBrushType = DEFAULT_PEN_RENDERER_TYPE;\r\n\r\n  init = () => {\r\n    this.setThickness(DEFAULT_PEN_THICKNESS);\r\n    this.setPenRendererType(DEFAULT_PEN_RENDERER_TYPE);\r\n    this.setColor(DEFAULT_PEN_COLOR_NUM);\r\n  }\r\n\r\n  constructor() {\r\n    if (_penmanager_instance) return _penmanager_instance;\r\n  }\r\n\r\n  /**\r\n   * @return {PenManager}\r\n   */\r\n  static getInstance() {\r\n    if (_penmanager_instance) return _penmanager_instance;\r\n\r\n    _penmanager_instance = new PenManager();\r\n    return _penmanager_instance;\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  public createPen = (): NeoSmartpen => {\r\n    const pen = new NeoSmartpen();\r\n    return pen;\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param pen \r\n   * @param device \r\n   */\r\n  public add = (pen: NeoSmartpen, device: BluetoothDevice) => {\r\n    console.log(device);\r\n    this.penArray.push({\r\n      id: device.id,\r\n      mac: pen.getMac(),\r\n      pen,\r\n      connected: false\r\n    });\r\n\r\n    console.log(`PenManager: pen added, mac=${pen.getMac()}`);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param device \r\n   */\r\n  public isAlreadyConnected = (device: BluetoothDevice): boolean => {\r\n    const index = this.penArray.findIndex(penInfo => penInfo.id === device.id);\r\n    if (index > -1) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param pen \r\n   */\r\n  private removePen = (pen: NeoSmartpen) => {\r\n    const btDeviceId = pen.getBtDevice().id;\r\n\r\n    const index = this.penArray.findIndex(penInfo => penInfo.id === btDeviceId);\r\n    if (index > -1) {\r\n      this.penArray.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  setActivePen = (penId: string) => {\r\n    _active_pen = this.penArray.find(penInfo => penInfo.pen.mac === penId).pen;\r\n  }\r\n\r\n  setColor(color_num: number) {\r\n    this.toggleColorRadioButton(color_num);\r\n    this.color = this.pen_colors[color_num];\r\n\r\n    if (_active_pen) {\r\n      _active_pen.setColor(this.color);\r\n    }\r\n  }\r\n\r\n  toggleColorRadioButton(color_num: number) {\r\n    const $elem = $(`.color_${color_num}`);\r\n    this.toggleColorRadioButton_inner(undefined, $elem);\r\n  }\r\n\r\n  toggleColorRadioButton_inner(e, $elem) {\r\n    if ($elem === undefined) {\r\n      $elem = $(e.target);\r\n    }\r\n    if ($elem.hasClass(\"color_icon\")) {\r\n      $(\".color_icon\").each(function (item) {\r\n        $(item).removeClass(\"pressed\");\r\n      });\r\n      $elem.addClass(\"pressed\");\r\n    }\r\n  }\r\n\r\n  setPenRendererType(type: IBrushType) {\r\n    const $elem = $(\"#btn_brush\").find(\".c2\");\r\n    this.setPenTypeStatus($elem, type);\r\n\r\n    if (type === IBrushType.MARKER) {\r\n      for (let i = 0; i < 11; i++) {\r\n        $('#clr_' + [i]).find(\".color_\" + [i]).css('background-color', this.marker_colors[i]);\r\n      }\r\n    }\r\n    else if (type === IBrushType.PEN) {\r\n      for (let i = 0; i < 11; i++) {\r\n        $('#clr_' + [i]).find(\".color_\" + [i]).css('background-color', this.pen_colors[i]);\r\n      }\r\n    }\r\n\r\n    this.penRendererType = type;\r\n\r\n    if (_active_pen) {\r\n      _active_pen.setPenRendererType(this.penRendererType);\r\n    }\r\n  }\r\n\r\n  setPenTypeStatus($elem, type) {\r\n    if (type == IBrushType.MARKER) {\r\n      $elem.removeClass(\"state_0\");\r\n      $elem.removeClass(\"state_2\");\r\n\r\n      $elem.addClass(\"state_1\");\r\n    } else if (type == IBrushType.ERASER) {\r\n      $elem.removeClass(\"state_0\");\r\n      $elem.removeClass(\"state_1\");\r\n\r\n      $elem.addClass(\"state_2\");\r\n    } else if (type == IBrushType.PEN) {\r\n      $elem.removeClass(\"state_1\");\r\n      $elem.removeClass(\"state_2\");\r\n\r\n      $elem.addClass(\"state_0\");\r\n    }\r\n  }\r\n\r\n  setThickness(thickness: number) {\r\n    $(\"#thickness_num\").text(thickness);\r\n\r\n    thickness = thickness * 2;\r\n    this.thickness = thickness;\r\n\r\n    if (_active_pen) {\r\n      _active_pen.setThickness(this.thickness);\r\n    }\r\n  }\r\n\r\n  registerRenderContainer = (renderContainer) => {\r\n    this.render.push(renderContainer);\r\n  }\r\n\r\n  unregisterRenderContainer = (renderContainer) => {\r\n    const sameRender = (item) => item === renderContainer;\r\n    const index = this.penArray.findIndex(sameRender);\r\n\r\n    if (index > -1) {\r\n      this.render.splice(index, 1);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param opt \r\n   */\r\n  public onConnected = (opt: { pen: NeoSmartpen, event: IPenEvent }) => {\r\n    const { pen } = opt;\r\n    const btDeviceId = pen.getBtDevice().id;\r\n\r\n    const index = this.penArray.findIndex(penInfo => penInfo.id === btDeviceId);\r\n\r\n    if (index > -1) {\r\n      this.penArray[index].connected = true;\r\n    }\r\n    else {\r\n      console.log(\"PenManager: something wrong, un-added pen connected\");\r\n      this.penArray.push({ id: pen.getBtDevice().id, mac: pen.getMac(), pen, connected: true });\r\n    }\r\n\r\n    const themeManager = ThemeManager.getInstance();\r\n    themeManager.enablePenRelatedButtons(true);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param opt \r\n   */\r\n  public onDisconnected = (opt: { pen: NeoSmartpen, event: IPenEvent }) => {\r\n    const { pen } = opt;\r\n    const btDeviceId = pen.getBtDevice().id;\r\n\r\n    const index = this.penArray.findIndex(penInfo => penInfo.id === btDeviceId);\r\n    if (index > -1) {\r\n      this.penArray.splice(index, 1);\r\n    }\r\n    else {\r\n      console.log(\"PenManager: something wrong, un-added pen disconnected\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param opt \r\n   */\r\n  public onNcodeError = (opt: { pen: NeoSmartpen, event: IPenEvent }) => {\r\n    // const { pen, event } = opt;\r\n\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  getConnectedPens = (): NeoSmartpen[] => {\r\n    /** @type {Array<NeoSmartpen>} */\r\n    const ret = new Array(0);\r\n\r\n    this.penArray.forEach(penInfo => {\r\n      if (penInfo.connected) {\r\n        ret.push(penInfo.pen);\r\n      }\r\n    });\r\n\r\n    return ret;\r\n  }\r\n\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\UtilsFunc.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\ThemeManager.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\neosmartpen.ts",["468"],"import PenComm, { deviceSelectDlg } from \"./pencomm\";\r\nimport InkStorage, { IOpenStrokeArg } from \"../penstorage/InkStorage\";\r\nimport { paperInfo } from \"../noteserver/PaperInfo\";\r\nimport Dispatcher, { EventCallbackType } from \"../penstorage/EventSystem\";\r\nimport PenManager from \"./PenManager\";\r\nimport \"../types\";\r\nimport { IPenEvent, IBrushState } from \"../DataStructure/Structures\";\r\nimport { NeoStroke, PEN_STATE, PenEventName } from \"../DataStructure\";\r\nimport { IWritingSurfaceInfo } from \"../DataStructure/Structures\";\r\nimport NeoDot from \"../DataStructure/NeoDot\";\r\nimport { IBrushType } from \"../DataStructure/Enums\"\r\nimport { fabric } from \"fabric\";\r\n\r\ninterface IPenMovement {\r\n  downEvent: IPenEvent,\r\n  infoEvent: IPenEvent,\r\n  moveEvents: IPenEvent[],\r\n  upEvent: IPenEvent,\r\n  numMovement: number,\r\n  stroke: NeoStroke,\r\n\r\n}\r\n\r\nconst NUM_HOVER_POINTERS = 6;\r\n\r\nexport class NeoSmartpen {\r\n  currPenMovement: IPenMovement = {\r\n    downEvent: null,\r\n    infoEvent: null,\r\n    moveEvents: [],\r\n    upEvent: null,\r\n    numMovement: 0,\r\n    stroke: null,\r\n  };\r\n\r\n  /** 펜 종류 마다의 굵기와 색깔 */\r\n  penState: IBrushState[] = new Array(Object.keys(IBrushType).length);\r\n\r\n  /** 펜 종류 (렌더러 종류) */\r\n  penRendererType: IBrushType = IBrushType.PEN;\r\n\r\n  lastInfoEvent: IPenEvent = null;\r\n  protocolHandler: PenComm = new PenComm(this);\r\n  mac: string = null;\r\n\r\n  lastState: PEN_STATE = PEN_STATE.NONE;\r\n\r\n  surfaceInfo: IWritingSurfaceInfo = {\r\n    section: 3,\r\n    owner: 27,\r\n    book: 168,\r\n    Xmin: 3.12,\r\n    Ymin: 3.12,\r\n    Xmax: 91.68,\r\n    Ymax: 128.36,\r\n    Mag: 1,\r\n  }\r\n\r\n  storage: InkStorage = InkStorage.getInstance();\r\n  manager: PenManager = PenManager.getInstance();\r\n  dispatcher: Dispatcher = new Dispatcher();\r\n\r\n  visibleHoverPoints = NUM_HOVER_POINTERS;\r\n  pathHoverPoints: Array<fabric.Circle> = new Array(0);\r\n  timeOut = null;\r\n  waitCount = 0;\r\n  eraserLastPoint = {};\r\n\r\n  pathPenTracker: fabric.Circle;\r\n  /**\r\n   *\r\n   * @param customStorage\r\n   */\r\n  constructor(customStorage: InkStorage = null) {\r\n    // this.appPen = appPenHandler;\r\n    if (customStorage) {\r\n      console.log(\"use custom Ink Storage\");\r\n      this.storage = customStorage;\r\n    }\r\n    else {\r\n      console.log(\"use default Ink Storage\");\r\n      this.storage = InkStorage.getInstance();\r\n    }\r\n\r\n    for (let i = 0; i < this.penState.length; i++) {\r\n      this.penState[i] = {\r\n        thickness: 0.1,\r\n        color: \"rgba(0,0,0,255)\",\r\n      };\r\n    }\r\n\r\n  }\r\n\r\n  initPenTracker() {\r\n    this.pathPenTracker = new fabric.Circle({\r\n      left: -30,\r\n      top: -30,\r\n      radius: 5,\r\n      opacity: 0.3,\r\n      fill: \"#7a7aff\",\r\n      stroke: \"#7a7aff\",\r\n      dirty: true,\r\n      name: 'penTracker',\r\n      data: 'pt'\r\n    });\r\n  }\r\n\r\n  initHoverCursor() {\r\n    for (let i = 0; i < 6; i++) {\r\n      const path = new fabric.Circle({\r\n        radius: (NUM_HOVER_POINTERS - i),\r\n        fill: \"#ff2222\",\r\n        stroke: \"#ff2222\",\r\n        opacity: (NUM_HOVER_POINTERS - i) / NUM_HOVER_POINTERS / 2,\r\n        left: -30,\r\n        top: -30,\r\n        hasControls: false,\r\n        dirty: true,\r\n        name: 'hoverPoint',\r\n        data: 'hp'\r\n      });\r\n      this.pathHoverPoints.push(path);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  getMac = (): string => {\r\n    return this.mac;\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   */\r\n  getBtDevice = (): BluetoothDevice => {\r\n    return this.protocolHandler.getBtDevice();\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   */\r\n  async connect(): Promise<boolean> {\r\n    let device = null;\r\n    try {\r\n      device = await deviceSelectDlg();\r\n    }\r\n    catch (e) {\r\n      console.log(e);\r\n      return false;\r\n    }\r\n\r\n    if (this.manager.isAlreadyConnected(device)) {\r\n      console.error(`bluetooth device(id:${device.id}) already connectged or connecting process is being processed`);\r\n      return false;\r\n    }\r\n\r\n    if (device) {\r\n      this.protocolHandler.connect(device);\r\n      this.manager.add(this, device);\r\n    }\r\n    else {\r\n      console.error(\"Device NULL\");\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param device\r\n   */\r\n  async connectByWebBtDevice(device: BluetoothDevice) {\r\n    this.protocolHandler.connect(device);\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param mac\r\n   */\r\n  async connectByMacAddress(mac: string) {\r\n    throw new Error(`connectByMacAddress() not implemented yet.`);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  resetPenStroke = () => {\r\n    // let { currPenMovement} = this;\r\n    const p = this.currPenMovement;\r\n\r\n    p.downEvent = null;\r\n    p.infoEvent = null;\r\n    p.numMovement = 0;\r\n    p.moveEvents = [];\r\n    p.upEvent = null;\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param event\r\n   */\r\n  onPenDown = (event: IPenEvent) => {\r\n    this.resetPenStroke();\r\n    this.currPenMovement.downEvent = event;\r\n    this.lastState = PEN_STATE.PEN_DOWN;\r\n\r\n    // console.log(event);\r\n\r\n    // storage에 저장\r\n    if (!this.storage) {\r\n      console.error(\"Ink Storage has not been initialized\");\r\n    }\r\n\r\n    const mac = this.mac;\r\n    const time = event.timeStamp;\r\n\r\n    const openStrokeArg: IOpenStrokeArg = {\r\n      mac,\r\n      time,\r\n      penTipMode: event.penTipMode,\r\n      brushType: this.penRendererType,\r\n      thickness: this.penState[this.penRendererType].thickness,\r\n      color: this.penState[this.penRendererType].color,\r\n    }\r\n\r\n    const stroke = this.storage.openStroke(openStrokeArg);\r\n    const strokeKey = stroke.key;\r\n    this.currPenMovement.stroke = stroke;\r\n\r\n    console.log(`NeoSmartpen dispatch event ON_PEN_DOWN`);\r\n    this.dispatcher.dispatch(PenEventName.ON_PEN_DOWN, { strokeKey, mac, time, stroke });\r\n\r\n    this.manager.setActivePen(event.penId);\r\n    // event 전달\r\n    // let ph = this.appPen;\r\n    // ph.onPenDown(event);\r\n  }\r\n\r\n  /**\r\n   * 펜의 움직임\r\n   *    1) down/up이 있는 경우: DOWN -> INFO -> MOVE -> MOVE -> ... -> UP -> INFO와 같이 나옴\r\n   *    2) hove의 경우: (페이지가 바뀌면) INFO -> HOVER_MOVE -> HOVER_MOVE...\r\n   *\r\n   * pen down 된 후의 page info, 실질적으로 pen_down과 같음\r\n   *\r\n   * @param event\r\n   * @param hover\r\n   */\r\n  onPageInfo = (event: IPenEvent, hover: boolean) => {\r\n    // console.log(event);\r\n    this.lastInfoEvent = event;\r\n\r\n\r\n    // margin 값을 가져오기 위해서\r\n    const info = paperInfo.getPaperInfo({ section: event.section, book: event.book, owner: event.owner, page: event.page });\r\n    if (info) this.surfaceInfo = info;\r\n\r\n    // 이전에 펜 down이 있었으면\r\n    if (this.lastState === PEN_STATE.PEN_DOWN) {\r\n      this.currPenMovement.infoEvent = event;\r\n      // this.currPenMovement.infoEvent = {\r\n      //   section: event.section,\r\n      //   owner: event.owner,\r\n      //   book: event.book,\r\n      //   page: event.page,\r\n\r\n      //   ...event,\r\n      // };\r\n\r\n      if (!this.storage) {\r\n        console.error(\"Ink Storage has not been initialized\");\r\n      }\r\n      else {\r\n        const { section, owner, book, page, timeStamp } = event;\r\n        const mac = this.mac;\r\n        if (!mac) {\r\n          throw new Error(\"mac address was not registered\");\r\n        }\r\n\r\n        if (!hover) {\r\n          // storage에 저장\r\n          const stroke = this.currPenMovement.stroke;\r\n          const strokeKey = stroke.key;\r\n          this.storage.setStrokeInfo(strokeKey, section, owner, book, page, timeStamp);\r\n\r\n          // hand pen page the event\r\n          this.dispatcher.dispatch(PenEventName.ON_PEN_PAGEINFO, {\r\n            strokeKey, mac, stroke, section, owner, book, page,\r\n            time: event.timeStamp\r\n          });\r\n        }\r\n        else {\r\n          // hand hover page the event\r\n          this.dispatcher.dispatch(PenEventName.ON_PEN_HOVER_PAGEINFO, {\r\n            mac, section, owner, book, page, time: event.timeStamp\r\n          });\r\n\r\n        }\r\n      }\r\n\r\n      // let ph = this.appPen;\r\n      // ph.onPageInfo(event);\r\n    }\r\n\r\n    if (hover) {\r\n      const { section, owner, book, page, timeStamp } = event;\r\n      const mac = this.mac;\r\n\r\n      this.dispatcher.dispatch(PenEventName.ON_PEN_HOVER_PAGEINFO, {\r\n        mac, section, owner, book, page, time: timeStamp, pen: this\r\n      });\r\n    }\r\n\r\n    // event 전달\r\n    // let ph = this.appPen;\r\n    // if (hover) ph.onHoverPageInfo(event);\r\n\r\n    return;\r\n  }\r\n\r\n\r\n\r\n  private adjustPaperXminYmin = (event: IPenEvent) => {\r\n    event.x -= this.surfaceInfo.Xmin;\r\n    event.y -= this.surfaceInfo.Ymin;\r\n\r\n    return event;\r\n  }\r\n\r\n  /**\r\n   * pen down 상태에서 움직임\r\n   * @param event\r\n   */\r\n  onPenMove = (event: IPenEvent) => {\r\n    this.lastState = PEN_STATE.PEN_MOVE;\r\n\r\n    // margin을 paperInfo의 Xmin, Ymin 값에 따라 조정\r\n    // event = this.adjustPaperXminYmin(event);\r\n\r\n    // 기존의 방식에서는 처리하지 않았던 것, redundant할 수 있다.\r\n    if (this.currPenMovement.infoEvent) {\r\n      event.owner = this.currPenMovement.infoEvent.owner;\r\n      event.book = this.currPenMovement.infoEvent.book;\r\n      event.page = this.currPenMovement.infoEvent.page;\r\n    } else {\r\n      /**\r\n       * 종이에 터치되지 않고 들어오는 호버 이벤트\r\n       *\r\n       */\r\n      event.owner = -1;\r\n      event.book = -1;\r\n      event.page = -1;\r\n      // let srcLine = getFunctionName();\r\n      // console.error(`Get PEN_MOVE without PEN_INFO ${srcLine}`);\r\n      // throw new Error( `Get PEN_MOVE without PEN_INFO`);\r\n    }\r\n\r\n    this.currPenMovement.numMovement++;\r\n    event.isFirstDot = (this.currPenMovement.numMovement === 1);\r\n\r\n    // storage에 저장\r\n    if (!this.storage) {\r\n      console.error(\"Ink Storage has not been initialized\");\r\n    }\r\n\r\n    const dot = new NeoDot({\r\n      dotType: 2,   // moving\r\n      deltaTime: event.timediff,\r\n      time: event.timeStamp,\r\n      f: event.force,\r\n      x: event.x,\r\n      y: event.y,\r\n    });\r\n\r\n    const stroke = this.currPenMovement.stroke;\r\n    const strokeKey = stroke.key;\r\n    this.storage.appendDot(strokeKey, dot);\r\n    const pen = this;\r\n\r\n    // hand the event\r\n    this.dispatcher.dispatch(PenEventName.ON_PEN_MOVE, { strokeKey, mac: stroke.mac, stroke, dot, pen });\r\n\r\n    // 이벤트 전달\r\n    // console.log(\"    -> onPenMove\" + event);\r\n    // let ph = this.appPen;\r\n    // ph.onPenMove(event);\r\n  }\r\n\r\n  /**\r\n   * hover 상태에서 움직임\r\n   * @param event\r\n   */\r\n  onHoverMove = (event: IPenEvent) => {\r\n    this.lastState = PEN_STATE.HOVER_MOVE;\r\n\r\n    // margin을 paperInfo의 Xmin, Ymin 값에 따라 조정\r\n    // event = this.adjustPaperXminYmin(event);\r\n\r\n\r\n    // console.log(\"    -> onHoverMove\" + event);\r\n    // let ph = this.appPen;\r\n    // ph.onHoverMove(event);\r\n    const mac = this.mac;\r\n    if (!mac) {\r\n      throw new Error(\"mac address was not registered\");\r\n    }\r\n    this.dispatcher.dispatch(PenEventName.ON_HOVER_MOVE, { pen: this, mac, event });\r\n  }\r\n\r\n  /**\r\n * hover 상태에서 움직임\r\n * @param event\r\n */\r\n  onHoverPageInfo = (event: IPenEvent) => {\r\n    this.lastState = PEN_STATE.HOVER_MOVE;\r\n\r\n    const mac = this.mac;\r\n    if (!mac) {\r\n      throw new Error(\"mac address was not registered\");\r\n    }\r\n\r\n    this.dispatcher.dispatch(PenEventName.ON_PEN_HOVER_PAGEINFO, { pen: this, mac, event });\r\n  }\r\n\r\n  /**\r\n   * pen up\r\n   * @param event\r\n   */\r\n  onPenUp = (event: IPenEvent) => {\r\n    this.lastState = PEN_STATE.PEN_UP;\r\n\r\n    this.currPenMovement.upEvent = event;\r\n\r\n    // storage에 저장\r\n    if (!this.storage) {\r\n      console.error(\"Ink Storage has not been initialized\");\r\n    }\r\n\r\n    if (this.penRendererType !== IBrushType.ERASER) {\r\n      const stroke = this.currPenMovement.stroke;\r\n      const strokeKey = stroke.key;\r\n      this.storage.closeStroke(strokeKey);\r\n\r\n      const { mac, section, owner, book, page } = stroke;\r\n      this.dispatcher.dispatch(PenEventName.ON_PEN_UP, { strokeKey, mac, pen: this, stroke, section, owner, book, page });\r\n\r\n      this.resetPenStroke();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ncode error\r\n   * @param event\r\n   */\r\n  onNcodeError = (event: IPenEvent) => {\r\n    // console.log(event);\r\n\r\n    // let ph = this.appPen;\r\n    // ph.onNcodeError(event);\r\n    const mac = this.mac;\r\n    if (!mac) {\r\n      throw new Error(\"mac address was not registered\");\r\n    }\r\n\r\n    this.manager.onNcodeError({ pen: this, event });\r\n    this.dispatcher.dispatch(PenEventName.ON_NCODE_ERROR, { pen: this, mac, event });\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   *\r\n   * @param event\r\n   */\r\n  onPasscodeRequired = (event: IPenEvent) => {\r\n    console.log(\"onPasscodeRequired\" + event);\r\n    const passcode = prompt(\"please enter passcode \" + (9 - event.retryCount));\r\n    this.protocolHandler.sendPasscode(passcode);\r\n\r\n    const mac = this.protocolHandler.getMac();\r\n    if (!mac) {\r\n      throw new Error(\"mac address was not registered\");\r\n    }\r\n    this.dispatcher.dispatch(PenEventName.ON_PW_REQUIRED, { pen: this, mac, event });\r\n    // throw new Error(\"Not implemented: onPasscodeRequired\");\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   *\r\n   * @param event\r\n   */\r\n  onConnected = (event: IPenEvent) => {\r\n    // let ph = this.appPen;\r\n    // ph.onConnected(event);\r\n\r\n    console.log(\"CONNECTED\");\r\n    const mac = this.protocolHandler.getMac();\r\n    this.mac = mac;\r\n    console.log(`Connected: ${mac}`);\r\n\r\n    this.manager.onConnected({ pen: this, event });\r\n    this.dispatcher.dispatch(PenEventName.ON_CONNECTED, { pen: this, mac, event });\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param event\r\n   */\r\n  onFirmwareUpgradeNeeded = (event: IPenEvent) => {\r\n    // let ph = this.appPen;\r\n    // ph.onFirmwareUpgradeNeeded(event);\r\n\r\n    const mac = this.mac;\r\n    if (!mac) {\r\n      throw new Error(\"mac address was not registered\");\r\n    }\r\n    this.dispatcher.dispatch(PenEventName.ON_UPGRADE_NEEDED, { pen: this, mac, event });\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param event\r\n   */\r\n  onDisconnected = (event: IPenEvent) => {\r\n    // let event = makePenEvent(DeviceTypeEnum.PEN, PenEventEnum.ON_DISCONNECTED);\r\n    // let ph = this.appPen;\r\n    // ph.onDisconnected(event);\r\n    const mac = this.mac;\r\n    if (!mac) {\r\n      console.error(`mac address was not registered`);\r\n      console.error(event);\r\n    }\r\n    else {\r\n      this.manager.onDisconnected({ pen: this, event });\r\n      this.dispatcher.dispatch(PenEventName.ON_DISCONNECTED, { pen: this, mac, event });\r\n    }\r\n  }\r\n\r\n  setColor(color: string) {\r\n    this.penState[this.penRendererType].color = color;\r\n  }\r\n\r\n  setThickness(thickness: number) {\r\n    this.penState[this.penRendererType].thickness = thickness;\r\n  }\r\n\r\n  setPenRendererType(type) {\r\n    this.penRendererType = type;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param eventName\r\n   * @param listener\r\n   */\r\n  public addEventListener(eventName: PenEventName, listener: EventCallbackType) {\r\n    if (eventName === PenEventName.ON_PEN_DOWN) {\r\n      console.log(`NeoSmartpen: addEventListener ${eventName}`);\r\n    }\r\n\r\n    this.dispatcher.on(eventName, listener, null);\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param eventName\r\n   * @param listener\r\n   */\r\n  public removeEventListener(eventName: PenEventName, listener: EventCallbackType) {\r\n    this.dispatcher.off(eventName, listener);\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\PaperInfo.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\NoteserverClient.ts",["469"],"import $ from \"jquery\";\r\nimport JSZip from \"jszip\";\r\n\r\n// const $ = jQuery;\r\n// window.$ = window.jQuery = jQuery;\r\n\r\nconst NCODE_SIZE_IN_INCH = 8 * 7 / 600;\r\nconst POINT_72DPI_SIZE_IN_INCH = 1 / 72;\r\n\r\nconst point72ToNcode = (p) => {\r\n  const ratio = NCODE_SIZE_IN_INCH / POINT_72DPI_SIZE_IN_INCH;\r\n  return p / ratio;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} xml\r\n * @param {{filename:string, section:number, owner:number, book:number}} option\r\n */\r\nfunction extractMarginInfo(xml, option) {\r\n  const { filename, section, owner, book } = option;\r\n\r\n\r\n\r\n  const $bookXml = $(xml).find(\"book\");\r\n  const title = $bookXml.find(\"title\").text();\r\n  const author = $bookXml.find(\"author\").text();\r\n\r\n  const name = `${author}_${title}_${section}_${owner}_${book}`;\r\n\r\n  let Xmin_old = -1;\r\n  let Ymin_old = -1;\r\n  let Xmax_old = -1;\r\n  let Ymax_old = -1;\r\n\r\n  const result = [];\r\n\r\n  const xmlData = $(xml).find(\"page_item\");\r\n\r\n  // $(xmlData).each(function () {\r\n  xmlData.forEach(function (item) {\r\n    // let ccc = $(this);\r\n    const ccc = $(item);\r\n\r\n    const x1 = parseFloat(ccc.attr(\"x1\"));\r\n    const x2 = parseFloat(ccc.attr(\"x2\"));\r\n    const y1 = parseFloat(ccc.attr(\"y1\"));\r\n    const y2 = parseFloat(ccc.attr(\"y2\"));\r\n\r\n    const crop_margin = ccc.attr(\"crop_margin\");\r\n    const margins = crop_margin.split(\",\");\r\n    const l = parseFloat(margins[0]);\r\n    const t = parseFloat(margins[1]);\r\n    const r = parseFloat(margins[2]);\r\n    const b = parseFloat(margins[3]);\r\n\r\n    const page_no = parseInt(ccc.attr(\"number\"));\r\n\r\n    const Xmin = point72ToNcode(x1) + point72ToNcode(l);\r\n    const Ymin = point72ToNcode(y1) + point72ToNcode(t);\r\n    const Xmax = point72ToNcode(x2) - point72ToNcode(r);\r\n    const Ymax = point72ToNcode(y2) - point72ToNcode(b);\r\n\r\n    if (Xmin !== Xmin_old || Xmax !== Xmax_old || Ymin !== Ymin_old || Ymax !== Ymax_old) {\r\n      // console.log(ccc.html());\r\n      const obj = {\r\n        name,\r\n        section,\r\n        owner,\r\n        book,\r\n        Xmin,\r\n        Ymin,\r\n        Xmax,\r\n        Ymax,\r\n        Mag: 1,\r\n      }\r\n      console.log(obj);\r\n      result.push(obj);\r\n      Xmin_old = Xmin;\r\n      Xmax_old = Xmax;\r\n\r\n      Ymin_old = Ymin;\r\n      Ymax_old = Ymax;\r\n      console.log(`${section}.${owner}.${book} ==> ${filename}/${page_no} ==> ${crop_margin}`);\r\n    }\r\n  });\r\n\r\n  // ${xml}.find(\"\")\r\n  console.log(xml);\r\n\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} zipurl\r\n * @param {{section:number, owner:number, book:number}} bookInfo\r\n */\r\nfunction getZippedResouce(zipurl, bookInfo) {\r\n  const { section, owner, book } = bookInfo;\r\n\r\n  fetch(zipurl).then((response) => {\r\n    if (response.ok) {\r\n      response.blob().then((data) => {\r\n\r\n        const zip = new JSZip();\r\n        zip.loadAsync(data).then(function (contents) {\r\n          // console.log( contents.files);\r\n          Object.keys(contents.files).forEach(function (filename) {\r\n            zip.file(filename).async('nodebuffer').then(function (content) {\r\n              const n = filename.search(\".nproj\");\r\n              if (n > 0) {\r\n                const xml = new TextDecoder(\"utf-8\").decode(content);\r\n                extractMarginInfo(xml, { filename, section, owner, book });\r\n              }\r\n              // let dest = path + filename;\r\n              // fs.writeFileSync(dest, content);\r\n            });\r\n          });\r\n        });\r\n        // console.log(data);\r\n      });\r\n    }\r\n\r\n  });\r\n}\r\n\r\nexport default class NoteserverClient {\r\n  // constructor() {\r\n\r\n  // }\r\n\r\n  /**\r\n   *\r\n   * @param {{section:number, owner:number, book:number, page:number}} pageInfo\r\n   */\r\n  async getNoteInfo(pageInfo) {\r\n    // const { section, owner, book } = pageInfo;\r\n\r\n    const url = \"http://nbs.neolab.net/v1/notebooks/attributes?device=android\";\r\n    const el: HTMLInputElement = document.getElementById('str') as HTMLInputElement;\r\n    const s = encodeURIComponent(el.value);\r\n\r\n\r\n\r\n    // $.getJSON(url + \"?callback=?\", data, (data) => { console.log(data); } );\r\n\r\n    $.ajax({\r\n      type: \"GET\",\r\n      dataType: \"json\",\r\n      url: url,\r\n      data: { 's': s },\r\n      jsonpCallback: \"myCallback\",\r\n      // jsonpCallback: \"callback\",\r\n      success: function (data) {\r\n        // console.log(data);\r\n        const arr = data.attributes;\r\n        for (let i = 0; i < arr.length; i++) {\r\n          // for (let i = 0; i < 2; i++) {\r\n          const item = arr[i];\r\n\r\n          const section = item.section_id;\r\n          const owner = item.owner_id;\r\n          const book = item.note_id;\r\n\r\n          if (owner === 27 && book === 168) {\r\n            const zipurl = item.resource.zipimage;\r\n            getZippedResouce(zipurl, { section, owner, book });\r\n          }\r\n\r\n        }\r\n        // page 정보\r\n      },\r\n      error: function (error) {\r\n        console.log(error);\r\n      },\r\n      complete: function () {\r\n        console.log(\"completed\");\r\n      },\r\n    });\r\n\r\n\r\n    //   let response;\r\n    //   try {\r\n    //     let origin = window.location.origin;\r\n    //     const headers = { authorization: `Bearer` };\r\n\r\n    //     response = await fetch(\"http://nbs.neolab.net/v1/notebooks/attributes?device=android\", { headers });\r\n    //   } catch (err) {\r\n    //     console.error(err);\r\n    //     return;\r\n    //   }\r\n\r\n    //   console.log(\"test 1 response.status : \", response.status);\r\n\r\n    //   if (response.ok) {\r\n    //     let jsonData = await response.json();\r\n\r\n    //     for (let i = 0; i < jsonData.resultElements.length; i++) {\r\n    //       let resultElement = jsonData.resultElements[i];\r\n    //       console.log(resultElement);\r\n    //     }\r\n    //   }\r\n    // }\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\MixedPageView.tsx",["470"],"import React, { CSSProperties } from \"react\";\r\nimport PenBasedRenderer, { PLAYSTATE } from \"./pageviewer/PenBasedRenderer\";\r\nimport NeoPdfViewer from \"./pdf/NeoPdfViewer\";\r\nimport { IPageSOBP } from \"../DataStructure/Structures\";\r\nimport { NeoSmartpen } from \"../pencomm/neosmartpen\";\r\nimport * as PdfJs from \"pdfjs-dist\";\r\n\r\ninterface Props {\r\n  pageInfo?: IPageSOBP;\r\n  pdfUrl: string;\r\n  pageNo: number;\r\n  pens: NeoSmartpen[];\r\n\r\n  scale: number,\r\n  playState: PLAYSTATE;\r\n}\r\n\r\ninterface State {\r\n  pageInfo: IPageSOBP;\r\n  pdfUrl: string;\r\n\r\n  /** NOTE: pageNo라고 씌어 있는 것은, 항상 PDF의 페이지번호(1부터 시작)를 나타내기로 한다.  */\r\n  pageNo: number;\r\n  canvasPosition: { offsetX: number, offsetY: number, zoom: number },\r\n\r\n  renderCount: number;\r\n}\r\n\r\nconst tempStyle: CSSProperties = {\r\n  position: \"absolute\",\r\n  // height: \"100%\",\r\n  // width: \"100%\",\r\n  left: \"0px\",\r\n  top: \"0px\",\r\n  overflow: \"hidden\",\r\n}\r\n\r\nexport default class MixedPageView extends React.Component<Props, State> {\r\n  waitingForFirstStroke = true;\r\n  pdf: PdfJs.PDFDocumentProxy;\r\n  rendererRef: React.RefObject<PenBasedRenderer> = React.createRef();\r\n\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    const { pdfUrl, pageNo } = props;\r\n    let pageInfo = props.pageInfo;\r\n\r\n    if (!pageInfo) {\r\n      pageInfo = { section: -1, owner: -1, book: -1, page: -1, }\r\n    }\r\n\r\n    const canvasPosition = { offsetX: 0, offsetY: 0, zoom: 1 };\r\n    this.state = { pageInfo, pdfUrl, pageNo, canvasPosition, renderCount: 0 };\r\n  }\r\n\r\n  onReportPdfInfo = (pdf: PdfJs.PDFDocumentProxy) => {\r\n    this.pdf = pdf;\r\n  }\r\n\r\n  onNcodePageChanged = (pageInfo: IPageSOBP) => {\r\n    if (this.pdf) {\r\n      const numPages = this.pdf.numPages;\r\n\r\n      let pageDelta = 0;\r\n      if (this.waitingForFirstStroke) {\r\n        pageDelta = 0;\r\n        this.waitingForFirstStroke = false;\r\n        this.setState({ pageInfo });\r\n      }\r\n      else {\r\n        pageDelta = pageInfo.page - this.state.pageInfo.page;\r\n        pageDelta += numPages;\r\n        pageDelta = pageDelta % numPages;\r\n      }\r\n      this.setState({ pageNo: pageDelta + 1 });\r\n\r\n    }\r\n    /** 여기까지 임시 내용 */\r\n  }\r\n\r\n  onCanvasShapeChanged = (arg: { offsetX: number, offsetY: number, zoom: number }) => {\r\n    console.log(arg);\r\n    this.setState({ canvasPosition: arg });\r\n\r\n    const r = this.state.renderCount;\r\n    this.setState({ renderCount: r + 1 });\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    if (nextProps.pdfUrl !== this.props.pdfUrl) {\r\n      this.setState({ pdfUrl: nextProps.pdfUrl });\r\n      return false;\r\n    }\r\n    // console.log(\"update requested\");\r\n    return true;\r\n  }\r\n\r\n  render() {\r\n    const pdfCanvas: CSSProperties = {\r\n      position: \"absolute\",\r\n      // height: \"100%\",\r\n      // width: \"100%\",\r\n      left: this.state.canvasPosition.offsetX + \"px\",\r\n      top: this.state.canvasPosition.offsetY + \"px\",\r\n      // zoom: this.state.canvasPosition.zoom,\r\n      overflow: \"hidden\",\r\n    }\r\n\r\n    // console.log(this.state.canvasPosition);\r\n    return (\r\n      <div id={\"mixed_view\"} style={{\r\n        // position: \"absolute\",\r\n        left: \"0px\", top: \"0px\",\r\n        flexDirection: \"row-reverse\", display: \"flex\",\r\n        width: \"100%\", height: \"100%\",\r\n        alignItems: \"center\",\r\n        zIndex: 1,\r\n      }}>\r\n        <div id={\"pdf_layer\"} style={pdfCanvas}>\r\n          <NeoPdfViewer\r\n            url={this.state.pdfUrl} pageNo={this.state.pageNo} onReportPdfInfo={this.onReportPdfInfo}\r\n            position={this.state.canvasPosition}\r\n          />\r\n        </div>\r\n        <div id={\"ink_layer\"} style={tempStyle}>\r\n          <PenBasedRenderer\r\n            scale={1}\r\n            pageInfo={{ section: 0, owner: 0, book: 0, page: 0 }}\r\n            playState={PLAYSTATE.live} pens={this.props.pens}\r\n            onNcodePageChanged={this.onNcodePageChanged}\r\n            onCanvasShapeChanged={this.onCanvasShapeChanged}\r\n            ref={this.rendererRef}\r\n          />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\types\\index.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\DefaultOption.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintDataTypes.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Locales\\i18n.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderer.tsx",["471","472","473"],"import React from \"react\";\r\n// import React, { Component } from 'react';\r\n// import PropTypes from \"prop-types\";\r\nimport { InkStorage, PenEventName } from \"../..\";\r\n\r\nimport { PLAYSTATE, IRenderWorkerOption } from \"./RenderWorkerBase\";\r\nimport PenBasedRenderWorker from \"./PenBasedRenderWorker\";\r\n// import { Paper } from \"@material-ui/core\";\r\nimport { NeoSmartpen, PenManager } from \"../../index\";\r\nimport * as UTIL from \"../../utils/UtilsFunc\";\r\n\r\n\r\nimport { IPageSOBP, ISize } from \"../../DataStructure/Structures\";\r\nimport { ZoomFitEnum } from \"./StorageRenderWorker\";\r\n// import { Util } from \"pdfjs-dist\";\r\n\r\nexport { PLAYSTATE };\r\n\r\n\r\n/**\r\n * Properties\r\n */\r\ntype Props = {\r\n  pageInfo: IPageSOBP,\r\n  inkStorage?: InkStorage,\r\n  playState?: PLAYSTATE,\r\n  pens?: NeoSmartpen[],\r\n\r\n  scale?: number,\r\n  width?: number;\r\n  height?: number;\r\n\r\n  viewFit?: ZoomFitEnum;\r\n\r\n  onNcodePageChanged: (arg: { section, owner, book, page }) => void;\r\n  onCanvasShapeChanged: (arg: { offsetX, offsetY, zoom }) => void;\r\n}\r\n\r\n\r\n/**\r\n * State\r\n */\r\ninterface State {\r\n  renderer: PenBasedRenderWorker | null,\r\n\r\n  sizeUpdate: number,\r\n  penEventCount: number,\r\n  strokeCount: number,\r\n  liveDotCount: number,\r\n\r\n  pageInfo: {\r\n    section: number,\r\n    owner: number,\r\n    book: number,\r\n    page: number\r\n  },\r\n\r\n  viewFit: ZoomFitEnum,\r\n  pens: NeoSmartpen[],\r\n\r\n  scale: number,\r\n  playState: PLAYSTATE,\r\n\r\n  renderCount: number,\r\n\r\n}\r\n\r\n/**\r\n * TO DO: 2020/11/05\r\n *    1)  Pen에서 Event를 받아 실시간 rendering만 하는 component로 만들것\r\n *\r\n */\r\nexport default class PenBasedRenderer extends React.Component<Props, State> {\r\n  state: State = {\r\n    renderer: null,\r\n    sizeUpdate: 0,\r\n    penEventCount: 0,\r\n    strokeCount: 0,\r\n    liveDotCount: 0,\r\n\r\n    pageInfo: {\r\n      section: -1,\r\n      owner: -1,\r\n      book: -1,\r\n      page: -1,\r\n    },\r\n\r\n    viewFit: ZoomFitEnum.ACTUAL,\r\n\r\n    /** @type {Array.<NeoSmartpen>} */\r\n    pens: [],\r\n    scale: 1,\r\n\r\n    playState: PLAYSTATE.live,\r\n\r\n    renderCount: 0,\r\n  };\r\n\r\n  propsSize: { scale: number, width: number, height: number } = { scale: 1, width: 0, height: 0 };\r\n  size: ISize = { width: 0, height: 0 };\r\n\r\n  canvasId = \"\";\r\n  canvasRef: React.RefObject<HTMLCanvasElement> = null;\r\n  myRef: React.RefObject<HTMLDivElement> = null;\r\n\r\n  inkStorage: InkStorage = null;\r\n  curr_pens: NeoSmartpen[] = new Array(0);\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    // kitty\r\n    this.canvasRef = React.createRef();\r\n    this.myRef = React.createRef();\r\n\r\n    const { pageInfo, inkStorage, scale, playState, width, height, pens, viewFit } = props;\r\n    this.inkStorage = inkStorage ? inkStorage : InkStorage.getInstance();\r\n\r\n    this.state.pageInfo = pageInfo ? pageInfo : this.state.pageInfo;\r\n    this.state.scale = scale ? scale : this.state.scale;\r\n    this.state.playState = playState ? playState : this.state.playState;\r\n    this.state.viewFit = viewFit ? viewFit : this.state.viewFit;\r\n\r\n    this.canvasId = UTIL.uuidv4();\r\n\r\n    this.curr_pens = pens;\r\n    this.propsSize = { scale, width, height };\r\n  }\r\n\r\n\r\n  /**\r\n   * @private\r\n   * @param {NeoSmartpen} pen\r\n   */\r\n  private subscribePenEvent = (pen: NeoSmartpen) => {\r\n    pen.addEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown);\r\n    pen.addEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo);\r\n    pen.addEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove);\r\n    pen.addEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp);\r\n    pen.addEventListener(PenEventName.ON_HOVER_MOVE, this.onLiveHoverMove);\r\n    pen.addEventListener(PenEventName.ON_PEN_HOVER_PAGEINFO, this.onLiveHoverPageInfo);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {NeoSmartpen} pen\r\n   */\r\n  private unsubscribePenEvent = (pen: NeoSmartpen) => {\r\n    pen.removeEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown);\r\n    pen.removeEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo);\r\n    pen.removeEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove);\r\n    pen.removeEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp);\r\n    pen.removeEventListener(PenEventName.ON_HOVER_MOVE, this.onLiveHoverMove);\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * @override\r\n   * @public\r\n   */\r\n  componentDidMount() {\r\n    const { pens } = this.props;\r\n    let { width, height } = this.propsSize;\r\n\r\n    const node = this.myRef.current;\r\n    if (node) {\r\n      const parentHeight = node.offsetHeight;\r\n      const parentWidth = node.offsetWidth;\r\n\r\n      console.log(`Parent window (width, height) = (${parentWidth}, ${parentHeight})`);\r\n\r\n      if (!width || !height) {\r\n        width = parentWidth;\r\n        height = parentHeight;\r\n        this.propsSize = { width, height, scale: this.propsSize.scale };\r\n\r\n        const renderCount = this.state.renderCount;\r\n        this.setState({ renderCount: renderCount + 1 });\r\n      }\r\n    }\r\n\r\n    // let size = this.size;\r\n\r\n    /** @type {{pageId:number, width:number, height:number, pens:Array.<NeoSmartpen> }} */\r\n\r\n    // let rect = { x: 0, y: 0, width, height };\r\n\r\n    // const page = pages.filter((p) => p.pageNumber === pageId)[0];\r\n    // console.log(\"Draw Stroke size\", pageId, \"canvas size\", size, \"rect\", rect);\r\n\r\n    console.log(`PenBasedRenderer: size ${this.propsSize.width}, ${this.propsSize.height}`);\r\n\r\n    console.log(\"Renderer Inited\");\r\n    this.initRenderer(this.propsSize);\r\n    window.addEventListener(\"resize\", this.resizeListener);\r\n\r\n    // subscribe all event from pen\r\n    pens.forEach(pen => {\r\n      console.log(`PenBasedRenderer: componentDidMount, EventSubscribing`);\r\n      this.subscribePenEvent(pen)\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * @override\r\n   * @public\r\n   */\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    let ret_val = true;\r\n\r\n    if (nextProps.pens !== this.curr_pens) {\r\n      /** @type {Array<NeoSmartpen>} */\r\n      const new_pens = nextProps.pens;\r\n\r\n      /** @type {Array<NeoSmartpen>} */\r\n      const curr_pens = this.curr_pens;\r\n\r\n      // subscribe all event from pen\r\n      new_pens.forEach(pen => {\r\n        console.log(`PenBasedRenderer: shouldComponentUpdate, EventSubscribing`);\r\n        const index = curr_pens.indexOf(pen);\r\n        if (index < 0) {\r\n          this.subscribePenEvent(pen)\r\n        }\r\n      });\r\n\r\n      this.curr_pens = nextProps.pens;\r\n\r\n      ret_val = true;\r\n    }\r\n\r\n    return ret_val;\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   * @public\r\n   */\r\n  componentWillUnmount() {\r\n    /** @type {Array.<NeoSmartpen>} */\r\n    const pens = this.props.pens;\r\n    pens.forEach(pen => this.unsubscribePenEvent(pen));\r\n\r\n    // this.state.renderer.stopInterval();\r\n    window.removeEventListener(\"resize\", this.resizeListener);\r\n\r\n    // penManager에 연결 해제\r\n    const penManager = PenManager.getInstance();\r\n    penManager.unregisterRenderContainer(this);\r\n  }\r\n\r\n\r\n  resizeListener = () => {\r\n    this.setState({ sizeUpdate: this.state.sizeUpdate + 1 });\r\n\r\n    // const { classes, scaleType, scale } = this.props;\r\n\r\n    const { scale, width, height } = this.propsSize;\r\n\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    // const { penEventCount } = this.state;\r\n    this.size = this.getSize(scale, rect);\r\n\r\n    if (this.state.renderer) {\r\n      // console.log(\"render resize\", this.size)\r\n      this.state.renderer.resize(this.size);\r\n    }\r\n  };\r\n\r\n\r\n\r\n  initRenderer(size: { width: number, height: number }) {\r\n    /** @type {{width:number, height:number}} */\r\n    const { width, height } = size;\r\n\r\n    // const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    // const page = pages.filter((p) => p.pageNumber === pageId)[0];\r\n\r\n    // const inkStorage = this.inkStorage;\r\n    const options: IRenderWorkerOption = {\r\n      canvasId: this.canvasId,\r\n      canvasRef: this.canvasRef,\r\n      width,\r\n      height,\r\n      viewFit: this.state.viewFit,\r\n      onCanvasShapeChanged: this.props.onCanvasShapeChanged,\r\n    };\r\n\r\n    const renderer = new PenBasedRenderWorker(options);\r\n    this.setState({ renderer: renderer });\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, time:number, stroke:NeoStroke}} event\r\n   */\r\n  onLivePenDown = (event) => {\r\n    // console.log(event);\r\n    if (this.state.renderer) {\r\n      this.state.renderer.createLiveStroke(event);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, section:number, owner:number, book:number, page:number}} event\r\n   */\r\n  onLivePenPageInfo = (event) => {\r\n    const { penEventCount } = this.state;\r\n    const { section, owner, book, page } = event;\r\n\r\n    const prevPageInfo = this.state.pageInfo;\r\n    if (UTIL.isSamePage(prevPageInfo, event)) {\r\n      return;\r\n    }\r\n\r\n    /** 내부 상태를 바꾼다. */\r\n    this.setState({\r\n      penEventCount: penEventCount + 1,\r\n      pageInfo: { section, owner, book, page }\r\n    });\r\n\r\n    /** 테스트용 */\r\n    const inkStorage = this.inkStorage;\r\n    if (inkStorage) {\r\n      const pageStrokesCount = inkStorage.getPageStrokes(event).length;\r\n      this.setState({ strokeCount: pageStrokesCount });\r\n    }\r\n\r\n    /** 잉크 렌더러의 페이지를 바꾼다 */\r\n    if (this.state.renderer) {\r\n      this.state.renderer.changePage(section, owner, book, page, false);\r\n    }\r\n\r\n    /** pdf pageNo를 바꿀 수 있게, container에게 전달한다. */\r\n    this.props.onNcodePageChanged({ section, owner, book, page });\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, dot:NeoDot}} event\r\n   */\r\n\r\n  onLivePenMove = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.pushLiveDot(event);\r\n    }\r\n    // const { liveDotCount } = this.state;\r\n\r\n    // this.setState({ liveDotCount: liveDotCount + 1 });\r\n    // console.log(event);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, stroke, section:number, owner:number, book:number, page:number}} event\r\n   */\r\n  onLivePenUp = (event) => {\r\n    console.log(\"Pen Up\");\r\n    if (this.state.renderer) {\r\n      this.state.renderer.closeLiveStroke(event);\r\n    }\r\n\r\n    // const { penEventCount, inkStorage } = this.state;\r\n    // this.setState({ penEventCount: penEventCount + 1 });\r\n    // if (inkStorage) {\r\n    //   let pageStrokesCount = inkStorage.getPageStrokes(event).length;\r\n    //   this.setState({ strokeCount: pageStrokesCount });\r\n    // }\r\n    // console.log(event);\r\n  }\r\n\r\n  onLiveHoverPageInfo = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.addHoverPoints(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, dot:NeoDot}} event\r\n   */\r\n\r\n  onLiveHoverMove = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.moveHoverPoint(event);\r\n    }\r\n    // const { liveDotCount } = this.state;\r\n\r\n    // this.setState({ liveDotCount: liveDotCount + 1 });\r\n    // console.log(event);\r\n  }\r\n\r\n  getSize = (scale, rect) => {\r\n    const size = {\r\n      width: rect.width,\r\n      height: rect.height,\r\n    };\r\n\r\n    return size;\r\n  };\r\n\r\n  render() {\r\n    // const { classes, scaleType, scale } = this.props;\r\n    const { pens } = this.props;\r\n    const { scale, width, height } = this.propsSize;\r\n    const { section, owner, book, page } = this.state.pageInfo;\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    const { penEventCount } = this.state;\r\n    this.size = this.getSize(scale, rect);\r\n\r\n    // const manager = PenManager.getInstance();\r\n    // let connected_pens = manager.getConnectedPens();\r\n\r\n    const dpr = UTIL.getDisplayRatio();\r\n    // const windowWidth = window.innerWidth / dpr;\r\n    const windowHeight = window.innerHeight / dpr;\r\n    const aWidth = document.body.clientWidth;\r\n    // const aWidth2 = document.body.scrollWidth;\r\n    const aHeight = windowHeight;\r\n\r\n    const statusBarHeight = 400;\r\n\r\n    return (\r\n      <div id=\"replayContainer\" ref={this.myRef} style={{ position: \"relative\" }}>\r\n        <div style={{\r\n          zIndex: 99,\r\n          display: \"flex\", flexDirection: \"column\",\r\n        }}>\r\n\r\n          <div style={{\r\n            height: statusBarHeight + \"px\",\r\n            display: \"flex\", flexDirection: \"column\",\r\n            justifyContent: \"flex-start\",\r\n            alignItems: \"flex-start\",\r\n          }}>\r\n            <div>\r\n              <ul>\r\n                {pens.map((pen, i) => (\r\n                  <li key={i}>{pen.mac}</li>\r\n                ))}\r\n              </ul>\r\n            </div>\r\n            <div style={{ fontSize: \"20px\", fontWeight: \"bold\", color: \"rgba(255,0,0,255)\" }}>\r\n              PenBasedRenderer{section}.{owner}.{book}.{page}:{penEventCount}\r\n            </div>\r\n          </div>\r\n\r\n        </div>\r\n\r\n\r\n        <div style={{\r\n          zIndex: 5,\r\n          position: \"relative\",\r\n          left: \"0px\",\r\n          top: -statusBarHeight + \"px\",\r\n        }}>\r\n          {/* <Paper style={{ height: this.size.height, width: this.size.width }}> */}\r\n          <canvas id={this.canvasId} ref={this.canvasRef}\r\n            style={{\r\n              width: width ? width : aWidth,\r\n              height: height ? height : aHeight\r\n            }} />\r\n          {/* </Paper> */}\r\n        </div>\r\n      </div >\r\n    );\r\n  }\r\n}\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\Upload.js",["474","475","476","477"],"/* eslint-disable no-unused-vars */\r\nimport React from 'react';\r\nimport { gapi } from 'gapi-script';\r\nimport { GoogleLogin } from 'react-google-login';\r\nimport * as PdfJs from \"pdfjs-dist\";\r\n\r\nimport { resolve } from 'path';\r\n\r\nconst FOLDER_ID = \"root\";\r\n\r\nexport default class Upload extends React.Component {\r\n  \r\n  mappingInfoUploadProcess = async () => {\r\n    const self = this;\r\n    let folderId;\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', async function () {\r\n        const folderResponse = await gapi.client.drive.files.list({\r\n          q: \"mimeType = 'application/vnd.google-apps.folder'\" //폴더만 걸러주는 filter\r\n        })\r\n\r\n        const folders = folderResponse.result.items;\r\n        let isGridaFolderExist = false;\r\n\r\n        if (folders && folders.length > 0) {\r\n          for (let i = 0; i < folders.length; i++) {\r\n            const folder = folders[i];\r\n            if (folder.title === 'Grida') {\r\n              isGridaFolderExist = true;\r\n              // folderId = folderId;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (isGridaFolderExist) {\r\n          //mappingInfo.json 있는지 확인 후 없으면\r\n          const fileResponse = await gapi.client.drive.files.list();\r\n          const files = fileResponse.result.items;\r\n          let isMappingFileExist = false;\r\n          if (files && files.length > 0) {\r\n            for (let i = 0; i < files.length; i++) {\r\n              const file = files[i];\r\n              if (file.title === 'mappingInfo.json') {\r\n                const fileId = file.id;\r\n                const getFileRequest = gapi.client.drive.files.get({\r\n                  fileId: fileId,\r\n                  alt: 'media'\r\n                })\r\n                let content = `\r\n                  {\"sobp\" : {\"s\":3,\"o\":281,\"b\":123,\"p\":2},\r\n                   \"pdf_info\" : {\"file_name\" : \"filename\",\"fp\" : \"finger print\"}\r\n                  }\r\n                `; //여기에다가 새로운 content 내용을 받을거야\r\n                getFileRequest.then(await function(response) {\r\n\r\n                  const currentMappingObj = JSON.parse(response.body);\r\n                  const newMappingObj = JSON.parse(content);\r\n\r\n                  currentMappingObj.mapping_info.push(newMappingObj);\r\n                  \r\n                  content = JSON.stringify(currentMappingObj);\r\n                  \r\n                  const contentBlob = new Blob([content], {'type': 'application/json'});\r\n                  self.updateMappingInfo(fileId, contentBlob, function(resp) {\r\n                    console.log(\"updateMappingInfo callback called\");\r\n                  });\r\n                }, function(error) {\r\n                  console.error(error)\r\n                })\r\n                isMappingFileExist = true;\r\n                break;\r\n              } \r\n              if (!isMappingFileExist) {\r\n                self.createNewMappingInfo(folderId);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        else if (!isGridaFolderExist) {\r\n          await self.createGridaFolder();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  updateMappingInfo = (fileId, contentBlob, callback) => {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.responseType = 'json';\r\n    xhr.onreadystatechange = function() {\r\n      if (xhr.readyState != XMLHttpRequest.DONE) {\r\n        return;\r\n      }\r\n      callback(xhr.response);\r\n    };\r\n    xhr.open('PATCH', 'https://www.googleapis.com/upload/drive/v3/files/' + fileId + '?uploadType=media');\r\n    xhr.setRequestHeader('Authorization', 'Bearer ' + gapi.auth.getToken().access_token);\r\n    xhr.send(contentBlob);\r\n  }\r\n\r\n  createNewMappingInfo = async (folderId) => {\r\n    const fileContent = `\r\n    {\"mapping_info\":[\r\n      {\"sobp\" : {\"s\":3,\"o\":281,\"b\":123,\"p\":1},\r\n       \"pdf_info\" : {\"file_name\" : \"filename\",\"fp\" : \"finger print\"}\r\n      }\r\n    ]}`; //sobp object와 pdf info를 object로 받아서 stringfy해준 뒤 fileContent에 삽입\r\n    const file = new Blob([fileContent], {type: 'text/plain'});\r\n    const metadata = {\r\n        'name': 'mappingInfo.json', // Filename at Google Drive\r\n        'mimeType': 'application/json', // mimeType at Google Drive\r\n        'parents': [folderId], // Folder ID at Google Drive\r\n    };\r\n    \r\n    const accessToken = gapi.auth.getToken().access_token; // Here gapi is used for retrieving the access token.\r\n\r\n    const form = new FormData();\r\n    form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));\r\n    form.append('file', file);\r\n    \r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open('post', 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id');\r\n    xhr.setRequestHeader('Authorization', 'Bearer ' + accessToken);\r\n    xhr.responseType = 'json';\r\n    xhr.onload = () => {\r\n        console.log('mapping info file id : ');\r\n        console.log(xhr.response.id); // Retrieve uploaded file ID.\r\n    };\r\n    xhr.send(form);\r\n  }\r\n\r\n  createGridaFolder = async () => {\r\n    const self = this;\r\n    const access_token = gapi.auth.getToken().access_token;\r\n\r\n    const request = gapi.client.request({\r\n        'path': '/drive/v2/files/',\r\n        'method': 'POST',\r\n        'headers': {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': 'Bearer ' + access_token,             \r\n        },\r\n        'body':{\r\n            \"title\" : \"Grida\",\r\n            \"mimeType\" : \"application/vnd.google-apps.folder\",\r\n        }\r\n    });\r\n\r\n    request.execute(await function(resp) { \r\n      self.createNewMappingInfo(resp.id);\r\n    });\r\n  }\r\n\r\n  listFiles = () => {\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', function () {\r\n\r\n        let fileId = \"\";\r\n\r\n        gapi.client.drive.files.list({\r\n          'pageSize': 10,\r\n          'fields': \"*\"\r\n        }).then(function(response) {\r\n          console.log(response);\r\n          const files = response.result.items;\r\n          console.log(response.result.items);\r\n    \r\n          if (files && files.length > 0) {\r\n            for (let i = 0; i < files.length; i++) {\r\n              const file = files[i];\r\n              if (file.title === 'hi.pdf') {\r\n                console.log('file : ');\r\n                console.log(file);\r\n                fileId = file.id;\r\n              }\r\n            }\r\n          }\r\n\r\n          const request = gapi.client.drive.files.get({\r\n            fileId: fileId,\r\n            alt: 'media'\r\n          })\r\n          request.then(function(response) {\r\n            console.log(response);\r\n          }, function(error) {\r\n            console.error(error)\r\n          })\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  readMappingInfo = () => {\r\n\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', async function () {\r\n        const fileResponse = await gapi.client.drive.files.list();\r\n        const files = fileResponse.result.items;\r\n\r\n        if (files && files.length > 0) {\r\n          for (let i = 0; i < files.length; i++) {\r\n            const file = files[i];\r\n            if (file.title === 'mappingInfo.json') {\r\n              const fileId = file.id;\r\n              const getFileRequest = gapi.client.drive.files.get({\r\n                fileId: fileId,\r\n                alt: 'media'\r\n              })\r\n\r\n              getFileRequest.then(await function(response) {\r\n                const currentMappingObj = JSON.parse(response.body);\r\n                const content = JSON.stringify(currentMappingObj);\r\n                console.log(content);\r\n              }, function(error) {\r\n                console.error(error)\r\n              })\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  readPDF = () => {\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', async function () {\r\n        const fileResponse = await gapi.client.drive.files.list();\r\n        const files = fileResponse.result.items;\r\n\r\n        if (files && files.length > 0) {\r\n          for (let i = 0; i < files.length; i++) {\r\n            const file = files[i];\r\n            const fileId = file.id;\r\n            const getFileRequest = gapi.client.drive.files.get({\r\n              fileId: fileId,\r\n              alt: 'media',\r\n            });\r\n\r\n            if (file.mimeType === 'application/pdf') {\r\n              console.log(getFileRequest);\r\n              console.log(file.mimeType);\r\n\r\n              getFileRequest.then(await function(response) {\r\n                const docInitParams = { data: response.body };\r\n                PdfJs.getDocument(docInitParams).promise.then(function(pdf) {\r\n                  console.log('finger : ');\r\n                  console.log(pdf.fingerprint);\r\n                });\r\n              }, function(error) {\r\n                console.error(error)\r\n              })\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  render() {\r\n      return (\r\n        <div>\r\n        <button id=\"mapping_info_process\" onClick={this.mappingInfoUploadProcess}>\r\n          Upload Mapping Info\r\n        </button>\r\n        <button id=\"read_mapping_info\" onClick={this.readMappingInfo}>\r\n          Read Mapping Info\r\n        </button>\r\n        <button id=\"read_mapping_info\" onClick={this.readPDF}>\r\n          Read PDF\r\n        </button>\r\n          <GoogleLogin \r\n            clientId=\"169738066451-5u100n2i6rko17jhmtpvq0bnjuedj7g4.apps.googleusercontent.com\"\r\n            buttonText=\"Login\"\r\n            onSuccess={this.responseGoogle}\r\n            onFailure={this.responseGoogle}\r\n            cookiePolicy={'single_host_origin'}\r\n          />\r\n        </div>\r\n      )\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\CanvasColorConverter.ts",["478","479","480"],"\r\nconst LUMINANCE_MAX_RATIO = 0.8;\r\nexport enum ColorConvertMethod {\r\n  BLUEPRINT,\r\n  ANDROID_STYLE,\r\n  IPHONE_STYLE,\r\n}\r\n\r\n/**\r\n * Class\r\n */\r\nexport default class CanvasColorConverter {\r\n  canvas: HTMLCanvasElement;\r\n\r\n  constructor(canvas: HTMLCanvasElement) {\r\n    this.canvas = canvas;\r\n  }\r\n\r\n  convert = (method = ColorConvertMethod.ANDROID_STYLE): Promise<void> => {\r\n    const canvas = this.canvas;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    const id = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n    const { width, height } = canvas;\r\n\r\n    const promises = new Array(0);\r\n\r\n    if (method === ColorConvertMethod.BLUEPRINT) {\r\n      for (let y = 0; y < height; y++) {\r\n        const pr = this.convertSingleRow(id.data, y, width);\r\n        promises.push(pr);\r\n      }\r\n    }\r\n    else {\r\n      for (let y = 0; y < height; y++) {\r\n        const pr = this.ConvertRgb_A3(id.data, y, width);\r\n        promises.push(pr);\r\n      }\r\n    }\r\n\r\n    return new Promise(resolve => {\r\n      Promise.all(promises).then(() => {\r\n        // console.log(\"End convert\");\r\n        ctx.putImageData(id, 0, 0);\r\n        resolve();\r\n      });\r\n    })\r\n  }\r\n\r\n  private ConvertRgb_A3 = (data: Uint8ClampedArray, row: number, width: number): Promise<void> => {\r\n    const byteWidth = width * 4;\r\n    const pixelAddr = byteWidth * row;\r\n    const pixelAddrEnd = pixelAddr + byteWidth;\r\n    const luminanceOffset = 255 * (1 - LUMINANCE_MAX_RATIO);\r\n\r\n    return new Promise(resolve => {\r\n      for (let i = pixelAddr; i < pixelAddrEnd; i += 4) {\r\n        let r = data[i];        // red\r\n        let g = data[i + 1];      // green\r\n        let b = data[i + 2];      // blue\r\n        let luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) * LUMINANCE_MAX_RATIO;\r\n        luminance += luminanceOffset;\r\n\r\n\r\n        if (r < g) {\r\n          if (g <= b + 10) {\r\n            b = 0xff;\r\n            r = g = luminance;\r\n          } else {\r\n            g = 0xff;\r\n            r = b = luminance;\r\n          }\r\n        } else {\r\n          if (r <= b + 10) {\r\n            b = 0xff;\r\n            r = g = luminance;\r\n\r\n          } else {\r\n            r = 0xff;\r\n            g = b = luminance;\r\n          }\r\n        }\r\n\r\n        data[i] = r;\r\n        data[i + 1] = g;\r\n        data[i + 2] = b;\r\n        data[i + 3] = 255;   // alpha\r\n\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  private convertSingleRow = (data: Uint8ClampedArray, row: number, width: number): Promise<void> => {\r\n    const byteWidth = width * 4;\r\n    const pixelAddr = byteWidth * row;\r\n    const pixelAddrEnd = pixelAddr + byteWidth;\r\n    const luminanceOffset = 255 * (1 - LUMINANCE_MAX_RATIO);\r\n\r\n    return new Promise(resolve => {\r\n      for (let i = pixelAddr; i < pixelAddrEnd; i += 4) {\r\n        const r = data[i];        // red\r\n        const g = data[i + 1];      // green\r\n        const b = data[i + 2];      // blue\r\n        let luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) * LUMINANCE_MAX_RATIO;\r\n        luminance += luminanceOffset;\r\n\r\n        data[i] = luminance;\r\n        data[i + 1] = luminance;\r\n        data[i + 2] = 255;\r\n        data[i + 3] = 255;   // alpha\r\n\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\RenderWorkerBase.tsx",["481","482","483","484","485","486","487","488","489","490"],"import \"../../types\";\r\nimport { fabric } from \"fabric\";\r\nimport { InkStorage } from \"../..\";\r\nimport { PATH_THICKNESS_SCALE } from \"./DrawCurves\";\r\n// import { NCODE_TO_SCREEN_SCALE } from \"../../constants\";\r\nimport { IWritingSurfaceInfo, ISize } from \"../../DataStructure/Structures\";\r\nimport { ncodeToDisplayPixel } from \"../../utils/UtilsFunc\";\r\nimport { ZoomFitEnum } from \"./StorageRenderWorker\";\r\n// import { paperInfo } from \"../../noteserver/PaperInfo\";\r\n// import { plugToRequest } from \"react-cookies\";\r\n// import { scaleCanvas } from \"../../utils/UtilsFunc\";\r\n// import { IRectOptions } from \"fabric/fabric-impl\";\r\n\r\n// const timeTickDuration = 20; // ms\r\n// const DISABLED_STROKE_COLOR = \"rgba(0, 0, 0, 0.1)\";\r\n// const INVISIBLE_STROKE_COLOR = \"rgba(255, 255, 255, 0)\";\r\n// const INCOMPLETE_STROKE_COLOR = \"rgba(255, 0, 255, 0.4)\";\r\n// const CURRENT_POINT_STROKE_COLOR = \"rgba(255, 255, 255, 1)\";\r\n\r\n\r\nexport enum PLAYSTATE {\r\n  live,\r\n  play,\r\n  stop,\r\n  pause,\r\n  rewind,\r\n  trackRewind,\r\n  setAutoStop,\r\n  unsetAutoStop,\r\n}\r\n\r\nexport type IRenderWorkerOption = {\r\n  canvasId: string,\r\n\r\n  canvasRef: React.RefObject<HTMLCanvasElement>,\r\n  width: number,\r\n  height: number,\r\n  viewFit: ZoomFitEnum,\r\n  bgColor?: string,\r\n  mouseAction?: boolean,\r\n  shouldDisplayGrid?: boolean,\r\n  storage?: InkStorage,\r\n\r\n  onCanvasShapeChanged: (arg: { offsetX, offsetY, zoom }) => void,\r\n}\r\n\r\n/**\r\n * @enum {string}\r\n */\r\n\r\n// const STROKE_OBJECT_ID = \"ns\";\r\nconst GRID_OBJECT_ID = \"g\";\r\n\r\n/**\r\n * @typedef {Object} RenderWorkerOption\r\n * @property {string} canvasId\r\n * @property {number} width\r\n * @property {number} height\r\n * @property {string} [bgColor]\r\n * @property {boolean} [mouseAction]\r\n * @property {ZoomFitEnum} [viewFit]\r\n * @property {boolean} [shouldDisplayGrid]\r\n * @property {InkStorage} [storage]\r\n *\r\n */\r\n\r\nexport default class RenderWorkerBase {\r\n\r\n  name: string;\r\n  /** canvas element ID */\r\n  canvasId = \"\";\r\n\r\n  canvasRef: React.RefObject<HTMLCanvasElement>;\r\n\r\n  /** background color */\r\n  bgColor = \"rgba(255,255,255,0)\";\r\n\r\n  /** the size when first initied */\r\n  initialSize: { width: number, height: number } = { width: 0, height: 0 };\r\n\r\n  /** the size after resize */\r\n  currSize: { width: number, height: number } = { width: 0, height: 0 };\r\n\r\n  /** FabricJs canvas */\r\n  canvasFb: fabric.Canvas = null;\r\n\r\n  /** mouse에 따라 pan, zoom이 가능한지에 대한 여부 */\r\n  mouseAction = true;\r\n\r\n  /**  mouse에 따라 pan, zoom이 가능한지에 대한 여부 */\r\n  zoomCtrlKey = false;\r\n\r\n  /** mouse drag & panning 을 위해 */\r\n  pan: { isDragging: boolean, lastPosX: number, lastPosY: number } = {\r\n    isDragging: false,\r\n    lastPosX: 0,\r\n    lastPosY: 0,\r\n  };\r\n\r\n  /** pen stroke에 따라 자동 focus를 맞추도록 */\r\n  autoFocus = true;\r\n\r\n  /** <canvas>내의 drawing canvas(fabric canvas)의 offset, 현재는 안 씀 - 2020/11/08*/\r\n  offset: { x: number, y: number } = { x: 0, y: 0 };\r\n\r\n  /** 종이 정보 */\r\n  surfaceInfo: IWritingSurfaceInfo = {\r\n    section: 3,\r\n    owner: 27,\r\n    book: 168,\r\n    page: 1,\r\n\r\n    Xmin: 3.12,   // code unit\r\n    Ymin: 3.12,\r\n    Xmax: 91.68,\r\n    Ymax: 128.36,\r\n    Mag: 1,\r\n  };\r\n\r\n  /** Ncode to Screen scale */\r\n  base_scale: number;\r\n\r\n  /** logical zoom in/out */\r\n  scale = 1;\r\n\r\n  /** zoom fit */\r\n  viewFit: ZoomFitEnum = ZoomFitEnum.ACTUAL;\r\n\r\n  /** determine whether border and grid lines displayed or not */\r\n  shouldDisplayGrid = true;\r\n\r\n  /** animation timer */\r\n  scrollAnimateTimer: number = null;\r\n  options: IRenderWorkerOption;\r\n\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {RenderWorkerOption} options\r\n   */\r\n  constructor(options: IRenderWorkerOption) {\r\n    const { canvasId, canvasRef, width, height, bgColor, mouseAction, viewFit, shouldDisplayGrid } = options;\r\n\r\n    this.name = \"RenderWorkerBase\";\r\n\r\n    if (typeof canvasId !== \"string\") {\r\n      throw new Error(\"canvasId should be a string\");\r\n    }\r\n\r\n    this.canvasId = canvasId;\r\n    this.canvasRef = canvasRef;\r\n\r\n    this.initialSize = { width, height };\r\n    this.currSize = { width, height };\r\n\r\n    this.base_scale = ncodeToDisplayPixel(1);\r\n    this.scale = 1;\r\n\r\n    this.canvasFb = null;\r\n\r\n    if (bgColor !== undefined) this.bgColor = bgColor;\r\n    if (typeof (mouseAction) === \"boolean\") this.mouseAction = mouseAction;\r\n\r\n    if (viewFit) {\r\n      this.viewFit = viewFit;\r\n    }\r\n    else {\r\n      this.viewFit = ZoomFitEnum.ACTUAL;\r\n    }\r\n\r\n    if (typeof (shouldDisplayGrid) === \"boolean\") this.shouldDisplayGrid = shouldDisplayGrid;\r\n\r\n    this.options = options;\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  init = () => {\r\n    const size = this.currSize;\r\n\r\n    // let HtmlCanvas = this.canvasRef.current;\r\n    // const dpr = getDisplayRatio();\r\n    // scaleCanvas(HtmlCanvas);\r\n    const dpr = 1;\r\n\r\n    console.log(`Fabric canvas inited: size(${size.width}, ${size.height})`);\r\n\r\n    this.canvasFb = new fabric.Canvas(this.canvasId, {\r\n\r\n      backgroundColor: this.bgColor ? this.bgColor : \"rgba(255,255,0,0.5)\",\r\n      selection: false,\r\n      controlsAboveOverlay: false,\r\n      selectionLineWidth: 4,\r\n      width: size.width * dpr,\r\n      height: size.height * dpr,\r\n\r\n    });\r\n\r\n    const canvasFb = this.canvasFb;\r\n\r\n    if (this.mouseAction) {\r\n      canvasFb.on('mouse:down', this.onCanvasMouseDown);\r\n      canvasFb.on('mouse:move', this.onCanvasMouseMove);\r\n      canvasFb.on('mouse:up', this.onCanvasMousUp);\r\n      canvasFb.on('mouse:wheel', this.onCanvasMouseWheel);\r\n    }\r\n\r\n    this.drawPageLayout();\r\n  }\r\n\r\n  getSurfaceSize_CSS = (): ISize => {\r\n    const { Xmin, Xmax, Ymin, Ymax } = this.surfaceInfo;\r\n    const ncode_width = Xmax - Xmin;\r\n    const ncode_height = Ymax - Ymin;\r\n\r\n    const actual_width = ncodeToDisplayPixel(ncode_width);\r\n    const actual_height = ncodeToDisplayPixel(ncode_height);\r\n    const s: ISize = {\r\n      width: actual_width * this.scale,\r\n      height: actual_height * this.scale,\r\n    };\r\n\r\n    return s;\r\n  }\r\n\r\n  drawPageLayout = () => {\r\n    if (!this.shouldDisplayGrid) return;\r\n    const canvasFb = this.canvasFb;\r\n\r\n    // 지우기\r\n    if (this.canvasFb) {\r\n      const objects = this.canvasFb.getObjects();\r\n      const strokes = objects.filter(obj => obj.data === GRID_OBJECT_ID);\r\n\r\n      strokes.forEach((obj) => {\r\n        this.canvasFb.remove(obj);\r\n      });\r\n    }\r\n\r\n    // 그리기\r\n    const size = this.getSurfaceSize_CSS();\r\n    console.log(`drawPageLayout: ${size.width}, ${size.height}`);\r\n\r\n    // console.log(`Grid: scale=${this.base_scale} (width, height)=(${size.width}, ${size.height})`);\r\n\r\n    const ratio = 1;\r\n\r\n    const rect = new fabric.Rect({\r\n      width: size.width * ratio - 5,\r\n      height: size.height * ratio - 5,\r\n      strokeWidth: 5,\r\n      stroke: 'rgba(0,0,0,1)',\r\n      fill: 'rgb(100,100,200, 0.1)',\r\n      left: size.width * (1 - ratio) * 0.5,\r\n      top: size.height * (1 - ratio) * 0.5,\r\n      // lockMovementX: true,\r\n      // lockMovementY: true,\r\n      selectable: false,\r\n      data: GRID_OBJECT_ID,\r\n\r\n    });\r\n    canvasFb.add(rect);\r\n\r\n    for (let x = 0; x < size.width; x += 10) {\r\n      const line = new fabric.Line([x, 0, x, size.height], {\r\n        strokeWidth: 0.5,\r\n        stroke: \"rgba(0,0,0,0.1)\",\r\n        hasControls: false,\r\n        hasBorders: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        data: GRID_OBJECT_ID,\r\n      });\r\n\r\n      canvasFb.add(line);\r\n    }\r\n\r\n\r\n    for (let y = 0; y < size.height; y += 10) {\r\n      const line = new fabric.Line([0, y, size.width, y], {\r\n        strokeWidth: 0.5,\r\n        stroke: \"rgba(0,0,0,0.1)\",\r\n        hasControls: false,\r\n        hasBorders: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        data: GRID_OBJECT_ID,\r\n      });\r\n\r\n      canvasFb.add(line);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * enable/disable mouse drag panning and zoom in/out\r\n   * default: true\r\n   *\r\n   * @public\r\n   * @param {boolean} sw\r\n   */\r\n  enableMouseAction = (sw: boolean) => {\r\n    if (this.mouseAction !== sw) {\r\n      const canvasFb = this.canvasFb;\r\n\r\n      if (sw === false) {\r\n\r\n        this.onCanvasMousUp();\r\n\r\n        canvasFb.off('mouse:down', this.onCanvasMouseDown);\r\n        canvasFb.off('mouse:move', this.onCanvasMouseMove);\r\n        canvasFb.off('mouse:up', this.onCanvasMousUp);\r\n        canvasFb.off('mouse:wheel', this.onCanvasMouseWheel);\r\n      }\r\n      else {\r\n        canvasFb.on('mouse:down', this.onCanvasMouseDown);\r\n        canvasFb.on('mouse:move', this.onCanvasMouseMove);\r\n        canvasFb.on('mouse:up', this.onCanvasMousUp);\r\n        canvasFb.on('mouse:wheel', this.onCanvasMouseWheel);\r\n      }\r\n    }\r\n    this.mouseAction = sw;\r\n  }\r\n\r\n  /**\r\n   * enable/disable auto set focus at current stroke point\r\n   * default: true\r\n   *\r\n   * @public\r\n   * @param {boolean} sw\r\n   */\r\n  enableAutoFocus = (sw: boolean) => {\r\n    this.autoFocus = sw;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMouseDown = (opt: any) => {\r\n    const canvasFb = this.canvasFb;\r\n\r\n    const evt: MouseEvent = opt.e;\r\n\r\n    this.pan.isDragging = true;\r\n    this.pan.lastPosX = evt.clientX;\r\n    this.pan.lastPosY = evt.clientY;\r\n\r\n    canvasFb.selection = false;\r\n\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMouseMove = (opt: any) => {\r\n    const canvasFb = this.canvasFb;\r\n\r\n    if (this.pan.isDragging) {\r\n      const e: MouseEvent = opt.e;\r\n      // console.log(`Point ${e.clientX}, ${e.clientY}`);\r\n      const vpt = canvasFb.viewportTransform;\r\n      vpt[4] += e.clientX - this.pan.lastPosX;\r\n      vpt[5] += e.clientY - this.pan.lastPosY;\r\n\r\n      this.scrollBoundaryCheck();\r\n\r\n      // event 전달\r\n      this.reportCanvasChanged();\r\n      // canvas.setViewportTransform(vpt);\r\n      canvasFb.requestRenderAll();\r\n\r\n      this.pan.lastPosX = e.clientX;\r\n      this.pan.lastPosY = e.clientY;\r\n\r\n\r\n\r\n      // this.canvasBoundaryCheck();\r\n    }\r\n  }\r\n\r\n  reportCanvasChanged = () => {\r\n    const canvasFb = this.canvasFb;\r\n    const vpt = canvasFb.viewportTransform;\r\n    const offsetX = vpt[4];\r\n    const offsetY = vpt[5];\r\n\r\n    const zoom = canvasFb.getZoom();\r\n\r\n    this.options.onCanvasShapeChanged({ offsetX, offsetY, zoom });\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMousUp = (opt: any = undefined) => {\r\n    const canvasFb = this.canvasFb;\r\n\r\n\r\n    // on mouse up we want to recalculate new interaction\r\n    // for all objects, so we call setViewportTransform\r\n    canvasFb.setViewportTransform(canvasFb.viewportTransform);\r\n    this.pan.isDragging = false;\r\n    canvasFb.selection = false;\r\n\r\n\r\n    // let vpt = canvas.viewportTransform;\r\n    // console.log(vpt);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMouseWheel = (opt: any) => {\r\n    const evt: MouseEvent = opt.e;\r\n    if ((!this.zoomCtrlKey) || (this.zoomCtrlKey === true && evt.ctrlKey === true)) {\r\n      const canvasFb = this.canvasFb;\r\n\r\n      const delta = opt.e.deltaY;\r\n      let zoom = canvasFb.getZoom();\r\n      zoom *= 0.999 ** delta;\r\n\r\n      this.setCanvasZoom(zoom, opt);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  scrollBoundaryCheck = () => {\r\n\r\n    // const canvasFb = this.canvasFb;\r\n    // const zoom = canvasFb.getZoom();\r\n\r\n    // // http://fabricjs.com/fabric-intro-part-5#pan_zoom\r\n    // let vpt = canvasFb.viewportTransform;\r\n\r\n    // if (vpt[4] >= 0) {\r\n    //   vpt[4] = 0;\r\n    // }\r\n    // else if (vpt[4] < canvasFb.getWidth() - this.currSize.width * zoom) {\r\n    //   vpt[4] = canvasFb.getWidth() - this.currSize.width * zoom;\r\n    // }\r\n\r\n    // if (vpt[5] >= 0) {\r\n    //   vpt[5] = 0;\r\n    // }\r\n    // else if (vpt[5] < canvasFb.getHeight() - this.currSize.height * zoom) {\r\n    //   vpt[5] = canvasFb.getHeight() - this.currSize.height * zoom;\r\n    // }\r\n\r\n    // if (zoom < 1) {\r\n    //   vpt[4] = (this.currSize.width - this.currSize.width * zoom) / 2;\r\n    //   vpt[5] = (this.currSize.height - this.currSize.height * zoom) / 2;\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {number} zoom\r\n   * @param {Object} opt\r\n   */\r\n  setCanvasZoom = (zoom: number, opt: any) => {\r\n    const canvas = this.canvasFb;\r\n\r\n    if (zoom > 20) zoom = 20;\r\n    if (zoom < 0.01) zoom = 0.01;\r\n\r\n    /** @type {fabric.Point} */\r\n    const evt: MouseEvent = opt.e;\r\n    const pt = new fabric.Point(evt.offsetX, evt.offsetY);\r\n    if (opt) canvas.zoomToPoint(pt, zoom);\r\n    else canvas.setZoom(zoom);\r\n\r\n\r\n    opt.e.preventDefault();\r\n    opt.e.stopPropagation();\r\n\r\n    this.scrollBoundaryCheck();\r\n\r\n    // event 전달\r\n    this.reportCanvasChanged();\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number, f?:number}} ncodeXY\r\n   */\r\n  protected getCanvasXY = (ncodeXY: { x: number, y: number, f?: number }) => {\r\n    const { x, y, f } = ncodeXY;\r\n    const { Xmin, Ymin } = this.surfaceInfo;\r\n\r\n    const scale = this.base_scale;\r\n\r\n    const cx = (x - Xmin) * scale + this.offset.x;\r\n    const cy = (y - Ymin) * scale + this.offset.y;\r\n\r\n    return { x: cx, y: cy, f };\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number, f?:number}} ncodeXY\r\n   */\r\n  protected getCanvasXY_scaled = (ncodeXY: { x: number, y: number, f?: number }) => {\r\n    const { x, y, f } = ncodeXY;\r\n    const { Xmin, Ymin } = this.surfaceInfo;\r\n\r\n    const scale = this.base_scale;\r\n\r\n    let cx = (x - Xmin) * scale + this.offset.x;\r\n    let cy = (y - Ymin) * scale + this.offset.y;\r\n\r\n    cx *= PATH_THICKNESS_SCALE;\r\n    cy *= PATH_THICKNESS_SCALE;\r\n\r\n    return { x: cx, y: cy, f };\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number}} canvasXY\r\n   */\r\n  protected getScreenXY = (canvasXY: { x: number, y: number }) => {\r\n    const { x, y } = canvasXY;\r\n\r\n    const canvasFb = this.canvasFb;\r\n    const vpt = canvasFb.viewportTransform;\r\n\r\n    const zoom = this.canvasFb.getZoom();\r\n    const offset_x = vpt[4];\r\n    const offset_y = vpt[5];\r\n\r\n\r\n    const sx = x * zoom + offset_x;\r\n    const sy = y * zoom + offset_y;\r\n\r\n    return { x: sx, y: sy };\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number}} screenXY\r\n   */\r\n  protected getNcodeXY = (screenXY: { x: number, y: number }) => {\r\n    const { x, y } = screenXY;\r\n\r\n    const scale_det = 1 / this.base_scale;\r\n\r\n    const nx = (x - this.offset.x) * scale_det;\r\n    const ny = (y - this.offset.y) * scale_det;\r\n\r\n    return { x: nx, y: ny };\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param mode \r\n   * @param szPaper \r\n   * @param currScale \r\n   */\r\n  protected calcScaleFactor(mode: ZoomFitEnum, szPaper: { width: number, height: number }, currScale: number): number {\r\n\r\n    const actual_width = szPaper.width * this.base_scale;\r\n    const actual_height = szPaper.height * this.base_scale;\r\n\r\n    const szCanvas = this.currSize;\r\n    let scale = 1;\r\n    switch (mode) {\r\n      case ZoomFitEnum.WIDTH:\r\n        scale = szCanvas.width / actual_width;\r\n\r\n        break;\r\n\r\n      case ZoomFitEnum.HEIGHT:\r\n        scale = szCanvas.height / actual_height;\r\n        break;\r\n\r\n      case ZoomFitEnum.FULL:\r\n        scale = Math.min(szCanvas.width / actual_width, szCanvas.height / actual_height);\r\n        break;\r\n\r\n      case ZoomFitEnum.ACTUAL:\r\n        scale = 1;\r\n        break;\r\n\r\n      default:\r\n        scale = currScale;\r\n\r\n        break;\r\n\r\n    }\r\n    return scale;\r\n  }\r\n\r\n\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number}} dot\r\n   */\r\n  protected focusToDot = (dot: { x: number, y: number }) => {\r\n    if (!this.autoFocus) return;\r\n    const margin_to_go_ratio = 0.25;\r\n    const canvas_xy = this.getCanvasXY(dot);\r\n    const screen_xy = this.getScreenXY(canvas_xy);\r\n\r\n    let dx = 0, dy = 0;\r\n    let shouldScroll = false;\r\n\r\n    const canvasFb = this.canvasFb;\r\n    const vpt = canvasFb.viewportTransform;\r\n    const offset_x = vpt[4];\r\n    const offset_y = vpt[5];\r\n\r\n    if (screen_xy.x < 0) {\r\n      // scroll to left\r\n      const target = this.currSize.width * margin_to_go_ratio;\r\n      dx = target - screen_xy.x;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.y < 0) {\r\n      // scroll to top\r\n      const target = this.currSize.height * margin_to_go_ratio;\r\n      dy = target - screen_xy.y;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.x > this.currSize.width) {\r\n      // scroll to right\r\n      const target = this.currSize.width * (1 - margin_to_go_ratio);\r\n      dx = target - screen_xy.x;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.y > this.currSize.height) {\r\n      // scroll to bottom\r\n      const target = this.currSize.height * (1 - margin_to_go_ratio);\r\n      dy = target - screen_xy.y;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (shouldScroll) {\r\n\r\n      const new_offset_x = offset_x + dx;\r\n      const new_offset_y = offset_y + dy;\r\n\r\n      this.scrollCanvasToPoint({ x: new_offset_x, y: new_offset_y }, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {{x:number, y:number}} point\r\n   * @param {boolean} animate\r\n   */\r\n  protected scrollCanvasToPoint = (point: { x: number, y: number }, animate: boolean) => {\r\n    const canvasFb = this.canvasFb;\r\n    const vpt = canvasFb.viewportTransform;\r\n\r\n    if (animate) {\r\n      if (this.scrollAnimateTimer) {\r\n        window.clearInterval(this.scrollAnimateTimer);\r\n        this.scrollAnimateTimer = null;\r\n      }\r\n      let x0 = vpt[4];\r\n      let y0 = vpt[5];\r\n      const x1 = point.x;\r\n      const y1 = point.y;\r\n\r\n      const div = 10;\r\n      const step_x = (x1 - x0) / div;\r\n      const step_y = (y1 - y0) / div;\r\n      let count = 0;\r\n\r\n      this.scrollAnimateTimer = window.setInterval(() => {\r\n        x0 += step_x;\r\n        y0 += step_y;\r\n        vpt[4] = x0;\r\n        vpt[5] = y0;\r\n        canvasFb.requestRenderAll();\r\n\r\n        count++;\r\n        if (count === div) {\r\n          window.clearInterval(this.scrollAnimateTimer);\r\n          this.scrollAnimateTimer = null;\r\n          canvasFb.setViewportTransform(canvasFb.viewportTransform);\r\n        }\r\n      }, 20);\r\n    }\r\n    else {\r\n      vpt[4] = point.x;\r\n      vpt[5] = point.y;\r\n      this.scrollBoundaryCheck();\r\n      canvasFb.requestRenderAll();\r\n      canvasFb.setViewportTransform(canvasFb.viewportTransform);\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * @public\r\n   * @param {{width:number, height:number}} size\r\n   */\r\n  resize = (size: { width: number, height: number }) => {\r\n    console.log(`RenderWorkerBase: resized window ${size.width}, ${size.height}`);\r\n\r\n    const zoom = size.width / this.initialSize.width;\r\n    this.currSize = { ...size };\r\n\r\n    this.canvasFb.setHeight(size.height);\r\n    this.canvasFb.setWidth(size.width);\r\n\r\n    this.canvasFb.setZoom(zoom);\r\n  };\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Save\\SavePdf.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowserButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PdfPrintButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationButton.tsx",["491"],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\Enums.ts",["492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519"],"/** @enum {string} */\r\nexport enum DeviceTypeEnum {\r\n  PEN = \"pen\",\r\n  ERASER = \"eraser\",\r\n  PLAYER = \"player\",\r\n  STYLUS = \"stylus\",\r\n  FSIR = \"fsir\",\r\n  NONE = \"none\",\r\n}\r\n\r\n\r\n\r\n/** @enum {number} */\r\nexport enum PEN_STATE {\r\n  NONE = 0,\r\n  PEN_DOWN = 1,\r\n  PEN_MOVE = 2,\r\n  PEN_UP = 9,\r\n\r\n  HOVER_MOVE = 101,\r\n}\r\n\r\n\r\n\r\n/** @enum {string} */\r\nexport enum PenEventName {\r\n  ON_PEN_DOWN = \"pendown\",\r\n  ON_PEN_PAGEINFO = \"penpageinfo\",\r\n  ON_PEN_HOVER_PAGEINFO = \"hoverpageinfo\",\r\n  ON_PEN_MOVE = \"penmove\",\r\n  ON_PEN_UP = \"penup\",\r\n  ON_HOVER_MOVE = \"hovermove\",\r\n\r\n  ON_NCODE_ERROR = \"error\",\r\n  ON_PW_REQUIRED = \"pw_req\",\r\n  ON_CONNECTED = \"connected\",\r\n  ON_DISCONNECTED = \"disconnected\",\r\n\r\n  ON_UPGRADE_NEEDED = \"fw_up\",\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport enum IBrushType {\r\n  PEN = 0,\r\n  MARKER = 1,\r\n  PENCIL = 2,\r\n  ERASER = 3,\r\n  BRUSH = 4,\r\n  FOUNTAINPEN = 5,\r\n}\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\JsUtils.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\Modal\\PrintOptionDialog.tsx",["520","521","522","523","524","525"],"import React, {useState} from \"react\";\r\n// import { Container, Modal, Row, Col, Button } from \"react-bootstrap\";\r\n\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\n\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport DialogActions from '@material-ui/core/DialogActions';\r\nimport DialogContent from '@material-ui/core/DialogContent';\r\nimport DialogContentText from '@material-ui/core/DialogContentText';\r\nimport DialogTitle from '@material-ui/core/DialogTitle';\r\n\r\nimport TextField from '@material-ui/core/TextField';\r\n\r\nimport { Button, Box, Input } from \"@material-ui/core\";\r\n\r\nimport { IPrintingProgress, IPrintOption, MediaSize, PageInfo } from '../PrintDataTypes';\r\n\r\nimport FormControl from '@material-ui/core/FormControl';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport InputLabel from '@material-ui/core/InputLabel';\r\nimport MenuItem from '@material-ui/core/MenuItem';\r\nimport Select from '@material-ui/core/Select';\r\nimport Switch from '@material-ui/core/Switch';\r\nimport $ from 'jquery';\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  form: {\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n    margin: 'auto',\r\n    width: 'fit-content',\r\n  },\r\n  formControl: {\r\n    marginTop: theme.spacing(2),\r\n    minWidth: 120,\r\n  },\r\n  formControlLabel: {\r\n    marginTop: theme.spacing(1),\r\n  },\r\n}));\r\nexport default function PrintOptionDialog () {\r\n  const classes = useStyles();\r\n  const [open, setOpen] = useState(false);\r\n  const [IPrintOption, setIPrintOption] = useState({\r\n    codeDensity: 2,\r\n    printDpi: 600,\r\n    pdfRenderingDpi: 300,\r\n    putCalibrationMark: true,\r\n    printNcode: true,\r\n    dotsInACell: 7,\r\n    mediaSize: MediaSize.A4,\r\n    direction: \"auto\",\r\n    colorMode: 1,\r\n    scaleUpToMedia: true,\r\n    scaleDownToMedia: true,\r\n    targetPages: \"\",\r\n    pagesPerSheet: 1,\r\n    pageInfo: PageInfo.first_page,\r\n    debugMode: 0,\r\n    hasToPutNcode: true\r\n  })\r\n\r\n  const handleClickOpen = () => {\r\n    setOpen(true);\r\n  }\r\n\r\n  const handleClose = (e) => {\r\n    setIPrintOption({\r\n      ...IPrintOption,\r\n      codeDensity: 2,\r\n      printDpi: 600,\r\n      pdfRenderingDpi: 300,\r\n      putCalibrationMark: true,\r\n      printNcode: true,\r\n      dotsInACell: 7,\r\n      mediaSize: MediaSize.A4,\r\n      direction: \"auto\",\r\n      colorMode: 1,\r\n      scaleUpToMedia: true,\r\n      scaleDownToMedia: true,\r\n      targetPages: \"\",\r\n      pagesPerSheet: 1,\r\n      pageInfo: PageInfo.first_page,\r\n      debugMode: 0,\r\n      hasToPutNcode: true\r\n    })\r\n    setOpen(false);\r\n  }\r\n\r\n  const handleSave = (e) => {\r\n    //저장 로직 추가\r\n    setIPrintOption({\r\n      ...IPrintOption,\r\n      targetPages : $('#targetPages').val(),\r\n      [e.target.name] : e.target.value\r\n    });\r\n\r\n    setOpen(false);\r\n  }\r\n\r\n  const onChange = (e) => {\r\n    setIPrintOption({\r\n      ...IPrintOption,\r\n      [e.target.name] : e.target.value\r\n    });\r\n\r\n    console.log(e.target.value);\r\n    // console.log(MediaSize);\r\n    // console.log(MediaSize.A4);\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <Button variant=\"outlined\" color=\"primary\" onClick={handleClickOpen}>\r\n        <Box fontSize={16} fontWeight=\"fontWeightBold\" >\r\n          인쇄 옵션 설정\r\n        </Box>\r\n      </Button>\r\n      <Dialog open={open} onClose={handleClose} aria-labelledby=\"form-dialog-title\">\r\n        <DialogTitle id=\"form-dialog-title\">인쇄 설정</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            Dialog의 Body\r\n          </DialogContentText>\r\n\r\n          {/* 코드의 농도 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"codeDensity\">코드 농도</InputLabel>\r\n              <Select\r\n                autoFocus\r\n                value={IPrintOption.codeDensity}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'codeDensity',\r\n                  id: 'codeDensity',\r\n                }}\r\n              >\r\n                <MenuItem value=\"1\">연하게</MenuItem>\r\n                <MenuItem value=\"2\">보통</MenuItem>\r\n                <MenuItem value=\"3\">진하게</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* 인쇄의 품질 Dialog */}\r\n          <form className={classes.form} noValidate style={{float:\"left\"}}>\r\n            <FormControl className={classes.formControl}>\r\n                <InputLabel htmlFor=\"printDpi\">인쇄 품질</InputLabel>\r\n                <Select\r\n                  value={IPrintOption.printDpi}\r\n                  onChange={onChange}\r\n                  inputProps={{\r\n                    name: 'printDpi',\r\n                    id: 'printDpi',\r\n                  }}\r\n                >\r\n                  <MenuItem value=\"600\">품질 우선</MenuItem>\r\n                  <MenuItem value=\"300\">보통 품질</MenuItem>\r\n                </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* PDF의 Rendering DPI Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"pdfRenderingDpi\">PDFRendering</InputLabel>\r\n              <Select\r\n                value={IPrintOption.pdfRenderingDpi}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'pdfRenderingDpi',\r\n                  id: 'pdfRenderingDpi'\r\n                }}\r\n              >\r\n                <MenuItem value=\"150\">150DPI</MenuItem>\r\n                <MenuItem value=\"200\">200DPI</MenuItem>\r\n                <MenuItem value=\"300\">300DPI</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* Calibration 유무 체크 Dialog */}\r\n          <form className={classes.form} noValidate style={{clear:\"both\", float:\"left\"}}>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"putCalibrationMark\">CalibrationMark</InputLabel>\r\n              <Select\r\n                value={IPrintOption.putCalibrationMark}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'putCalibrationMark',\r\n                  if: 'putCalibrationMark',\r\n                }}\r\n              >\r\n                <MenuItem value=\"true\">true</MenuItem>\r\n                <MenuItem value=\"false\">false</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* Print시 Ncode 유무 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"printNcode\">PrintNcode</InputLabel>\r\n              <Select\r\n                value={IPrintOption.printNcode}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'printNcode',\r\n                  id: 'printNcode'\r\n                }}\r\n              >\r\n                <MenuItem value=\"true\">true</MenuItem>\r\n                <MenuItem value=\"false\">false</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* DotsInACell의 Dialog - 보이지는 않는다 */}\r\n          <form className={classes.form} noValidate style={{display:\"none\"}}>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"dotsInACell\" disabled>DotsInACell</InputLabel>\r\n                <Input value=\"7\" id=\"dotsInACell\" name=\"dotsInACell\" />\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* MediaSize의 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"mediaSize\">MediaSize</InputLabel>\r\n              <Select\r\n                value={IPrintOption.mediaSize}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'mediaSize',\r\n                  id: 'mediaSize'\r\n                }}\r\n              >\r\n                <MenuItem value={\"A4\"}>A4</MenuItem>\r\n                <MenuItem value={\"A3\"}>A3</MenuItem>\r\n                <MenuItem value={\"B4\"}>B4</MenuItem>\r\n                <MenuItem value={\"B5\"}>B5</MenuItem>\r\n                <MenuItem value={\"Letter\"}>Letter</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* ColorMode에 대한 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"colorMode\">ColorMode</InputLabel>\r\n              <Select\r\n                value={IPrintOption.colorMode}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'colorMode',\r\n                  id: 'colorMode'\r\n                }}\r\n              >\r\n                <MenuItem value=\"0\">BLUEPRINT</MenuItem>\r\n                <MenuItem value=\"1\">ANDROID_STYLE</MenuItem>\r\n                <MenuItem value=\"2\">IPHONE_STYLE</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* Direction에 대한 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"direction\">Direction</InputLabel>\r\n              <Select\r\n                value={IPrintOption.direction}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'direction',\r\n                  id: 'direction'\r\n                }}\r\n              >\r\n                <MenuItem value=\"auto\">auto</MenuItem>\r\n                <MenuItem value=\"protrait\">protrait</MenuItem>\r\n                <MenuItem value=\"landscape\">landscape</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* ScaleUp에 대한 Dialog */}\r\n          <form className={classes.form} noValidate style={{clear:\"both\", float:\"left\"}}>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"scaleUpToMedia\">ScaleUpToMedia</InputLabel>\r\n              <Select\r\n                value={IPrintOption.scaleUpToMedia}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'scaleUpToMedia',\r\n                  id: 'scaleUpToMedia'\r\n                }}\r\n              >\r\n                <MenuItem value=\"true\">true</MenuItem>\r\n                <MenuItem value=\"false\">false</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* ScaleDown에 대한 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"scaleDownToMedia\">ScaleDownToMedia</InputLabel>\r\n              <Select\r\n                value={IPrintOption.scaleDownToMedia}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'scaleDownToMedia',\r\n                  id: 'scaleDownToMedia'\r\n                }}\r\n              >\r\n                <MenuItem value=\"true\">true</MenuItem>\r\n                <MenuItem value=\"false\">false</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* TargetPage에 대한 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              {/* <TextField id=\"targetPages\" margin=\"dense\" label=\"TargetPages\" type=\"text\" /> */}\r\n              {/* <InputLabel htmlFor=\"targetPages\">TargetPages</InputLabel> */}\r\n              <TextField id=\"targetPages\" name=\"targetPages\" margin=\"dense\" label=\"TargetPages\"\r\n                     type=\"text\" onSubmit={(e) => handleSave}/>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* PagePerSheet에 대한 Dialog */}\r\n          <form className={classes.form} noValidate style={{float:\"left\"}}>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"pagesPerSheet\">PagesPerSheet</InputLabel>\r\n              <Select\r\n                value={IPrintOption.pagesPerSheet}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'pagesPerSheet',\r\n                  id: 'pagesPerSheet'\r\n                }}\r\n              >\r\n                <MenuItem value=\"1\">1</MenuItem>\r\n                <MenuItem value=\"2\">2</MenuItem>\r\n                <MenuItem value=\"4\">4</MenuItem>\r\n                <MenuItem value=\"8\">8</MenuItem>\r\n                <MenuItem value=\"9\">9</MenuItem>\r\n                <MenuItem value=\"16\">16</MenuItem>\r\n                <MenuItem value=\"18\">18</MenuItem>\r\n                <MenuItem value=\"25\">25</MenuItem>\r\n                <MenuItem value=\"32\">32</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* PageInfo에 대한 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"pageInfo\">PageInfo</InputLabel>\r\n              <Select\r\n                value={IPrintOption.pageInfo}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'pageInfo',\r\n                  id: 'pageInfo'\r\n                }}\r\n              >\r\n                <MenuItem value={1}>3, 27, 1068, 1</MenuItem>\r\n                <MenuItem value={2}>3, 27, 1069, 1</MenuItem>\r\n                <MenuItem value={3}>3, 27, 1070, 1</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* DebugMode에 대한 Dialog */}\r\n          <form className={classes.form} noValidate style={{float:\"left\"}}>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"debugMode\">DebugMode</InputLabel>\r\n              <Select\r\n                value={IPrintOption.debugMode}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'debugMode',\r\n                  id: 'debugMode'\r\n                }}\r\n              >\r\n                <MenuItem value=\"0\">0</MenuItem>\r\n                <MenuItem value=\"1\">1</MenuItem>\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n          {/* HasToPutNcode에 대한 Dialog */}\r\n          <form className={classes.form} noValidate>\r\n            <FormControl className={classes.formControl}>\r\n              <InputLabel htmlFor=\"debugMode\">HasToPutNcode</InputLabel>\r\n              <Select\r\n                value={IPrintOption.hasToPutNcode}\r\n                onChange={onChange}\r\n                inputProps={{\r\n                  name: 'hasToPutNcode',\r\n                  id: 'hasToPutNcode'\r\n                }}\r\n              >\r\n                <MenuItem value=\"true\">true</MenuItem>\r\n                <MenuItem value=\"false\">false</MenuItem>\r\n\r\n              </Select>\r\n            </FormControl>\r\n          </form>\r\n\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={handleSave} color=\"primary\">\r\n            Save\r\n          </Button>\r\n          <Button onClick={handleClose} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n        </DialogActions>\r\n      </Dialog>\r\n    </div>\r\n  );\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoDot.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\NeoPdfViewer.tsx",["526"],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfManager.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoStroke.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\DrawCurves.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowser.tsx",["527","528","529"],"import { uuidv4 } from \"../NcodePrint\";\r\n\r\nexport const _uuid: string = uuidv4();\r\nconst _fileInputId = _uuid;\r\n\r\nlet _fileOpenPromise: Promise<IFileBrowserResult> = null;\r\nlet _resolveFunc = null;\r\nlet _filename = \"\";\r\n\r\n\r\nexport type IFileBrowserResult = {\r\n  result: \"success\" | \"canceled\" | \"failed\",\r\n  file: any,\r\n  url?: any\r\n}\r\n\r\n\r\nexport async function openFileBrowser(): Promise<IFileBrowserResult> {\r\n  let result = await performClick(_fileInputId);\r\n  const file = result.file;\r\n  if (file) {\r\n    const url = URL.createObjectURL(file);\r\n    result = {\r\n      ...result,\r\n      url,\r\n    }\r\n    console.log(file.name);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n\r\nasync function performClick(elemId): Promise<IFileBrowserResult> {\r\n  _filename = \"\";\r\n\r\n\r\n  _fileOpenPromise = new Promise(resolve => {\r\n    const elem = document.getElementById(elemId);\r\n    if (elem && document.createEvent) {\r\n      const evt = document.createEvent(\"MouseEvents\");\r\n      evt.initEvent(\"click\", true, false);\r\n      elem.dispatchEvent(evt);\r\n      _resolveFunc = resolve;\r\n\r\n      return _fileOpenPromise;\r\n    }\r\n    else {\r\n      resolve({ result: \"failed\", file: null });\r\n    }\r\n  });\r\n\r\n  return _fileOpenPromise;\r\n}\r\n\r\n\r\nasync function performClick_old(elemId): Promise<IFileBrowserResult> {\r\n  _filename = \"\";\r\n  const elem = document.getElementById(elemId);\r\n  if (elem && document.createEvent) {\r\n    _fileOpenPromise = new Promise(resolve => {\r\n      const evt = document.createEvent(\"MouseEvents\");\r\n      evt.initEvent(\"click\", true, false);\r\n      elem.dispatchEvent(evt);\r\n      _resolveFunc = resolve;\r\n    });\r\n\r\n    return _fileOpenPromise;\r\n  }\r\n\r\n  return Promise.resolve({ result: \"failed\", file: null });\r\n}\r\n\r\nexport function onSuccess(e) {\r\n  window.removeEventListener('focus', handleFocusBack);\r\n\r\n  const file = e.target.files[0];\r\n  console.log(\"OK : \" + file.name);\r\n\r\n  _filename = file.name;\r\n  e.target.value = null;\r\n\r\n  _resolveFunc({ result: \"success\", file });\r\n}\r\n\r\nfunction handleFocusBack(e) {\r\n  // console.log('focus-back');\r\n  setTimeout(() => {\r\n    if (_filename.length) {\r\n      // 이것은 time delay를 주어야 동작한다.\r\n      console.log('Files Loaded');\r\n    }\r\n    // Alert the user if the number\r\n    // of file is zero\r\n    else {\r\n      console.log('Cancel clicked');\r\n      _resolveFunc(\"\");\r\n    }\r\n  }, 300);\r\n\r\n  document.body.onfocus = null;\r\n  // window.removeEventListener('focus', handleFocusBack);\r\n}\r\n\r\nexport function onOpenClicked(e) {\r\n  document.body.onfocus = handleFocusBack;\r\n  // window.addEventListener('focus', handleFocusBack);\r\n}\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderWorker.tsx",["530"],"import \"../../types\";\r\nimport RenderWorkerBase, { IRenderWorkerOption } from \"./RenderWorkerBase\";\r\n\r\nimport { fabric } from \"fabric\";\r\n\r\n// import { PLAYSTATE } from \"./StorageRenderer\";\r\nimport { InkStorage } from \"../..\";\r\nimport { drawPath } from \"./DrawCurves\";\r\n// import { NCODE_TO_SCREEN_SCALE } from \"../../constants\";\r\nimport { paperInfo } from \"../../noteserver/PaperInfo\";\r\nimport { NeoDot, NeoStroke } from \"../../DataStructure\";\r\nimport { IBrushType } from \"../../DataStructure/Enums\";\r\nimport { INeoStrokeProps } from \"../../DataStructure/NeoStroke\";\r\nimport { IPageSOBP } from \"../../DataStructure/Structures\";\r\n\r\nimport $ from \"jquery\";\r\n\r\n\r\n// const timeTickDuration = 20; // ms\r\n// const DISABLED_STROKE_COLOR = \"rgba(0, 0, 0, 0.1)\";\r\n// const INVISIBLE_STROKE_COLOR = \"rgba(255, 255, 255, 0)\";\r\n// const INCOMPLETE_STROKE_COLOR = \"rgba(255, 0, 255, 0.4)\";\r\n// const CURRENT_POINT_STROKE_COLOR = \"rgba(255, 255, 255, 1)\";\r\n\r\nconst NUM_HOVER_POINTERS = 6;\r\nconst REMOVE_HOVER_POINTS_INTERVAL = 50; // 50ms\r\nconst REMOVE_HOVER_POINTS_WAIT = 20; // 20 * 50ms = 1sec\r\n\r\n/** @enum {string}  */\r\nexport const ZoomFitEnum = {\r\n  WIDTH: \"width\",\r\n  HEIGHT: \"height\",\r\n  FULL: \"full\",\r\n  ACTUAL: \"100%\",\r\n}\r\n\r\nconst STROKE_OBJECT_ID = \"ns\";\r\n// const GRID_OBJECT_ID = \"g\";\r\n\r\nexport default class PenBasedRenderWorker extends RenderWorkerBase {\r\n\r\n  /** @type {Array<fabric.Path>} */\r\n  localPathArray = new Array(0);\r\n\r\n\r\n  /** @type {Object.<string, {stroke:NeoStroke, path:fabric.Path}>} */\r\n  livePaths = {};\r\n\r\n\r\n  storage = InkStorage.getInstance();\r\n\r\n  visibleHoverPoints: number = NUM_HOVER_POINTERS;\r\n  pathHoverPoints: Array<fabric.Circle> = new Array(0);\r\n\r\n\r\n  /**\r\n   * \r\n   * @param options \r\n   */\r\n  constructor(options: IRenderWorkerOption) {\r\n    super(options);\r\n\r\n    this.name = \"PenBasedRenderWorker\";\r\n\r\n    const { storage } = options;\r\n    if (storage !== undefined) {\r\n      if (!(storage instanceof InkStorage)) {\r\n        throw new Error(\"storage is not an instance of InkStorage\");\r\n      }\r\n      this.storage = storage;\r\n    }\r\n\r\n\r\n    const { section, owner, book, page } = this.surfaceInfo;\r\n    this.changePage(section, owner, book, page, true);\r\n\r\n    console.log(`constructor size ${options.width}, ${options.height}`)\r\n    this.resize({ width: options.width, height: options.height });\r\n  }\r\n\r\n  // /**\r\n  //  * @override\r\n  //  */\r\n  // init = () => {\r\n  //   super.init();\r\n  // }\r\n\r\n\r\n  /**\r\n   * Pen Down이 들어왔다. 그러나 아직 page 정보가 들어오지 않아서,\r\n   * 이 페이지에 붙여야 할 것인가 아니면, 새로운 페이지에 붙여야 할 것인가를 모른다.\r\n   *\r\n   * 렌더러 처리 순서\r\n   * 1) Pen Down: live stroke의 path를 생성\r\n   * 2) Page Info: 페이지를 전환하고, 잉크 스토리지에 있는 이전의 스트로크를 path로 등록한다.\r\n   *      2-1) 이 클래스를 new 하는 container에서 setPageStrokePath(strokes)를 불러줘야 한다.\r\n   * 3) Pen Move:\r\n   *      3-1) live stroke path의 처음 나오는 점이면, path를 canvas에 등록한다.\r\n   *      3-2) 두번째 점부터는 path에 append 한다.\r\n   * 4) Pen Up: Live stroke path는 없애고, 잉크스토리지에 2) 이후의 stroke를 받아 path에 추가 등록한다.\r\n   *\r\n   *\r\n   * 조심해야 할 것은, 위의 2의 처리를 container가 담당하고 있는데, 2에 앞서서 3이 처리되면\r\n   * 이전의 페이지에 획이 추가되고, 2-1에 의해 clear되어 버린다. 순서에 유의할 것\r\n   *\r\n   * @public\r\n   * @param {{strokeKey:string, mac:string, time:number, stroke:NeoStroke}} event\r\n   */\r\n  createLiveStroke = (event: any) => {\r\n    console.log(`Stroke created = ${event.strokeKey}`);\r\n    this.livePaths[event.strokeKey] = {\r\n      stroke: event.stroke,\r\n      path: null\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, dot:NeoDot}} event\r\n   */\r\n  pushLiveDot = (event: any) => {\r\n    //pen tracker rendering\r\n    this.movePenTracker(event);\r\n\r\n    const pathData = this.livePaths[event.strokeKey];\r\n    const { path, stroke } = pathData;\r\n    const dot = event.dot;\r\n\r\n    if (path) {\r\n      this.canvasFb.remove(path);\r\n    }\r\n\r\n\r\n\r\n    //지우개 구현\r\n    const canvas_xy = this.getCanvasXY(dot);\r\n    const screen_xy = this.getScreenXY(canvas_xy);\r\n    const pen = event.pen;\r\n    if (pen.penRendererType === IBrushType.ERASER) {\r\n      console.log('ERASE');\r\n      if (Object.keys(pen.eraserLastPoint).length) {\r\n        this.eraseOnLine(pen.eraserLastPoint.x, pen.eraserLastPoint.y, screen_xy.x, screen_xy.y, stroke);\r\n      }\r\n\r\n      pen.eraserLastPoint = { x: screen_xy.x, y: screen_xy.y };\r\n    }\r\n    else {\r\n      const new_path = this.createPenPathFromStroke(stroke);\r\n\r\n      if (this.canvasFb) {\r\n        this.canvasFb.add(new_path);\r\n        pathData.path = new_path;\r\n      }\r\n\r\n\r\n      this.focusToDot(dot);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {{strokeKey:string, mac:string, stroke, section:number, owner:number, book:number, page:number}} event\r\n   */\r\n  closeLiveStroke = (event) => {\r\n    const pathData = this.livePaths[event.strokeKey];\r\n\r\n    if (!pathData || pathData.path === undefined) {\r\n      console.log(`undefined path`);\r\n    }\r\n\r\n    const path = pathData.path;\r\n\r\n    if (path) {\r\n      this.localPathArray.push(path);\r\n      path.fill = path.color;\r\n      path.stroke = path.color;\r\n      // this.canvas.renderAll();\r\n    }\r\n\r\n    delete this.livePaths[event.strokeKey];\r\n  }\r\n\r\n  movePenTracker = (event: any) => {\r\n    const dot = event.dot;\r\n    const canvas_xy = this.getCanvasXY(dot);\r\n    const screen_xy = this.getScreenXY(canvas_xy);\r\n    const penTracker = event.pen.pathPenTracker;\r\n\r\n    const objects = this.canvasFb.getObjects();\r\n    const penTrackerObj = objects.filter(obj => obj.data === 'pt');\r\n\r\n    if (penTrackerObj.length === 0) {\r\n      this.canvasFb.add(event.pen.pathPenTracker);\r\n    }\r\n\r\n    const radius = penTracker.radius;\r\n    penTracker.visible = true;\r\n    penTracker.set({ left: screen_xy.x - radius, top: screen_xy.y - radius });\r\n    penTracker.setCoords();\r\n    this.canvasFb.renderAll();\r\n\r\n    const pen = event.pen;\r\n\r\n    pen.waitCount = REMOVE_HOVER_POINTS_WAIT;\r\n    pen.visibleHoverPoints--;\r\n    if (pen.visibleHoverPoints >= 0) {\r\n      pen.pathHoverPoints[pen.visibleHoverPoints].visible = false;\r\n    }\r\n\r\n    if (pen.timeOut) {\r\n      clearInterval(pen.timeOut);\r\n      pen.timeOut = null;\r\n    }\r\n\r\n\r\n  }\r\n\r\n  eraseOnLine(ink_x0, ink_y0, ink_x1, ink_y1, stroke) {\r\n    const pathData = 'M ' + ink_x0 + ' ' + ink_y0 + ' L ' + ink_x1 + ' ' + ink_y1;\r\n    const eraserPath = new fabric.Path(pathData);\r\n    eraserPath.set({ left: ink_x0, top: ink_y0, opacity: 0 });\r\n\r\n    const paths = this.canvasFb.getObjects().filter(obj => obj.data === 'ns');\r\n\r\n    for (let i = 0; i < this.localPathArray.length; i++) {\r\n      const path = this.localPathArray[i];\r\n\r\n      if (path.intersectsWithObject(eraserPath)) {\r\n        this.canvasFb.remove(path);\r\n\r\n        const { section, book, owner, page } = stroke;\r\n        const pageId = InkStorage.getPageId({ section, book, owner, page });\r\n\r\n        this.storage.completed = this.storage.completedOnPage.get(pageId)\r\n        const idx = this.storage.completed.findIndex(ns => ns.key === path.key);\r\n        this.storage.completed.splice(idx, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  addHoverPoints = (e) => {\r\n    for (let i = 0; i < e.pen.pathHoverPoints.length; i++) {\r\n      this.canvasFb.add(e.pen.pathHoverPoints[i]);\r\n    }\r\n\r\n    this.canvasFb.add(e.pen.pathPenTracker);\r\n    console.log('hover points & pen tracker added')\r\n  }\r\n\r\n  moveHoverPoint = (e) => {\r\n\r\n    const objects = this.canvasFb.getObjects();\r\n    const hoverPoints = objects.filter(obj => obj.data === 'hp');\r\n\r\n    if (hoverPoints.length === 0) {\r\n      for (let i = 0; i < e.pen.pathHoverPoints.length; i++) {\r\n        this.canvasFb.add(e.pen.pathHoverPoints[i]);\r\n      }\r\n    }\r\n\r\n    const dot = { x: e.event.x, y: e.event.y }\r\n    const canvas_xy = this.getCanvasXY(dot);\r\n\r\n    for (let i = NUM_HOVER_POINTERS - 1; i > 0; i--) {\r\n      e.pen.pathHoverPoints[i].left = e.pen.pathHoverPoints[i - 1].left;\r\n      e.pen.pathHoverPoints[i].top = e.pen.pathHoverPoints[i - 1].top;\r\n      e.pen.pathHoverPoints[i].setCoords();\r\n      this.canvasFb.renderAll();\r\n    }\r\n\r\n    e.pen.pathHoverPoints[0].left = canvas_xy.x;\r\n    e.pen.pathHoverPoints[0].top = canvas_xy.y;\r\n    e.pen.pathHoverPoints[0].setCoords();\r\n    this.canvasFb.renderAll();\r\n\r\n    const isPointerVisible = $(\"#btn_tracepoint\").find(\".c2\").hasClass(\"checked\");\r\n\r\n    e.pen.visibleHoverPoints = NUM_HOVER_POINTERS;\r\n\r\n    for (let i = 0; i < e.pen.visibleHoverPoints; i++) {\r\n      e.pen.pathHoverPoints[i].visible = isPointerVisible;\r\n      this.canvasFb.renderAll();\r\n    }\r\n\r\n    if (e.pen.timeOut) {\r\n      clearInterval(e.pen.timeOut);\r\n      e.pen.timeOut = null;\r\n    }\r\n    e.pen.waitCount = 0;\r\n\r\n    const pen = e.pen;\r\n    const self = this;\r\n\r\n    e.pen.timeOut = setInterval(() => {\r\n      pen.waitCount++;\r\n      // 1초 뒤\r\n      if (pen.waitCount > 20) {\r\n        for (let i = NUM_HOVER_POINTERS - 1; i > 0; i--) {\r\n          pen.pathHoverPoints[i].left = pen.pathHoverPoints[i - 1].left;\r\n          pen.pathHoverPoints[i].top = pen.pathHoverPoints[i - 1].top;\r\n        }\r\n        pen.pathHoverPoints[0].left = -30;\r\n        pen.pathHoverPoints[0].top = -30;\r\n\r\n        pen.visibleHoverPoints--;\r\n        if (pen.visibleHoverPoints >= 0) {\r\n          pen.pathHoverPoints[pen.visibleHoverPoints].visible = false;\r\n          self.canvasFb.renderAll();\r\n        } else {\r\n          clearInterval(pen.timeOut);\r\n        }\r\n      }\r\n    }, REMOVE_HOVER_POINTS_INTERVAL);\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {number} section\r\n   * @param {number} owner\r\n   * @param {number} book\r\n   * @param {number} page\r\n   * @param {boolean} forceToRefresh\r\n   */\r\n  changePage = (section: number, owner: number, book: number, page: number, forceToRefresh: boolean) => {\r\n    console.log(\"changePage\");\r\n    const currPage = this.surfaceInfo;\r\n\r\n    if ((!forceToRefresh)\r\n      && (section === currPage.section\r\n        && owner === currPage.owner\r\n        && book === currPage.book\r\n        && page === currPage.page)) return;\r\n\r\n\r\n    // 페이지 정보와 scale을 조정한다.\r\n    const info = paperInfo.getPaperInfo({ section, owner, book, page });\r\n    if (info) {\r\n      this.surfaceInfo = {\r\n        section, owner, book, page,\r\n        Xmin: info.Xmin, Ymin: info.Ymin, Xmax: info.Xmax, Ymax: info.Ymax,\r\n        Mag: info.Mag\r\n      };\r\n\r\n    }\r\n    const szPaper = paperInfo.getPaperSize({ section, owner, book, page });\r\n    this.scale = this.calcScaleFactor(this.viewFit, szPaper, this.base_scale);\r\n\r\n    // 현재 모든 stroke를 지운다.\r\n    this.removeAllCanvasObject();\r\n    this.resetLocalPathArray();\r\n\r\n    // grid를 그려준다\r\n    this.drawPageLayout();\r\n\r\n    // page에 있는 stroke를 가져온다\r\n    const pageInfo = { section, owner, book, page };\r\n    const strokes = this.storage.getPageStrokes(pageInfo);\r\n\r\n    //test\r\n    const testStroke = this.generateA4CornerStrokeForTest(pageInfo);\r\n    strokes.push(testStroke);\r\n\r\n    // 페이지의 stroke를 fabric.Path로 바꾼다.\r\n    this.addStrokePaths(strokes);\r\n\r\n    // page refresh\r\n    this.canvasFb.requestRenderAll();\r\n  }\r\n\r\n  private generateDotForTest(x: number, y: number): NeoDot {\r\n    const dot = new NeoDot({\r\n      dotType: 2,   // moving\r\n      deltaTime: 2,\r\n      time: 0,\r\n      f: 255,\r\n      x, y,\r\n    });\r\n\r\n    return dot;\r\n  }\r\n\r\n  private generateA4CornerStrokeForTest(pageInfo: IPageSOBP): NeoStroke {\r\n    // for debug\r\n    const { section, owner, book, page } = pageInfo;\r\n    const strokeArg: INeoStrokeProps = {\r\n      section, owner, book, page,\r\n      startTime: 0,\r\n      mac: \"00:00:00:00:00:00\",\r\n      color: \"rgba(0,0,255,255)\",\r\n      brushType: IBrushType.PEN,\r\n      thickness: 1,\r\n    }\r\n    const defaultStroke = new NeoStroke(strokeArg);\r\n\r\n    let dot: NeoDot;\r\n\r\n    const dot0 = this.generateDotForTest(0, 0);\r\n    defaultStroke.addDot(dot0);\r\n\r\n    dot = this.generateDotForTest(88.56, 0);\r\n    defaultStroke.addDot(dot);\r\n    defaultStroke.addDot(dot);\r\n\r\n    dot = this.generateDotForTest(88.56, 125.24);\r\n    defaultStroke.addDot(dot);\r\n    defaultStroke.addDot(dot);\r\n\r\n    dot = this.generateDotForTest(0, 125.24);\r\n    defaultStroke.addDot(dot);\r\n    defaultStroke.addDot(dot);\r\n\r\n    dot = this.generateDotForTest(0, 0);\r\n    defaultStroke.addDot(dot);\r\n\r\n    return defaultStroke;\r\n  }\r\n\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  resetLocalPathArray = () => {\r\n    this.localPathArray = new Array(0);\r\n\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  removeAllPaths = () => {\r\n    if (!this.canvasFb) return;\r\n    this.localPathArray.forEach(path => {\r\n      this.canvasFb.remove(path);\r\n    });\r\n\r\n    this.localPathArray = new Array(0);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  removeAllStrokeObject = () => {\r\n    if (this.canvasFb) {\r\n      const objects = this.canvasFb.getObjects();\r\n      const strokes = objects.filter(obj => obj.data === STROKE_OBJECT_ID);\r\n\r\n      strokes.forEach((path) => {\r\n        this.canvasFb.remove(path);\r\n      });\r\n    }\r\n  };\r\n\r\n  removeAllCanvasObject = () => {\r\n    if (this.canvasFb) {\r\n      this.canvasFb.clear();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @private\r\n   * @param {Array<NeoStroke>} strokes\r\n   */\r\n  addStrokePaths = (strokes) => {\r\n    if (!this.canvasFb) return;\r\n\r\n    strokes.forEach((stroke) => {\r\n      if (stroke.dotArray.length > 0) {\r\n        const path = this.createPenPathFromStroke(stroke);\r\n        this.canvasFb.add(path);\r\n        this.localPathArray.push(path);\r\n      }\r\n    });\r\n  }\r\n\r\n  createPenPathFromStroke = (stroke: NeoStroke) => {\r\n    const { dotArray, color, thickness, brushType, key } = stroke;\r\n\r\n    const pointArray = [];\r\n    dotArray.forEach((dot) => {\r\n      const pt = this.getCanvasXY_scaled(dot);\r\n      pointArray.push(pt);\r\n    });\r\n\r\n    let opacity = 0;\r\n    switch (brushType) {\r\n      case 0: opacity = 1; break;\r\n      case 1: opacity = 0.3; break;\r\n      default: opacity = 1; break;\r\n    }\r\n\r\n    const pathOption = {\r\n      objectCaching: false,\r\n      stroke: color, //\"rgba(0,0,0,255)\"\r\n      fill: color, //위에 두놈은 그려지는 순간의 color\r\n      color: color, //얘가 canvas에 저장되는 color\r\n      opacity: opacity,\r\n      // strokeWidth: 10,\r\n      originX: 'left',\r\n      originY: 'top',\r\n      selectable: false,\r\n\r\n      data: STROKE_OBJECT_ID,    // neostroke\r\n      evented: true,\r\n      key: key,\r\n    };\r\n\r\n    const strokeThickness = thickness / 64;\r\n    const pathData = drawPath(pointArray, strokeThickness);\r\n    const path = new fabric.Path(pathData, pathOption);\r\n\r\n    return path;\r\n  }\r\n\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintPdfMain.tsx",["531","532","533","534","535"],"import * as React from \"react\";\r\n\r\nimport { IPageOverview, PagesForPrint } from \"./PagesForPrint\";\r\nimport ReactToPrint from 'react-to-print';\r\nimport { IPrintingProgress, IPrintOption } from \"./PrintDataTypes\";\r\nimport { compareObject } from \"./UtilFunc\";\r\nimport { getCellMatrixShape } from \"../NcodeSurface/SurfaceSplitter\";\r\nimport { LandscapeOrientation, PortraitOrientation } from \"./PageOrientation\";\r\nimport NeoPdfDocument from \"../NeoPdf/NeoPdfDocument\";\r\n\r\n// let globalPagesCnt = 0;\r\ninterface Props {\r\n  pdf: NeoPdfDocument,\r\n  printOption: IPrintOption,\r\n  updatePrintProgress: Function,\r\n\r\n  /** 숫자가 바뀌면, 프린트한다 */\r\n  printTrigger: number,\r\n\r\n  pagesOverview: IPageOverview[],\r\n\r\n  /** 인쇄가 끝나고 나면 부를 콜백 */\r\n  onAfterPrint?: Function,\r\n}\r\n\r\ninterface State {\r\n  text: string,\r\n  isLoading: boolean,\r\n  shouldRenderPage: boolean,\r\n  renderingCompleted: boolean,\r\n  shouldPrint: boolean,\r\n  // renderPromise: Promise<any>,\r\n}\r\n\r\n/**\r\n * Class\r\n */\r\nexport class PrintPdfMain extends React.Component<Props, State> {\r\n  componentRef: PagesForPrint | null = null;\r\n  printRef: ReactToPrint;\r\n  onAfterPrint: Function;\r\n\r\n  title: string = \"\";\r\n\r\n\r\n  renderedSheets: number[];\r\n  renderedPages: number[];\r\n\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    this.onAfterPrint = props.onAfterPrint;\r\n\r\n    this.state = {\r\n      text: \"normal\",\r\n      isLoading: false,\r\n      shouldRenderPage: true,\r\n      renderingCompleted: false,\r\n      shouldPrint: false,\r\n      // renderPromise: pr,\r\n    };\r\n    this.clearRenderedPagesArray();\r\n  }\r\n\r\n  private clearRenderedPagesArray = () => {\r\n    this.renderedSheets = [];\r\n    this.renderedPages = [];\r\n  }\r\n\r\n  handleAfterPrint = () => {\r\n    console.log(\"[PrintPdfMain] onAfterPrint called\"); // tslint:disable-line no-console\r\n    this.onAfterPrint();\r\n\r\n  }\r\n\r\n  handleBeforePrint = () => {\r\n    console.log(\"[PrintPdfMain] onBeforePrint called\"); // tslint:disable-line no-console\r\n    return new Promise((resolve: any) => {\r\n      resolve();\r\n      /** 문서의 제목을 얻어오자 */\r\n      const pdf = this.props.pdf;\r\n      pdf.getMetadata().then(stuff => {\r\n        // console.log(stuff); // Metadata object here\r\n        this.title = stuff.info.title ? stuff.info.title : \"\";\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  handleOnBeforeGetContent = () => {\r\n    console.log(\"[PrintPdfMain] onBeforeGetContent called\"); // tslint:disable-line no-console\r\n    this.clearRenderedPagesArray();\r\n\r\n    this.setState({ text: \"Loading new text...\", isLoading: true, shouldRenderPage: true });\r\n    return new Promise((resolve: any) => { resolve(); });\r\n  };\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    if (this.props.printTrigger !== nextProps.printTrigger) {\r\n      this.clearRenderedPagesArray();\r\n      this.setState({ shouldPrint: true });\r\n\r\n      return true;\r\n    }\r\n\r\n    if (nextState.shouldPrint) return true;\r\n\r\n    if (this.props.pdf !== nextProps.pdf) {\r\n      return true;\r\n    }\r\n\r\n    console.log(\"[PrintPdfMain] CHECK START props\");\r\n    compareObject(this.props, nextProps, \"PrintPdfMain\");\r\n\r\n    console.log(\"[PrintPdfMain] CHECK START state\");\r\n    compareObject(this.state, nextState, \"PrintPdfMain\");\r\n\r\n    return false;\r\n  }\r\n\r\n  public OnPagePrepared = (event: { sheetIndex: number, pageNums: number[], completion: number }) => {\r\n    const { sheetIndex, pageNums, completion } = event;\r\n\r\n    const { targetPages, pagesPerSheet } = this.props.printOption;\r\n\r\n    if (completion === 100) {\r\n      if (this.renderedSheets.indexOf(sheetIndex) < 0) {\r\n        this.renderedSheets.push(sheetIndex);\r\n      }\r\n\r\n      this.renderedPages.push(...pageNums);\r\n    }\r\n\r\n    const numCompleted = Object.keys(this.renderedSheets).length;\r\n\r\n    /** callback을 불러준다 */\r\n    if (this.props.updatePrintProgress) {\r\n      const event: IPrintingProgress = {\r\n        preparedPages: [...this.renderedPages],\r\n        numSheetsPrepared: numCompleted,\r\n        completion,\r\n      }\r\n      this.props.updatePrintProgress(event);\r\n    }\r\n\r\n    /** 모든 페이지의 렌더링이 끝났는지 확인한다.  */\r\n    const numSheets = Math.ceil(targetPages.length / pagesPerSheet);\r\n    const pageNo = targetPages[sheetIndex];\r\n\r\n    // const numPages = endPage - startPage + 1;\r\n    console.log(`[PrintPdfMain] Page rendered: ${pageNo} : ${numCompleted}/${numSheets}`);\r\n    if (numCompleted === numSheets) {\r\n      console.log(\"[PrintPdfMain] Print!!!\");\r\n      // console.timeEnd('Function #1');\r\n      this.onPageRenderCompleted();\r\n    }\r\n  }\r\n\r\n\r\n\r\n  setComponentRef = (ref: PagesForPrint) => {\r\n    this.componentRef = ref;\r\n  }\r\n\r\n  setPrinttRef = (ref: ReactToPrint) => {\r\n    this.printRef = ref;\r\n  }\r\n\r\n\r\n  reactToPrintContent = () => {\r\n    return this.componentRef;\r\n  }\r\n\r\n  reactToPrintTrigger = () => {\r\n    // NOTE: could just as easily return <SomeComponent />. Do NOT pass an `onClick` prop\r\n    // to the root node of the returned component as it will be overwritten.\r\n\r\n    // Bad: the `onClick` here will be overwritten by `react-to-print`\r\n    // return <a href=\"#\" onClick={() => alert('This will not work')}>Print this out!</a>;\r\n\r\n    // Good\r\n    // return <a href=\"#\">Print using a Class Component</a>;\r\n    // return <a href=\"#\">Print using a Class Component</a>;\r\n    return \"\";\r\n  }\r\n\r\n  getSnapshotBeforeUpdate = (prevProps: Props, prevState: State) => {\r\n    console.log(\"[PrintPdfMain] getSnapshotBeforeUpdate\");\r\n\r\n    return null;\r\n  }\r\n\r\n\r\n  onPageRenderCompleted = () => {\r\n    this.setState({\r\n      text: \"Rendering Completed\",\r\n      renderingCompleted: true,\r\n    });\r\n  }\r\n\r\n\r\n  componentDidUpdate(prevProps: Props, prevState: State) {\r\n    console.log(\"[PrintPdfMain] componentDidUpdate\");\r\n\r\n    // if (this.state.renderingCompleted !== prevState.renderingCompleted) {\r\n    if (this.state.renderingCompleted) {\r\n      /** 페이지 렌더링이 끝나고 나면 ReactToPrint Component에 handlePrint를 부른다 */\r\n      this.setState({\r\n        text: \"Print start\",\r\n        renderingCompleted: false,\r\n      });\r\n      this.startPrintOnRenderCompleted();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 페이지 렌더링이 끝나고 나면 ReactToPrint Component에 handlePrint를 부른다\r\n   */\r\n  startPrintOnRenderCompleted = () => {\r\n    if (this.printRef) {\r\n      this.printRef.handlePrint();\r\n      this.setState({\r\n        text: \"Print started\",\r\n        shouldPrint: false,\r\n      });\r\n    }\r\n  }\r\n\r\n\r\n  render() {\r\n    const { pdf, printOption, pagesOverview } = this.props;\r\n    const { shouldRenderPage, shouldPrint } = this.state;\r\n\r\n    const { pagesPerSheet, direction } = printOption;\r\n    let isLandscape = (direction === \"landscape\");\r\n\r\n    const { rotation } = getCellMatrixShape(pagesPerSheet, direction);\r\n    const isRotationNeeded = rotation === 90;\r\n    if (isRotationNeeded) isLandscape = !isLandscape;\r\n\r\n    // globalPagesCnt++;\r\n    // const { startPage, endPage } = printOption;\r\n\r\n    return (\r\n      <div>\r\n        { shouldPrint ?\r\n          (\r\n            <div style={{ display: \"none\" }}>\r\n              { isLandscape ? (<LandscapeOrientation />) : (<PortraitOrientation />)}\r\n\r\n              <ReactToPrint\r\n                // key={`action-${pdf.fingerprint}-${globalPagesCnt}`}\r\n                ref={this.setPrinttRef}\r\n                content={this.reactToPrintContent}\r\n                documentTitle={this.title}\r\n                onAfterPrint={this.handleAfterPrint}\r\n                onBeforeGetContent={this.handleOnBeforeGetContent}\r\n                onBeforePrint={this.handleBeforePrint}\r\n                removeAfterPrint\r\n              // trigger={this.reactToPrintTrigger}\r\n              />\r\n              {/* <PagesForPrint ref={this.setComponentRef} text={this.state.text}\r\n                // key={`print-${pdf.fingerprint}-${globalPagesCnt}`}\r\n                pdf={pdf}\r\n                shouldRenderPage={shouldRenderPage}\r\n                OnPagePrepared={this.OnPagePrepared}\r\n                printOption={printOption}\r\n              /> */}\r\n            </div>\r\n          ) : (<></>)\r\n        }\r\n\r\n        <PagesForPrint ref={this.setComponentRef} text={this.state.text}\r\n          // key={`screen-${pdf.fingerprint}-${globalPagesCnt}`}\r\n          pdf={pdf}\r\n          pagesOverview={pagesOverview}\r\n          shouldRenderPage={shouldRenderPage}\r\n          OnPagePrepared={null}\r\n          printOption={printOption}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationDialog.tsx",["536","537","538","539","540","541"],"import React, { useState } from \"react\";\r\n\r\n// import { makeStyles } from '@material-ui/core/styles';\r\n\r\n\r\nimport Dialog from '@material-ui/core/Dialog';\r\nimport DialogActions from '@material-ui/core/DialogActions';\r\nimport DialogContent from '@material-ui/core/DialogContent';\r\nimport DialogContentText from '@material-ui/core/DialogContentText';\r\nimport DialogTitle from '@material-ui/core/DialogTitle';\r\nimport { Button, makeStyles, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow } from \"@material-ui/core\";\r\nimport { t } from \"../../Locales/i18n\";\r\n\r\n\r\n// const useStyles = makeStyles((theme) => ({\r\n//   form: {\r\n//     display: 'flex',\r\n//     flexDirection: 'column',\r\n//     margin: 'auto',\r\n//     width: 'fit-content',\r\n//   },\r\n//   formControl: {\r\n//     marginTop: theme.spacing(2),\r\n//     minWidth: 120,\r\n//   },\r\n//   formControlLabel: {\r\n//     marginTop: theme.spacing(1),\r\n//   },\r\n// }));\r\nconst useStyles = makeStyles({\r\n  table: {\r\n    minWidth: 400,\r\n  },\r\n});\r\n\r\n\r\nconst useStyles2 = makeStyles({\r\n  table: {\r\n    minWidth: 2000,\r\n  },\r\n});\r\n\r\n\r\ntype Props = {\r\n  open: boolean,\r\n  handleClose: any,\r\n  pageNo: number,\r\n}\r\n\r\n\r\n\r\n\r\nconst TAX_RATE = 0.07;\r\n\r\n\r\nfunction ccyFormat(num: number) {\r\n  return `${num.toFixed(2)}`;\r\n}\r\n\r\nfunction priceRow(qty: number, unit: number) {\r\n  return qty * unit;\r\n}\r\n\r\nfunction createRow(desc: string, qty: number, unit: number) {\r\n  const price = priceRow(qty, unit);\r\n  return { desc, qty, unit, price };\r\n}\r\n\r\ninterface Row {\r\n  desc: string;\r\n  qty: number;\r\n  unit: number;\r\n  price: number;\r\n}\r\n\r\nfunction subtotal(items: Row[]) {\r\n  return items.map(({ price }) => price).reduce((sum, i) => sum + i, 0);\r\n}\r\n\r\nconst rows = [\r\n  createRow('Paperclips (Box)', 100, 1.15),\r\n  createRow('Paper (Case)', 10, 45.99),\r\n  createRow('Waste Basket', 2, 17.99),\r\n];\r\n\r\nconst invoiceSubtotal = subtotal(rows);\r\nconst invoiceTaxes = TAX_RATE * invoiceSubtotal;\r\nconst invoiceTotal = invoiceTaxes + invoiceSubtotal;\r\n\r\ntype maxWidthType = \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\";\r\n\r\nexport default function CalibrationDialog(props: Props) {\r\n  const { open, handleClose, pageNo } = props;\r\n  const classes = useStyles();\r\n  const classes2 = useStyles2();\r\n\r\n  const handleSave = (e) => {\r\n    console.log(\"Save\");\r\n  }\r\n\r\n  const onChange = (e) => {\r\n    console.log(e.target.value);\r\n  }\r\n\r\n\r\n  const maxWidth = \"md\";\r\n\r\n  const img_src = \"https://www.k-voucher.kr/bbs/service/2020-09/16010263390201_1_1601026339.PNG\";\r\n\r\n  return (\r\n    <div>\r\n      <Dialog open={open} onClose={handleClose}\r\n        fullWidth={true}\r\n        maxWidth={maxWidth}\r\n        aria-labelledby=\"form-dialog-title\">\r\n\r\n        <DialogTitle id=\"form-dialog-title\">{t('calibration_dlg_title')}</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            Dialog의 Body\r\n          </DialogContentText>\r\n        </DialogContent>\r\n\r\n\r\n\r\n\r\n\r\n        <TableContainer component={Paper}>\r\n          <Table className={classes.table} aria-label=\"spanning table\">\r\n            <TableHead>\r\n              <TableRow>\r\n                <TableCell align=\"center\" colSpan={3}>\r\n                  Details\r\n            </TableCell>\r\n                <TableCell align=\"right\">Price</TableCell>\r\n              </TableRow>\r\n              <TableRow>\r\n                <TableCell>Desc</TableCell>\r\n                <TableCell align=\"right\">Qty.</TableCell>\r\n                <TableCell align=\"right\">Unit</TableCell>\r\n                <TableCell align=\"right\">Sum</TableCell>\r\n              </TableRow>\r\n            </TableHead>\r\n            <TableBody>\r\n              {rows.map((row) => (\r\n                <TableRow key={row.desc}>\r\n                  <TableCell>{row.desc}</TableCell>\r\n                  <TableCell align=\"right\">{row.qty}</TableCell>\r\n                  <TableCell align=\"right\">{row.unit}</TableCell>\r\n                  <TableCell align=\"right\">{ccyFormat(row.price)}</TableCell>\r\n                </TableRow>\r\n              ))}\r\n              <TableRow>\r\n                <TableCell rowSpan={3} />\r\n                <TableCell colSpan={2}>Subtotal</TableCell>\r\n                <TableCell align=\"right\">{ccyFormat(invoiceSubtotal)}</TableCell>\r\n              </TableRow>\r\n              <TableRow>\r\n                <TableCell>Tax</TableCell>\r\n                <TableCell align=\"right\">{`${(TAX_RATE * 100).toFixed(0)} %`}</TableCell>\r\n                <TableCell align=\"right\">{ccyFormat(invoiceTaxes)}</TableCell>\r\n              </TableRow>\r\n              <TableRow>\r\n                <TableCell colSpan={2}>Total</TableCell>\r\n                <TableCell align=\"right\">{ccyFormat(invoiceTotal)}</TableCell>\r\n              </TableRow>\r\n            </TableBody>\r\n          </Table>\r\n        </TableContainer>\r\n\r\n\r\n\r\n\r\n\r\n\r\n        <TableContainer component={Paper}>\r\n          <Table className={classes2.table} aria-label=\"spanning table\">\r\n\r\n\r\n            <TableBody>\r\n              <TableRow>\r\n                <TableCell>\r\n                  <img src={img_src} style={{ width: \"400px\", height: \"400px\" }} />\r\n                </TableCell>\r\n                <TableCell>\r\n                  <img src={img_src} style={{ width: \"400px\", height: \"400px\" }} />\r\n                </TableCell>\r\n                <TableCell>\r\n                  <img src={img_src} style={{ width: \"400px\", height: \"400px\" }} />\r\n                </TableCell>\r\n                <TableCell>\r\n                  <img src={img_src} style={{ width: \"400px\", height: \"400px\" }} />\r\n                </TableCell>\r\n              </TableRow>\r\n            </TableBody>\r\n          </Table>\r\n        </TableContainer>\r\n\r\n\r\n        <DialogActions>\r\n          <Button autoFocus onClick={handleClose} color=\"primary\">\r\n            취소\r\n          </Button>\r\n        </DialogActions>\r\n      </Dialog>\r\n    </div>\r\n  );\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_event.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfDocument.ts",["542","543","544"],"import * as PdfJs from \"pdfjs-dist\";\r\nimport { CoordinateTanslater, IPolygonArea } from \"../Coordinates\";\r\nimport { stringToDpiNum, } from \"../DataStructure/Structures\";\r\nimport { getDocumentId, } from \"../NcodePrint\";\r\nimport { IPageOverview } from \"../NcodePrint/PagesForPrint\";\r\nimport { ColorConvertMethod } from \"../NcodeSurface/CanvasColorConverter\";\r\nimport { getNcodeAtCanvasPixel, getNcodeRectAtCanvasPixel, ICellsOnSheetDesc } from \"../NcodeSurface/NcodeRasterizer\";\r\nimport { MappingItem } from \"../SurfaceMapper/MappingItem\";\r\nimport MappingStorage from \"../SurfaceMapper/MappingStorage\";\r\nimport NeoPdfPage, { IPdfPageCanvasDesc, PDF_VIEWPORT_DESC } from \"./NeoPdfPage\";\r\n\r\nPdfJs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${PdfJs.version}/pdf.worker.js`;\r\nconst CMAP_URL = \"./cmaps/\";\r\nconst CMAP_PACKED = true;\r\n\r\nexport type IGetDocumentOptions = {\r\n  url?: string,\r\n  fingerprint?: string,\r\n  cMapUrl?: string,\r\n  cMapPacked?: boolean,\r\n}\r\n\r\nexport type IPdfDocDesc = {\r\n  /** PDF url */\r\n  url: string,\r\n\r\n  /** PDF finger print */\r\n  fingerprint: string,\r\n\r\n  /** POD id = fingerprint + \"/\" + pagesPerSheet */\r\n  id: string,\r\n\r\n  /** total pages in pdf file */\r\n  numPages: number,\r\n};\r\n\r\n\r\n\r\n\r\nexport default class NeoPdfDocument {\r\n  _pdfDoc: PdfJs.PDFDocumentProxy = null;\r\n\r\n  _ready: PdfJs.PDFLoadingTask<PdfJs.PDFDocumentProxy>;\r\n\r\n  _url: string;\r\n\r\n  _fingerprint: string;\r\n\r\n  _id: string;\r\n\r\n  private _pages: NeoPdfPage[];\r\n\r\n  pagesOverview: IPageOverview[];\r\n\r\n  direction: \"portrait\" | \"landscape\";\r\n\r\n  load = async (options: IGetDocumentOptions) => {\r\n    await this.justLoad(options);\r\n\r\n    // const { url, cMapUrl, cMapPacked } = options;\r\n\r\n    // this._url = url;\r\n    // this._ready = PdfJs.getDocument(\r\n    //   {\r\n    //     url: url,\r\n    //     cMapUrl: cMapUrl ? cMapUrl : CMAP_URL,\r\n    //     cMapPacked: cMapPacked ? cMapPacked : CMAP_PACKED,\r\n    //   });\r\n\r\n    // const _pdfDoc = await this._ready.promise;\r\n    // this._pdfDoc = _pdfDoc;\r\n    // this._fingerprint = _pdfDoc.fingerprint;\r\n\r\n    // page를 로드한다\r\n    this._pages = [];\r\n    for (let i = 1; i <= this._pdfDoc.numPages; i++) {\r\n      const neoPage = new NeoPdfPage(this, i);\r\n      this._pages.push(neoPage);\r\n    }\r\n\r\n    await this.setPageOverview(this);\r\n    return this;\r\n  }\r\n\r\n  destroy = () => {\r\n    this._pages = [];\r\n    this._pdfDoc.destroy();\r\n  }\r\n\r\n  justLoad = async (options: IGetDocumentOptions) => {\r\n    const { url, cMapUrl, cMapPacked } = options;\r\n\r\n    this._url = url;\r\n    this._ready = PdfJs.getDocument(\r\n      {\r\n        url: url,\r\n        cMapUrl: cMapUrl ? cMapUrl : CMAP_URL,\r\n        cMapPacked: cMapPacked ? cMapPacked : CMAP_PACKED,\r\n      });\r\n\r\n    const pdfDoc = await this._ready.promise;\r\n    this._pdfDoc = pdfDoc;\r\n    this._fingerprint = pdfDoc.fingerprint;\r\n\r\n    return this;\r\n  }\r\n\r\n  get numPages() {\r\n    return this._pdfDoc.numPages;\r\n  }\r\n\r\n  get url() {\r\n    return this._url;\r\n  }\r\n\r\n  get fingerprint() {\r\n    return this._fingerprint;\r\n  }\r\n\r\n  getPageAsync = async (pageNo: number) => {\r\n    await this._pages[pageNo - 1]._ready;\r\n    return this._pages[pageNo - 1];\r\n  }\r\n\r\n  /** page가 로드된 것이 확실할 때만 쓸 것! */\r\n  getPage = (pageNo: number) => {\r\n    if (!this._pages[pageNo - 1]._loaded) {\r\n      throw new Error(`PDF page ${pageNo} has not been loaded`);\r\n    }\r\n\r\n    return this._pages[pageNo - 1];\r\n  }\r\n\r\n  getMetadata = async () => {\r\n    return this._pdfDoc.getMetadata();\r\n  }\r\n\r\n  public renderPages_dpi = async (pageNums: number[], dpi: number, colorConvertMode?: ColorConvertMethod)\r\n    : Promise<IPdfPageCanvasDesc[]> => {\r\n    const pdfDpi = dpi;\r\n\r\n    const promises: Promise<IPdfPageCanvasDesc>[] = [];\r\n    for (let i = 0; i < pageNums.length; i++) {\r\n      const pageNo = pageNums[i];\r\n      const neoPage = await this.getPageAsync(pageNo);\r\n      const pr = neoPage.render_dpi(i, pdfDpi).then(async (canvasDesc) => {\r\n        return await neoPage.convertColor(canvasDesc, colorConvertMode);\r\n      })\r\n      promises.push(pr);\r\n    }\r\n    const descs = await Promise.all(promises);\r\n\r\n    const pageImageDescs: IPdfPageCanvasDesc[] = new Array(descs.length);\r\n    descs.forEach(async (canvasDesc) => {\r\n      const { index } = canvasDesc;\r\n      pageImageDescs[index] = canvasDesc;\r\n      // console.log(`[Multipage] page rendered ${canvasDesc.pdfPageInfo.pageNo}, index ${index}`);\r\n    });\r\n\r\n    // let converterPromises = [];\r\n    // descs.forEach(async (canvasDesc) => {\r\n    //   const { index } = canvasDesc;\r\n    //   pageImageDescs[index] = canvasDesc;\r\n\r\n    //   const pdfCanvas = canvasDesc.canvas;\r\n    //   const converter = new CanvasColorConverter(pdfCanvas);\r\n    //   const pr = converter.convert(colorConvertMode);\r\n    //   converterPromises.push(pr);\r\n    // });\r\n    return pageImageDescs;\r\n  }\r\n\r\n\r\n  registerMappingItem = (pageImagesDesc: IPdfPageCanvasDesc[], ncodePlane: ICellsOnSheetDesc, assignNewCode: boolean) => {\r\n    for (let i = 0; i < ncodePlane.ncodeAreas.length; i++) {\r\n      const desc = pageImagesDesc[i];\r\n      const pdfRect = desc.drawnRect;\r\n      const ncode = ncodePlane.ncodeAreas[i];\r\n\r\n      const mapData = new MappingItem();\r\n\r\n      /** canvas 좌표계 */\r\n      const { x, y, unit, width, height } = pdfRect;\r\n      const dpi = stringToDpiNum(unit);\r\n\r\n      /** Ncode 좌표계 */\r\n      const pt0_nu = getNcodeAtCanvasPixel({ x, y, dpi }, ncodePlane);\r\n      const pt1_nu = getNcodeAtCanvasPixel({ x: x + width, y: y + height, dpi }, ncodePlane);\r\n\r\n      const pdfRect_nu = getNcodeRectAtCanvasPixel({ dpi, x, y, width, height }, ncodePlane);\r\n\r\n      /** 페이지에 해당하는 ncode가 인쇄된 영역 */\r\n      const r_nu = ncode.rect;\r\n      const polygon: IPolygonArea = [\r\n        { x: r_nu.x, y: r_nu.y },\r\n        { x: r_nu.x + r_nu.width, y: r_nu.y },\r\n        { x: r_nu.x + r_nu.width, y: r_nu.y + r_nu.height },\r\n        { x: r_nu.x, y: r_nu.y + r_nu.height },\r\n      ];\r\n\r\n      mapData.setNcodeArea({\r\n        pageInfo: ncode.pageInfo,\r\n        pdfDrawnRect: { ...pdfRect_nu },\r\n        npageArea: polygon,\r\n      });\r\n\r\n\r\n      /** PDF 좌표계 */\r\n      mapData.setPdfArea({\r\n        pdfPageInfo: { ...desc.pdfPageInfo },\r\n        rect: {\r\n          unit: \"pu\",\r\n          x: 0, y: 0,\r\n          width: desc.width_pu,\r\n          height: desc.height_pu,\r\n        }\r\n      });\r\n\r\n      const trans = new CoordinateTanslater();\r\n      trans.calc(mapData);\r\n      const pageNo = desc.pdfPageInfo.pageNo;\r\n      const page = this.getPage(pageNo);\r\n      page.setTranslater(trans);\r\n\r\n      if (assignNewCode) {\r\n        const st = MappingStorage.getInstance();\r\n        st.register(trans);\r\n\r\n\r\n      }\r\n      // trans.dump(`[dump-${this._url}]-${i} `);\r\n    }\r\n\r\n    if (assignNewCode) {\r\n      const st = MappingStorage.getInstance();\r\n      // st.dump(\"MAP\");\r\n    }\r\n  }\r\n\r\n  setDocumentId = (pagesPerSheet: number) => {\r\n    this._id = getDocumentId(this._fingerprint, pagesPerSheet);\r\n  }\r\n\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  setPageOverview = async (pdf) => {\r\n    // const pdf = this.props.pdf;\r\n    this.pagesOverview = new Array(pdf.numPages + 1);\r\n    // const { pagesPerSheet } = this.printOption;\r\n\r\n    let numPortraitPages = 0;\r\n    let numLandscapePages = 0;\r\n\r\n    for (let i = 0; i < pdf.numPages; i++) {\r\n      const page = await pdf.getPageAsync(i + 1);\r\n      const vpt: PDF_VIEWPORT_DESC = page.getViewport({ scale: 1, rotation: 0 });\r\n      const { width, height } = vpt;\r\n\r\n      const landscape = width > height;\r\n      landscape ? numLandscapePages++ : numPortraitPages++;\r\n\r\n      const pageOverview = {\r\n        rotation: vpt.rotation,\r\n        landscape,\r\n        sizePu: { width, height },\r\n      }\r\n      this.pagesOverview[i] = pageOverview;\r\n    }\r\n\r\n\r\n    if (numPortraitPages >= numLandscapePages) {\r\n      this.direction = \"portrait\";\r\n    } else {\r\n      this.direction = \"landscape\";\r\n    }\r\n\r\n    return this.direction;\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_const.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pen_util_func.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\Page.tsx",["545","546","547","548"],"import React, { Component } from 'react';\r\nimport { pdfSizeToDIsplayPixel } from \"../../utils/UtilsFunc\";\r\n\r\nimport \"pdfjs-dist\";\r\nimport * as PdfJs from \"pdfjs-dist\";\r\n\r\n\r\n/**\r\n * Page.js\r\n * Component rendering page of PDF\r\n **/\r\n\r\ninterface PageProps {\r\n  pdf: PdfJs.PDFDocumentProxy,\r\n  index: number,\r\n  scale?: number,\r\n  position: { offsetX: number, offsetY: number, zoom: number },\r\n}\r\n\r\ninterface PageState {\r\n  status: string,\r\n  page: PdfJs.PDFPageProxy | null,\r\n  width: number,\r\n  height: number,\r\n  imgSrc: string,\r\n  renderCount: number;\r\n}\r\n\r\nclass Page extends Component<PageProps> {\r\n  state: PageState = {\r\n    status: 'N/A',\r\n    page: null,\r\n    width: 0,\r\n    height: 0,\r\n    imgSrc: URL.createObjectURL(new Blob()),\r\n    renderCount: 0,\r\n  };\r\n\r\n  canvas: HTMLCanvasElement | null = null;\r\n  inRendering = false;\r\n  inImageRendering = false;\r\n\r\n  scaleCanvas(canvas: HTMLCanvasElement, width: number, height: number, zoom: number) {\r\n    // assume the device pixel ratio is 1 if the browser doesn't specify it\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const context = canvas.getContext('2d');\r\n\r\n    // determine the 'backing store ratio' of the canvas context\r\n    const backingStoreRatio = 1;\r\n    // (\r\n    //   context.webkitBackingStorePixelRatio ||\r\n    //   context.mozBackingStorePixelRatio ||\r\n    //   context.msBackingStorePixelRatio ||\r\n    //   context.oBackingStorePixelRatio ||\r\n    //   context.backingStorePixelRatio || 1\r\n    // );\r\n\r\n    // determine the actual ratio we want to draw at\r\n    const ratio = devicePixelRatio * zoom / backingStoreRatio;\r\n\r\n    if (devicePixelRatio !== backingStoreRatio) {\r\n      // set the 'real' canvas size to the higher width/height\r\n      canvas.width = width * ratio;\r\n      canvas.height = height * ratio;\r\n\r\n      // ...then scale it back down with CSS\r\n      canvas.style.width = width + 'px';\r\n      canvas.style.height = height + 'px';\r\n    }\r\n    else {\r\n      // this is a normal 1:1 device; just scale it simply\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      canvas.style.width = '';\r\n      canvas.style.height = '';\r\n    }\r\n\r\n    // scale the drawing context so everything will work at the higher ratio\r\n    context.scale(ratio, ratio);\r\n  }\r\n\r\n\r\n  shouldComponentUpdate(nextProps: PageProps, nextState: PageState) {\r\n    // const ret = this.state.status !== nextState.status || this.state.renderCount !== nextState.renderCount || this.state.page !== nextState.page;\r\n    const zoomChanged = nextProps.position.zoom !== this.props.position.zoom;\r\n    // const imageChanged = nextState.imgSrc !== this.state.imgSrc;\r\n\r\n    if (zoomChanged) {\r\n      this.renderPage(this.state.page, nextProps.position.zoom);\r\n      return false;\r\n    }\r\n\r\n    const pdfChanged = this.props.pdf !== nextProps.pdf;\r\n    if (pdfChanged) {\r\n      this._update(nextProps.pdf);\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n    // return ret || zoomChanged || imageChanged;\r\n  }\r\n\r\n  componentDidUpdate(nextProps: PageProps) {\r\n    // this._update(nextProps.pdf);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const { pdf } = this.props;\r\n    this._update(pdf);\r\n  }\r\n\r\n  setCanvasRef = (canvas: HTMLCanvasElement) => {\r\n    this.canvas = canvas;\r\n  };\r\n\r\n  /**\r\n   *\r\n   */\r\n  _update = (pdf: PdfJs.PDFDocumentProxy) => {\r\n    if (pdf) {\r\n      this._loadPage(pdf);\r\n    } else {\r\n      this.setState({ status: 'loading' });\r\n    }\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param page\r\n   * @param zoom\r\n   */\r\n  renderPage = (page: PdfJs.PDFPageProxy, zoom: number) => {\r\n    if (!this.inRendering) {\r\n      this._renderPage(page);\r\n    }\r\n    if (!this.inImageRendering) {\r\n      // this.renderPageToImage(page, zoom);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  _loadPage = (pdf: PdfJs.PDFDocumentProxy) => {\r\n    if (this.state.status === 'rendering') return;\r\n\r\n    pdf.getPage(this.props.index).then(\r\n      (page) => {\r\n        this.setState({ page, status: 'rendering' });\r\n        this.renderPage(page, this.props.position.zoom);\r\n      }\r\n    );\r\n  }\r\n\r\n\r\n\r\n  renderPageToImage = (page: PdfJs.PDFPageProxy, zoom: number): HTMLImageElement => {\r\n    const img = document.createElement(\"img\");\r\n    const canvas = document.createElement(\"canvas\");\r\n\r\n    this.inImageRendering = true;\r\n\r\n    console.log(this.props);\r\n    // let { scale } = this.props;\r\n\r\n    // let aa = 2;\r\n\r\n    let viewport: any = page.getViewport({ scale: 1 });\r\n    const { width, height } = viewport;\r\n\r\n    const size = { width, height };\r\n    const displaySize = pdfSizeToDIsplayPixel(size);\r\n    const new_scale = displaySize.width / viewport.width;\r\n\r\n    viewport = page.getViewport({ scale: new_scale });\r\n\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    // scaleCanvas(canvas, ctx, width, height);\r\n    this.scaleCanvas(canvas, displaySize.width, displaySize.height, zoom);\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgba(255, 255, 255, 255)\";     // 투명 캔버스\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    console.log(viewport);\r\n    ctx.restore();\r\n\r\n    const renderTask = page.render({\r\n      canvasContext: ctx,\r\n      viewport,\r\n      // intent: \"print\",\r\n    });\r\n\r\n    const self = this;\r\n    renderTask.promise.then(() => {\r\n      self.setState({ status: 'rendered', page, width, height });\r\n\r\n      const canvasAny: any = canvas;\r\n      if (\"toBlob\" in canvasAny) {\r\n        canvasAny.toBlob(function (blob) {\r\n          self.setState({ imgSrc: URL.createObjectURL(blob) });\r\n        });\r\n      } else {\r\n        self.setState({ imgSrc: canvasAny.toDataURL() });\r\n      }\r\n\r\n      // self.setState({ status: 'rendered', page, width, height });\r\n\r\n      this.inImageRendering = false;\r\n    });\r\n\r\n    return img;\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   */\r\n  _renderPage = (page: PdfJs.PDFPageProxy) => {\r\n    // return;\r\n    this.inRendering = true;\r\n\r\n    console.log(this.props);\r\n    // let { scale } = this.props;\r\n\r\n    // let aa = 2;\r\n\r\n    let viewport: any = page.getViewport({ scale: 1 });\r\n    const { width, height } = viewport;\r\n    const canvas = this.canvas;\r\n\r\n    const size = { width, height };\r\n    const displaySize = pdfSizeToDIsplayPixel(size);\r\n    const new_scale = displaySize.width / viewport.width;\r\n\r\n    viewport = page.getViewport({ scale: new_scale });\r\n    // viewport.viewBox[2] = 100;\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    // scaleCanvas(canvas, ctx, width, height);\r\n    this.scaleCanvas(canvas, displaySize.width, displaySize.height, this.props.position.zoom);\r\n    console.log(viewport);\r\n\r\n    const renderTask = page.render({\r\n      canvasContext: ctx,\r\n      viewport,\r\n      // intent: \"print\",\r\n    });\r\n\r\n    const self = this;\r\n    renderTask.promise.then(() => {\r\n      const renderCount = this.state.renderCount + 1;\r\n      self.setState({ status: 'rendered', page, width, height, renderCount });\r\n      this.inRendering = false;\r\n    });\r\n  }\r\n\r\n  render = () => {\r\n    const { status } = this.state;\r\n\r\n    return (\r\n      <div className={`pdf-page ${status}`} >\r\n        {/* <img src={this.state.imgSrc} /> */}\r\n        <canvas ref={this.setCanvasRef} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport { Page };","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_enum.ts",["549","550","551","552","553","554","555","556","557","558","559","560","561","562"],"\r\n/** @enum {string} */\r\nexport enum DeviceTypeEnum {\r\n  PEN = \"pen\",\r\n  ERASER = \"eraser\",\r\n  PLAYER = \"player\",\r\n  STYLUS = \"stylus\",\r\n  FSIR = \"fsir\",\r\n  NONE = \"none\",\r\n}\r\n\r\n\r\nexport enum PenModelEnum {\r\n  F121 = DeviceTypeEnum.PEN,\r\n  F120 = DeviceTypeEnum.PEN,\r\n  F51 = DeviceTypeEnum.PEN,\r\n  F50 = DeviceTypeEnum.PEN,\r\n  F30 = DeviceTypeEnum.PEN,\r\n\r\n  E100 = DeviceTypeEnum.ERASER,\r\n  E101 = DeviceTypeEnum.ERASER,\r\n\r\n  X100 = DeviceTypeEnum.STYLUS,\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_base.ts",["563","564","565","566","567"],"/// <reference types=\"web-bluetooth\" />\r\n\r\nimport {\r\n  PEN_PACKET_START,\r\n  PEN_PACKET_END,\r\n  PEN_SERVICE_UUID_16,\r\n  PEN_CHARACTERISTICS_WRITE_UUID_16,\r\n  PEN_CHARACTERISTICS_NOTIFICATION_UUID_16,\r\n  PEN_SERVICE_UUID_128,\r\n  PEN_CHARACTERISTICS_WRITE_UUID_128,\r\n  PEN_CHARACTERISTICS_NOTIFICATION_UUID_128,\r\n} from \"./pencomm_const\";\r\n\r\nimport { unescapePacket } from \"./pen_util_func\";\r\n// import * as Bluetooth from 'react-bluetooth';\r\nimport \"../types\";\r\n\r\nexport async function deviceSelectDlg(): Promise<BluetoothDevice> {\r\n  console.log(\"********* Requesting any Bluetooth Device... **********\");\r\n\r\n  const options = {\r\n    // acceptAllDevices: true,\r\n    filters: [\r\n      { services: [PEN_SERVICE_UUID_16, PEN_SERVICE_UUID_128] },\r\n      // { services: [PEN_SERVICE_UUID_128] },\r\n      { namePrefix: \"Neosmartpen\" },\r\n      { namePrefix: \"Smartpen\" }\r\n    ]\r\n  }\r\n  // let result = await Bluetooth.requestDeviceAsync(options);\r\n\r\n  let result = { device: null, type: \"null\" };\r\n\r\n  try {\r\n    // let mobileNavigatorObject: any = window.navigator;\r\n    const device = await navigator.bluetooth.requestDevice(options);\r\n    result = { type: 'success', device };\r\n  }\r\n  catch (error) {\r\n    if (error.code === 8) {\r\n      // User Cancelled\r\n      result = { device: null, type: 'cancel' };\r\n    }\r\n    throw error;\r\n  }\r\n\r\n  if (result.type === 'cancel') {\r\n    return null;\r\n  }\r\n\r\n  return result.device;\r\n}\r\n\r\nenum DEVICE_STATE {\r\n  disconnected = 0,\r\n  connecting = 1,\r\n  connected = 2,\r\n}\r\n\r\ntype GetServiceReturnType = {\r\n  service: BluetoothRemoteGATTService,\r\n  writeSocket: BluetoothRemoteGATTCharacteristic,\r\n  notifyIndicate: BluetoothRemoteGATTCharacteristic,\r\n};\r\n\r\ntype BT_UUID_DEFINITION = {\r\n  service: string | number,\r\n  write: string | number,\r\n  noti: string | number,\r\n};\r\n\r\nconst PEN_BT_UUID: { [key: string]: BT_UUID_DEFINITION } = {\r\n  // for F30, and future devices\r\n  \"new\": {\r\n    service: PEN_SERVICE_UUID_128,\r\n    write: PEN_CHARACTERISTICS_WRITE_UUID_128,\r\n    noti: PEN_CHARACTERISTICS_NOTIFICATION_UUID_128,\r\n  },\r\n\r\n  // for F51, F50, F121, F120\r\n  \"old\": {\r\n    service: PEN_SERVICE_UUID_16,\r\n    write: PEN_CHARACTERISTICS_WRITE_UUID_16,\r\n    noti: PEN_CHARACTERISTICS_NOTIFICATION_UUID_16,\r\n  }\r\n}\r\n\r\nexport class PenCommBase {\r\n\r\n  protocolHandler: ProtocolHandlerBase = null;\r\n  btDevice: BluetoothDevice = null;\r\n\r\n  _btWriteSocket: BluetoothRemoteGATTCharacteristic = null;\r\n  _btNotifyIndicate: BluetoothRemoteGATTCharacteristic = null;\r\n\r\n  // this._bluetooth_MTU = 1024;\r\n\r\n  _bt_buffer = new Uint8Array(0);\r\n  // this.modelNameString = null;\r\n\r\n  inConnecting = false;\r\n  inDisconnecting = false;\r\n  connected = false;\r\n\r\n  _state = DEVICE_STATE.disconnected;\r\n\r\n  btServer: BluetoothRemoteGATTServer = null;\r\n\r\n\r\n  /**\r\n   * \r\n   * @param protocolHandler \r\n   */\r\n  constructor(protocolHandler: ProtocolHandlerBase) {\r\n    this.protocolHandler = protocolHandler;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * \r\n   * @param uuids \r\n   * @param server \r\n   */\r\n  async getServiceProcess(uuids: BT_UUID_DEFINITION, server: BluetoothRemoteGATTServer): Promise<GetServiceReturnType> {\r\n    console.log(`  2-1. M1 getPrimaryService, connected:${server.connected}`);\r\n    const service = await server.getPrimaryService(uuids.service);\r\n\r\n    console.log(`  2-2. M1 getCharacteristic, connected:${server.connected}`);\r\n    const writeSocket = await service.getCharacteristic(uuids.write);\r\n\r\n    console.log(`  2-3. M1 getCharacteristic, connected:${server.connected}`);\r\n    const notifyIndicate = await service.getCharacteristic(uuids.noti);\r\n\r\n    return { service, writeSocket, notifyIndicate };\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param server \r\n   */\r\n  getService = async (server: BluetoothRemoteGATTServer): Promise<GetServiceReturnType> => {\r\n    let uuids = [PEN_BT_UUID.old, PEN_BT_UUID.new];\r\n    if (server.device.name === \"Smartpen dimo_d\") {\r\n      uuids = [PEN_BT_UUID.new, PEN_BT_UUID.old];\r\n    }\r\n\r\n    try {\r\n      const result = await this.getServiceProcess(uuids[0], server);\r\n      return result;\r\n    } catch (e) {\r\n      console.log(`  ==> failed`);\r\n      if (e.message.indexOf(\"No Services matching UUID\") > -1) {\r\n        const result = await this.getServiceProcess(uuids[1], server);\r\n        return result;\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param btDevice \r\n   * @param protocolStartCallback \r\n   */\r\n  connect = async (btDevice: BluetoothDevice, protocolStartCallback: () => void): Promise<boolean> => {\r\n    if (this._state !== DEVICE_STATE.disconnected)\r\n      return false;\r\n\r\n    this.connected = false;\r\n    this.inConnecting = true;\r\n\r\n    let server: BluetoothRemoteGATTServer = null;\r\n    this.btServer = server;\r\n\r\n    try {\r\n      console.log(\"1. Connecting to GATT Server...\");\r\n      btDevice.addEventListener(\"gattserverdisconnected\", this.onDeviceDisconnected);\r\n      server = await btDevice.gatt.connect();\r\n    }\r\n    catch (e) {\r\n      const isBTdevice = e.message.indexOf(\"adapter\");\r\n      if (isBTdevice > -1) console.log(\"Bluetooth LE dongle is not found\");\r\n\r\n      console.error(e);\r\n      return false;\r\n    }\r\n\r\n    console.log(`2. get Service and Sockets, connected:${server.connected}`);\r\n\r\n    try {\r\n      const { writeSocket, notifyIndicate } = await this.getService(server);\r\n\r\n      console.log(\"3. Add Event listeners\");\r\n      notifyIndicate.addEventListener(\"characteristicvaluechanged\", this.onPenPacketReceived);\r\n      await notifyIndicate.startNotifications();\r\n\r\n      this.btDevice = btDevice;\r\n      this._btWriteSocket = writeSocket;\r\n      this._btNotifyIndicate = notifyIndicate;\r\n      console.log(\"BLE Connected...\");\r\n\r\n      this.connected = true;\r\n      this.inConnecting = false;\r\n\r\n\r\n    }\r\n    catch (e) {\r\n      const isBTdevice = e.message.indexOf(\"adapter\");\r\n      if (isBTdevice > -1) console.log(\"Bluetooth LE dongle is not found\");\r\n      console.error(e);\r\n      return false;\r\n    }\r\n\r\n    protocolStartCallback();\r\n    // this.protocolHandler.onPhysicallyConnected();\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * disconnect function:\r\n   */\r\n  disconnect = () => {\r\n    console.log(`     DISCONNECT operation`);\r\n    this.inDisconnecting = true;\r\n    const self = this;\r\n    if (!self.connected || self.btDevice === null) {\r\n      return;\r\n    }\r\n\r\n    if (self.btDevice !== null) {\r\n      self.btDevice.gatt.disconnect();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  preDisconnected = () => {\r\n    throw new Error(\"Not implemented: preDisconnected\");\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  onDeviceDisconnected = () => {\r\n    this.inDisconnecting = false;\r\n    this.btDevice = null;\r\n    this.btServer = null;\r\n\r\n    this._btWriteSocket = null;\r\n    this._btNotifyIndicate = null;\r\n\r\n    this._bt_buffer = new Uint8Array(0);\r\n\r\n    // 상위로 전달\r\n    const handler = this.protocolHandler;\r\n    if (handler) handler.onDisconnected();\r\n    // this.protocolHandler = null;\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param buf \r\n   */\r\n  write = (buf: Uint8Array): Promise<void> => {\r\n    return this._btWriteSocket.writeValue(buf);\r\n  }\r\n\r\n\r\n  /**\r\n   * PEN PACKET PROCESSOR\r\n   * \r\n   * process raw packets from pen\r\n   * slice packets in to a unit packet\r\n   * process the unit packet command code\r\n   * @param event \r\n   */\r\n  onPenPacketReceived = (event: any) => {\r\n    // console.log(\"    handle Data\");\r\n    const self = this;\r\n\r\n    const value = event.target.value;\r\n    const data_length = event.target.value.byteLength;\r\n\r\n    // 이전에 있던 buf에 concatenate\r\n    const prev_buf = self._bt_buffer;\r\n    const prev_len = prev_buf.length;\r\n    let buffer = new Uint8Array(prev_buf.length + data_length);\r\n\r\n    // https://stackoverflow.com/questions/14071463/how-can-i-merge-typedarrays-in-javascript\r\n    buffer.set(prev_buf);\r\n    for (let i = 0; i < value.byteLength; i++) {\r\n      buffer[prev_len + i] = value.getUint8(i);\r\n    }\r\n\r\n    let start = buffer.indexOf(PEN_PACKET_START);\r\n    let end = buffer.indexOf(PEN_PACKET_END);\r\n\r\n    // let idx = 0;\r\n    // let cnt = 0;\r\n\r\n    // console.log(\"packet length: \" + data_length);\r\n    while (start !== -1 && end !== -1) {\r\n      // console.log(\"   [\" + cnt + \"]  packet found: (\" + (idx + start) + \", \" + (idx + end) + \")\");\r\n\r\n      // buffer 잘라 주기\r\n      const curCmdPacket = buffer.slice(start, end + 1);\r\n      // idx += end;\r\n\r\n      // escape code 처리\r\n      const unescapedBuf = unescapePacket(curCmdPacket);\r\n\r\n      // packet 처리\r\n      if (unescapedBuf[0] === PEN_PACKET_START) {\r\n        // pen command 처리\r\n        this.protocolHandler.processUnitPacket(unescapedBuf);\r\n      } else {\r\n        // 위의 slice 처리가 이상하든지 메모리가 깨졌다.\r\n      }\r\n\r\n      // buffer 정리\r\n      // cnt++;\r\n      buffer = buffer.slice(end + 1);\r\n      start = buffer.indexOf(PEN_PACKET_START);\r\n      end = buffer.indexOf(PEN_PACKET_END);\r\n    }\r\n\r\n    self._bt_buffer = buffer;\r\n  }\r\n}\r\n\r\nexport class ProtocolHandlerBase {\r\n  onPhysicallyConnected() {\r\n    throw new Error(\"Not implemented: processUnitPacket\");\r\n\r\n  }\r\n  onDisconnected() {\r\n    throw new Error(\"Not implemented: processUnitPacket\");\r\n  }\r\n  processUnitPacket(buf) {\r\n    throw new Error(\"Not implemented: processUnitPacket\");\r\n  }\r\n}\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\UtilFunc.ts",["568"],"export function compareObject(curr: Object, next: Object, header: string = \"\") {\r\n  for (const [key, value] of Object.entries(next)) {\r\n    if (curr[key] !== value) {\r\n      console.log(`[${header}] state[${key}] was changed, from \"${curr[key]} to \"${value}\"`);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nexport function uuidv4(): string {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    // let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n    const r = Math.random() * 16 | 0, v = c === 'x' ? r : ((r & 0x3) | 0x8);\r\n    return v.toString(16);\r\n  });\r\n}\r\n\r\n\r\nexport function getDocumentId(fingerprint: string, pagesPerSheet: number): string {\r\n  return fingerprint + \"/\" + pagesPerSheet.toString();\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceSplitter.ts",["569"],"\r\nimport { IRectDpi, ISize } from \"../DataStructure/Structures\";\r\nimport { IPrintOption, MediaSize } from \"../NcodePrint/PrintDataTypes\";\r\nimport { IAreasDesc } from \"./NcodeRasterizer\";\r\nimport { getSurfaceSize_px_600dpi } from \"./SurfaceInfo\";\r\n// import { isPortrait } from \"./SurfaceInfo\";\r\nexport const PAGES_CELL_SPACING = 120; // 600dpi px, 5.08mm\r\n\r\n// http://www.javascripter.net/math/primes/factorization.htm\r\nfunction factor(n: number) {\r\n  if (isNaN(n) || !isFinite(n) || n % 1 !== 0 || n === 0) return '' + n;\r\n  if (n < 0) return '-' + factor(-n);\r\n  const minFactor = leastFactor(n);\r\n  if (n === minFactor) return n;\r\n\r\n  const recursive = factor(n / minFactor);\r\n  // console.log(`[recursive] ${typeof recursive}`);\r\n\r\n  return [minFactor].concat(recursive);\r\n}\r\n\r\n// find the least factor in n by trial division\r\nfunction leastFactor(n: number) {\r\n  if (isNaN(n) || !isFinite(n)) return NaN;\r\n  if (n === 0) return 0;\r\n  if (n % 1 || n * n < 2) return 1;\r\n  if (n % 2 === 0) return 2;\r\n  if (n % 3 === 0) return 3;\r\n  if (n % 5 === 0) return 5;\r\n  const m = Math.sqrt(n);\r\n  for (let i = 7; i <= m; i += 30) {\r\n    if (n % i === 0) return i;\r\n    if (n % (i + 4) === 0) return i + 4;\r\n    if (n % (i + 6) === 0) return i + 6;\r\n    if (n % (i + 10) === 0) return i + 10;\r\n    if (n % (i + 12) === 0) return i + 12;\r\n    if (n % (i + 16) === 0) return i + 16;\r\n    if (n % (i + 22) === 0) return i + 22;\r\n    if (n % (i + 24) === 0) return i + 24;\r\n  }\r\n  return n;\r\n}\r\n\r\nfunction findBestCombination(factored: number[]) {\r\n  let min_left = 1, min_right = 1;\r\n\r\n  const reducer = (mul: number, curr: number) => mul * curr;\r\n\r\n  for (let i = 1; i < factored.length; i++) {\r\n    const left = factored.slice(0, i).reduce(reducer, 1);\r\n    const right = factored.slice(i, factored.length + 1).reduce(reducer, 1);\r\n\r\n    if (left > right) break;\r\n    min_left = left;\r\n    min_right = right;\r\n  }\r\n\r\n  return [min_left, min_right];\r\n}\r\n\r\nfunction findRotation(rows: number, cols: number, srcDirection: string): number {\r\n  const srcSize = getSurfaceSize_px_600dpi(MediaSize.A4, srcDirection === \"landscape\");\r\n  let rotation = 0;\r\n\r\n  const cellSize = {\r\n    width: srcSize.width / cols,\r\n    height: srcSize.height / rows,\r\n  };\r\n\r\n  let cellSize_90 = {\r\n    width: srcSize.height / cols,\r\n    height: srcSize.width / rows,\r\n  };\r\n\r\n  if (srcDirection === \"landscape\") {\r\n    cellSize_90 = {\r\n      width: srcSize.height / rows,\r\n      height: srcSize.width / cols,\r\n    };\r\n  }\r\n\r\n\r\n  const scale_x = cellSize.width / srcSize.width;\r\n  const scale_y = cellSize.height / srcSize.width;\r\n  const scale_normal = Math.min(scale_x, scale_y);\r\n\r\n  const scale_rev_x = cellSize_90.width / srcSize.width;\r\n  const scale_rev_y = cellSize_90.height / srcSize.height;\r\n  const scale_rev = Math.min(scale_rev_x, scale_rev_y);\r\n\r\n  if (scale_rev > scale_normal) {\r\n    rotation = 90;\r\n  }\r\n\r\n  return rotation;\r\n}\r\n\r\n\r\nexport function getCellMatrixShape(numItems: number, srcDirection: string): { rows: number, cols: number, rotation: number } {\r\n  const factored = [1].concat(factor(numItems));\r\n  let [rows, cols] = findBestCombination(factored);\r\n\r\n  let rotation = findRotation(rows, cols, srcDirection);\r\n\r\n  /**\r\n   * 정수 제곱 개의 cell을 가지는 경우에는 90도 돌려서 출력할 필요 없음\r\n   */\r\n  if (numItems === 1) { rows = 1; cols = 1; rotation = 0; }\r\n  else if (numItems === 4) { rows = 2; cols = 2; rotation = 0; }\r\n  else if (numItems === 9) { rows = 3; cols = 3; rotation = 0; }\r\n  else if (numItems === 16) { rows = 4; cols = 4; rotation = 0; }\r\n  else if (numItems === 25) { rows = 5; cols = 5; rotation = 0; }\r\n  /**\r\n   * 아래의 면분할 숫자들은, 각 cell을 출력할 때 90도 돌려서 출력\r\n   * 90도 돌려서 출력하는 것은 ctx.rotate를 쓰도록 한다.\r\n   *    ctx.save();\r\n   *    ctx.translate(canvas.width, 0);\r\n   *    ctx.rotate( -90 * Math.PI/180);\r\n   *    ... drawing operation ...\r\n   *    ctx.restore();\r\n   *\r\n   * rows, cols는 90도 돌아갔다고 가정하고 나눈 면을 뜻한다.\r\n   *\r\n   *    r=1, c=1\r\n   *    +-----+           r=1, c=2\r\n   *    |     |           +---+---+\r\n   *    |  1  |     =>    | 1 | 2 |\r\n   *    |     |           +---+---+\r\n   *    +-----+\r\n   */\r\n  else if (numItems === 2) { rows = 1; cols = 2; rotation = 90; }\r\n  else if (numItems === 8) { rows = 2; cols = 4; rotation = 90; }\r\n  else if (numItems === 18) { rows = 3; cols = 6; rotation = 90; }\r\n  else if (numItems === 32) { rows = 4; cols = 8; rotation = 90; }\r\n\r\n  // else if (numItems === 3) { rows = 1; cols = 3; rotation = 90; }\r\n\r\n  return { rows, cols, rotation };\r\n}\r\n\r\nexport function devideSurfaceAreaTo(printOptions: IPrintOption, szSrc: ISize, numItems: number)\r\n  : IAreasDesc {\r\n  const cellSpace = PAGES_CELL_SPACING;\r\n\r\n  let { rows, cols, rotation } = getCellMatrixShape(numItems, printOptions.direction);\r\n\r\n  // if (rotation === 90) {\r\n  //   const { width, height } = szSrc;\r\n  //   szSrc = { width: height, height: width };\r\n  // }\r\n\r\n  // sheet가 landscape이면 면을 나누는 row, col을 바꾼다.\r\n  if (printOptions.direction === \"landscape\") {\r\n    const temp = rows;\r\n    rows = cols;\r\n    cols = temp;\r\n  }\r\n\r\n  const rcSrc = { x: 0, y: 0, ...szSrc };\r\n  const areas: IRectDpi[] = devideSurfaceAreaToMxN(rcSrc, rows, cols, cellSpace);\r\n  return { rotation, areas };\r\n}\r\n\r\n\r\n\r\nfunction devideSurfaceAreaToMxN(rcSrc: IRectDpi, rows: number, cols: number, cellSpace: number): IRectDpi[] {\r\n  const retAreas = [];\r\n  const areas = devideVertical(rcSrc, rows, cellSpace);\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    const cells = devideHorizontal(areas[row], cols, cellSpace);\r\n    retAreas.push(...cells);\r\n  }\r\n\r\n  return retAreas;\r\n}\r\n\r\n\r\n/**\r\n * 영역 세로로 나누기 ( cellSpace 만큼 띄우고)\r\n */\r\nfunction devideVertical(rcSrc: IRectDpi, numItems: number, cellSpace: number): IRectDpi[] {\r\n  const areas: IRectDpi[] = new Array(0);\r\n\r\n  const width = rcSrc.width;\r\n  const height = (rcSrc.height - cellSpace * (numItems - 1)) / numItems;\r\n\r\n  const x = rcSrc.x\r\n  let y = rcSrc.y\r\n  for (let i = 0; i < numItems; i++) {\r\n    const rc = {\r\n      x: Math.floor(x),\r\n      y: Math.floor(y),\r\n      width: Math.floor(width),\r\n      height: Math.floor(height),\r\n    };\r\n    areas.push(rc);\r\n    y += height + cellSpace;\r\n  }\r\n\r\n  return areas;\r\n}\r\n\r\n\r\n\r\n/**\r\n * 영역 가로로 나누기 ( cellSpace 만큼 띄우고)\r\n */\r\nfunction devideHorizontal(rcSrc: IRectDpi, numItems: number, cellSpace: number): IRectDpi[] {\r\n  const areas: IRectDpi[] = new Array(0);\r\n\r\n  const width = (rcSrc.width - cellSpace * (numItems - 1)) / numItems;\r\n  const height = rcSrc.height;\r\n\r\n  let x = rcSrc.x\r\n  const y = rcSrc.y\r\n  for (let i = 0; i < numItems; i++) {\r\n    const rc = {\r\n      x: Math.floor(x),\r\n      y: Math.floor(y),\r\n      width: Math.floor(width),\r\n      height: Math.floor(height),\r\n    };\r\n    areas.push(rc);\r\n    x += width + cellSpace;\r\n  }\r\n\r\n  return areas;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PagesForPrint.tsx",["570","571","572","573","574"],"import React from \"react\";\r\n\r\nimport { PageForPrint } from \"./PageForPrint\";\r\nimport \"./print.css\";\r\n\r\nimport { ISize } from \"../DataStructure/Structures\";\r\nimport { IPrintOption } from \"./PrintDataTypes\";\r\nimport NeoPdfDocument from \"../NeoPdf/NeoPdfDocument\";\r\nimport { PDF_VIEWPORT_DESC } from \"../NeoPdf/NeoPdfPage\";\r\n\r\ninterface Props { // tslint:disable-line interface-over-type-literal\r\n  text: string,\r\n  pdf: NeoPdfDocument,\r\n  shouldRenderPage: boolean,\r\n  /** null이면 화면 전용 */\r\n  OnPagePrepared: Function,\r\n\r\n  printOption: IPrintOption,\r\n\r\n  pagesOverview: IPageOverview[],\r\n\r\n};\r\n\r\ntype State = {\r\n  renderState: string,\r\n};\r\n\r\nexport type IPageOverview = {\r\n  rotation: number,\r\n\r\n  /** pdf의 viewport가 rotation 0일 때의 크기로 판단(rotation은 고려하지 않음) */\r\n  landscape: boolean,\r\n\r\n  /** pdf의 viewport의 rotation은 고려하지 않음, 각 페이지에서 rotation된 것으로 rendering */\r\n  sizePu: ISize,\r\n}\r\n\r\nexport class PagesForPrint extends React.Component<Props, State> {\r\n\r\n  printOption: IPrintOption = null;\r\n\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    this.printOption = this.props.printOption;\r\n    this.state = {\r\n      renderState: \"rendering\",\r\n    };\r\n    // console.time('Function #1');\r\n  }\r\n\r\n  setPageOverview_old = async (pdf) => {\r\n    this.setState({\r\n      renderState: \"ready\",\r\n    });\r\n  }\r\n\r\n  componentDidMount() {\r\n    if (this.props.pdf) {\r\n      this.setPageOverview_old(this.props.pdf);\r\n    }\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n\r\n    if (this.state.renderState !== \"ready\" && nextState.renderState === \"ready\") {\r\n      return true;\r\n    }\r\n\r\n    if (this.props.pdf !== nextProps.pdf) {\r\n      console.log(`[yyy] setPageOverview_old called`);\r\n      this.setPageOverview_old(nextProps.pdf);\r\n      return true;\r\n    }\r\n\r\n\r\n    return false;\r\n  }\r\n\r\n  componentDidUpdate(nextProps, nextState) {\r\n    // console.log(\"[xxx] PagesForPrint componentDidUpdate\");\r\n  }\r\n\r\n  public render() {\r\n    const { renderState } = this.state;\r\n    const { pdf, OnPagePrepared, pagesOverview } = this.props;\r\n\r\n    const printOption = this.printOption;\r\n    const { pagesPerSheet, targetPages, } = printOption;\r\n\r\n    const numPages = targetPages.length;\r\n    const numSheets = Math.ceil(numPages / pagesPerSheet);\r\n    const pageNumsInSheet: number[][] = new Array(numSheets);\r\n\r\n\r\n    for (let i = 0; i < numSheets; i++) {\r\n      pageNumsInSheet[i] = new Array(0);\r\n\r\n      for (let j = 0; j < pagesPerSheet && (i * pagesPerSheet + j) < numPages; j++) {\r\n        const pageNo = targetPages[i * pagesPerSheet + j];\r\n        pageNumsInSheet[i].push(pageNo);\r\n      }\r\n    }\r\n\r\n\r\n    return (\r\n      // <div className=\"relativeCSS\">\r\n      <div>\r\n        {renderState === \"ready\" ? pageNumsInSheet.map(\r\n          (v, i) => {\r\n            // console.log(`Page displaying ${i}`);\r\n            return (\r\n              <div key={`page-div-${pdf.fingerprint}-${i}`}>\r\n                <PageForPrint\r\n                  pdf={pdf}\r\n                  key={`page-${pdf.fingerprint}-${i}`}\r\n                  sheetIndex={i}\r\n                  name={`page-${pdf.fingerprint}-${i}`}\r\n                  OnPagePrepared={OnPagePrepared}\r\n                  printOption={printOption}\r\n                  pageNums={pageNumsInSheet[i]}\r\n                  pagesOverview={pagesOverview}\r\n                />\r\n              </div>\r\n            )\r\n          }\r\n        ) : <></>}\r\n      </div>\r\n    );\r\n  }\r\n\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageOrientation.jsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingItem.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingStorage.ts",["575","576","577"],"import { CoordinateTanslater, IMappingParams } from \"../Coordinates\";\r\nimport { INcodeSOBPxy } from \"../DataStructure/Structures\";\r\nimport { isSamePage } from \"../NcodeSurface\";\r\n\r\nlet _instance: MappingStorage = null;\r\nconst LOCAL_STORAGE_ID = \"GridaBoard_codeMappingInfo_v2\";\r\n\r\nexport default class MappingStorage {\r\n  _arrMapped: IMappingParams[] = [];\r\n\r\n  private constructor() {\r\n    if (_instance) return _instance;\r\n  }\r\n\r\n  static getInstance() {\r\n    if (_instance) return _instance;\r\n\r\n    _instance = new MappingStorage();\r\n    return _instance;\r\n  }\r\n\r\n  register = (item: CoordinateTanslater) => {\r\n    const params = item.mappingParams;\r\n\r\n    const now = new Date();\r\n    const timeStr =\r\n      `${addZeros(now.getFullYear(), 2)}/` +\r\n      `${addZeros(now.getMonth() + 1, 2)}/` +\r\n      `${addZeros(now.getDate(), 2)} ` +\r\n      `${addZeros(now.getHours(), 2)}:` +\r\n      `${addZeros(now.getMinutes(), 2)}:` +\r\n      `${addZeros(now.getSeconds(), 2)}.` +\r\n      `${addZeros(now.getMilliseconds(), 4)}`;\r\n\r\n    params.timeString = timeStr; // JSON.stringify(new Date());\r\n    this._arrMapped.push(params);\r\n  }\r\n\r\n  /**\r\n   * pen down시에 새로운 SOBP라면, 관련된 PDF가 있는지 찾을 때 쓰인다\r\n   */\r\n  findPdfPage = (ncodeXy: INcodeSOBPxy) => {\r\n    // const pdfPageInfo: IPdfPageDesc = null;\r\n    // const pdfDocInfo: IPdfDocDesc = null;\r\n\r\n    // let found = -1;\r\n    // for ( let i=0; i<this._arrMapped.length; i++ ) {\r\n    //   const trans = this._arrMapped[i];\r\n    //   if ( isSamePage(ncodeXy as IPageSOBP, trans.pageInfo) ) {\r\n    //     found = i;\r\n    //     break;\r\n    //   }\r\n    // }\r\n\r\n\r\n    /** 원래는 폴리곤에 속했는지 점검해야 하지만, 현재는 같은 페이지인지만 점검한다  2020/12/06 */\r\n    const found = this._arrMapped.find(trans => isSamePage(ncodeXy, trans.pageInfo));\r\n    return found;\r\n  }\r\n\r\n  /**\r\n   * Ncode가 발행된 적이 있는지를 점검하기 위해서 쓰인다.\r\n   */\r\n  findMappedNcode = (pdfId: string) => {\r\n    const found = this._arrMapped.find(trans => pdfId === trans.pdfDesc.id);\r\n    return found;\r\n  }\r\n\r\n  dump = (prefix: string) => {\r\n    console.log(`[${prefix}]----------------------------------------------------------------------`);\r\n    const str = JSON.stringify(this._arrMapped, null, \"  \");\r\n    const arr = str.split(\"\\n\");\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n      console.log(`[${prefix}] ${arr[i]}`);\r\n    }\r\n    console.log(`[${prefix}]----------------------------------------------------------------------`);\r\n  }\r\n\r\n\r\n\r\n  storeMappingInfo = () => {\r\n    if (storageAvailable(\"localStorage\")) {\r\n      const key = LOCAL_STORAGE_ID;\r\n      const value = JSON.stringify(this._arrMapped);\r\n      // console.log(`Pdf Ncode Info Saved   ${key}: ${value}`);\r\n      localStorage.setItem(key, value);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * app이 기동되면 반드시 처음에 load하자\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  loadMappingInfo = () => {\r\n    if (storageAvailable(\"localStorage\")) {\r\n      const key = LOCAL_STORAGE_ID;\r\n      const value = localStorage.getItem(key);\r\n\r\n      if (value) {\r\n        this._arrMapped = JSON.parse(value);\r\n\r\n        this._arrMapped.sort(function (a, b) {\r\n          if (a.timeString < b.timeString) return 1;\r\n          else if (a.timeString > b.timeString) return -1;\r\n          else return 0;\r\n        });\r\n\r\n        // const debug = JSON.stringify(this._arrMapped);\r\n        // console.log(`Pdf Ncode Info Loaded   ${key}: ${debug}`);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\nfunction storageAvailable(type) {\r\n  let storage;\r\n  try {\r\n    storage = window[type];\r\n    const x = \"__storage_test__\";\r\n    storage.setItem(x, x);\r\n    storage.removeItem(x);\r\n    return true;\r\n  } catch (e) {\r\n    return (\r\n      e instanceof DOMException &&\r\n      // Firefox를 제외한 모든 브라우저\r\n      (e.code === 22 ||\r\n        // Firefox\r\n        e.code === 1014 ||\r\n        // 코드가 존재하지 않을 수도 있기 떄문에 이름 필드도 확인합니다.\r\n        // Firefox를 제외한 모든 브라우저\r\n        e.name === \"QuotaExceededError\" ||\r\n        // Firefox\r\n        e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\r\n      // 이미 저장된 것이있는 경우에만 QuotaExceededError를 확인하십시오.\r\n      storage &&\r\n      storage.length !== 0\r\n    );\r\n  }\r\n}\r\n\r\n\r\nfunction addZeros(num, digit) {\r\n  // 자릿수 맞춰주기\r\n  let zero = \"\";\r\n  num = num.toString();\r\n  if (num.length < digit) {\r\n    for (let i = 0; i < digit - num.length; i++) {\r\n      zero += \"0\";\r\n    }\r\n  }\r\n  return zero + num;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfPage.ts",["578"],"import * as PdfJs from \"pdfjs-dist\";\r\nimport { CoordinateTanslater, IPdfPageDesc } from \"../Coordinates\";\r\nimport { IRectDpi,  } from \"../DataStructure/Structures\";\r\nimport { uuidv4 } from \"../NcodePrint\";\r\nimport { CanvasColorConverter } from \"../NcodeSurface\";\r\nimport { ColorConvertMethod } from \"../NcodeSurface/CanvasColorConverter\";\r\nimport { PDF_DEFAULT_DPI } from \"../NcodeSurface/NcodeConstans\";\r\nimport NeoPdfDocument from \"./NeoPdfDocument\";\r\nexport type PDF_VIEWPORT_DESC = PdfJs.ViewportParameters & PdfJs.PDFPageViewport;\r\n\r\n\r\n\r\nexport interface IPdfPageCanvasDesc {\r\n  pdfPageInfo: IPdfPageDesc,\r\n\r\n  /** splitted canvas 내의 index */\r\n  index: number,\r\n\r\n  /** 그려진 canvas */\r\n  canvas: HTMLCanvasElement,\r\n  rotation: number,\r\n\r\n\r\n  width_pu: number,\r\n  height_pu: number,\r\n\r\n  drawnRect: IRectDpi,\r\n}\r\n\r\n\r\nexport default class NeoPdfPage {\r\n  _pdfPage: PdfJs.PDFPageProxy;\r\n\r\n  _ready: PdfJs.PDFPromise<PdfJs.PDFPageProxy>;\r\n\r\n  _loaded: boolean = false;\r\n\r\n  private _defaultViewport: PDF_VIEWPORT_DESC;\r\n\r\n  _pageNo: number;\r\n\r\n  _doc: NeoPdfDocument;\r\n\r\n  _translater: CoordinateTanslater;\r\n\r\n  constructor(neoPdf: NeoPdfDocument, pageNo: number) {\r\n    this._pageNo = pageNo;\r\n    this._doc = neoPdf;\r\n\r\n\r\n    this._ready = neoPdf._pdfDoc.getPage(pageNo);\r\n    this._ready.then(_pdfPage => {\r\n      this._pdfPage = _pdfPage;\r\n      this._loaded = true;\r\n      this._defaultViewport = _pdfPage.getViewport({ scale: 1 });\r\n    });\r\n  }\r\n\r\n  getPage = async () => {\r\n    await this._ready;\r\n    return this._pdfPage;\r\n  }\r\n\r\n  render = async (params: PdfJs.PDFRenderParams) => {\r\n    await this._ready;\r\n    const renderTask: PdfJs.PDFRenderTask = this._pdfPage.render(params);\r\n    const ret = await renderTask.promise;\r\n    return ret;\r\n  }\r\n\r\n  public get viewport(): PDF_VIEWPORT_DESC {\r\n    return this._defaultViewport;\r\n  }\r\n\r\n  getViewport = (params: PdfJs.ViewportParameters): PDF_VIEWPORT_DESC => {\r\n    return this._pdfPage.getViewport(params);\r\n  }\r\n\r\n\r\n  setTranslater = (translater: CoordinateTanslater) => {\r\n    this._translater = translater;\r\n  }\r\n\r\n\r\n  public render_dpi = async (index: number, dpi: number)\r\n    : Promise<IPdfPageCanvasDesc> => {\r\n\r\n    await this._ready;\r\n\r\n    const pageNo = this._pageNo;\r\n    const scratchCanvas = document.createElement(\"canvas\");\r\n    const canvas = scratchCanvas;\r\n    const uuid = uuidv4();\r\n    canvas.id = `scratchCanvas-${pageNo}-${uuid}`;\r\n\r\n    const page = this._pdfPage;\r\n\r\n    const viewport: PDF_VIEWPORT_DESC = this.viewport;\r\n    const rotation = viewport.rotation;\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    const PRINT_RESOLUTION = dpi;\r\n    const PRINT_UNITS = PRINT_RESOLUTION / PDF_DEFAULT_DPI;\r\n    // const CSS_UNITS = 96.0 / PDF_DEFAULT_DPI;\r\n\r\n    canvas.width = Math.floor(viewport.width * PRINT_UNITS);\r\n    canvas.height = Math.floor(viewport.height * PRINT_UNITS);\r\n\r\n    // const cssWidth = Math.floor(viewport.width * CSS_UNITS);\r\n    // const cssHeight = Math.floor(viewport.height * CSS_UNITS);\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgb(255, 255, 255)\";\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    ctx.restore();\r\n\r\n\r\n    // return Promise.resolve({ index, canvas, rotation, pageNo });\r\n\r\n    const renderContext = {\r\n      canvasContext: ctx,\r\n      transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],\r\n      viewport: page.getViewport({\r\n        scale: 1,\r\n        rotation: viewport.rotation\r\n      }),\r\n      intent: \"print\"\r\n    };\r\n\r\n\r\n    const renderTask = page.render(renderContext);\r\n    await renderTask.promise;\r\n\r\n    const doc = this._doc;\r\n    const result: IPdfPageCanvasDesc = {\r\n      pdfPageInfo: {\r\n        url: doc.url,\r\n        fingerprint: doc.fingerprint,\r\n        numPages: doc.numPages,\r\n        pageNo: this._pageNo,\r\n      },\r\n\r\n      index,\r\n      canvas,\r\n      rotation,\r\n\r\n      width_pu: viewport.width,\r\n      height_pu: viewport.height,\r\n      drawnRect: {\r\n        unit: \"600dpi\",\r\n        x: 0, y: 0, width: 0, height: 0,\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public convertColor = async (canvasDesc: IPdfPageCanvasDesc, colorConvertMode?: ColorConvertMethod) => {\r\n    if (colorConvertMode) {\r\n      const pdfCanvas = canvasDesc.canvas;\r\n      const converter = new CanvasColorConverter(pdfCanvas);\r\n      await converter.convert(colorConvertMode);\r\n    }\r\n\r\n    return canvasDesc;\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\DataStructure\\Structures.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceInfo.ts",["579","580","581","582","583","584","585"],"import { paperType } from \"./NcodeSurfaceDataJson\";\r\nimport { INcodeSurfaceDesc, IPaperSize } from \"./SurfaceDataTypes\";\r\n\r\nimport { IPageSOBP, INcodeSOBPxy, ISize, UNIT_TO_DPI } from \"../DataStructure/Structures\";\r\nimport { INCH_TO_MM_SCALE, NCODE_TO_INCH_SCALE, PDF_DEFAULT_DPI } from \"./NcodeConstans\";\r\n\r\n\r\n/**\r\n *\r\n * @param pageInfo\r\n */\r\nexport function isPlatePaper(pageInfo: IPageSOBP): boolean {\r\n  const { owner, book } = pageInfo;\r\n  if (owner === 1013 && book === 2) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param coordInfo\r\n */\r\nexport function isPUI(pageInfo: INcodeSOBPxy): boolean {\r\n  const { owner, book, page, } = pageInfo;\r\n  // console.log( `isPUI: ${owner}.${book}.${page}`);\r\n  if (owner === 27 && book === 161 && page === 1) {\r\n    return true;\r\n  }\r\n\r\n  if (owner === 1013 && book === 1) {\r\n    // page === 4, Smart plate\r\n    // page === 1, Plate paper\r\n\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param pageInfo\r\n * @return paper size in NU\r\n */\r\nfunction getNPaperSize_nu(item: IPageSOBP | INcodeSurfaceDesc): ISize {\r\n  let desc = item as INcodeSurfaceDesc;\r\n\r\n  if (!item.hasOwnProperty(\"margin\")) {\r\n    const pageInfo = item as IPageSOBP;\r\n    desc = getNPaperInfo(pageInfo);\r\n  }\r\n  const margin = desc.margin;\r\n  return {\r\n    width: margin.Xmax - margin.Xmin,\r\n    height: margin.Ymax - margin.Ymin\r\n  };\r\n}\r\n\r\n\r\nfunction getNPaperSize_dpi(item: IPageSOBP | INcodeSurfaceDesc, dpi: number): ISize {\r\n  // const { section, owner, book, page } = pageInfo;\r\n  const size = getNPaperSize_nu(item);\r\n\r\n  return {\r\n    width: size.width * NCODE_TO_INCH_SCALE * dpi,\r\n    height: size.height * NCODE_TO_INCH_SCALE * dpi,\r\n  }\r\n}\r\n\r\nexport function getNPaperSize_pu(item: IPageSOBP | INcodeSurfaceDesc): ISize {\r\n  return getNPaperSize_dpi(item, PDF_DEFAULT_DPI);\r\n}\r\n\r\n\r\nexport function getMediaSize_pu(mediaType: IPaperSize): ISize {\r\n  const { width, height } = mediaType;\r\n\r\n  return {\r\n    width: width * INCH_TO_MM_SCALE * PDF_DEFAULT_DPI,\r\n    height: height * INCH_TO_MM_SCALE * PDF_DEFAULT_DPI,\r\n  }\r\n}\r\n\r\n/**\r\n * paper size를 해당 inch 단위로 돌려 준다.\r\n * @param pageInfo\r\n */\r\nexport function getNPaperInfo(pageInfo: IPageSOBP): INcodeSurfaceDesc {\r\n  const { section, owner, book } = pageInfo;\r\n\r\n\r\n  let found = paperType.paperA4_dummy;\r\n  let found_key = \"paperA4_dummy\";\r\n\r\n  const keys = Object.keys(paperType);\r\n  for (let j = 0; j < keys.length; j++) {\r\n    const key = keys[j];\r\n    const value = paperType[key];\r\n\r\n    const idx = value.books.indexOf(book);\r\n    if (idx > -1) {\r\n      if (section === value.section && owner === value.owner) {\r\n        found = value;\r\n        found_key = key;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  const desc: INcodeSurfaceDesc = {\r\n    id: found_key,\r\n    pageInfo,\r\n    margin: {\r\n      Xmin: found.Xmin,\r\n      Xmax: found.Xmax,\r\n      Ymin: found.Ymin,\r\n      Ymax: found.Ymax,\r\n    },\r\n    glyphData: \"\",\r\n  };\r\n\r\n  return desc;\r\n}\r\n\r\n\r\n\r\nexport function getSurfaceSize_dpi(size: IPaperSize, dpi: number, isLandscape: boolean = false) {\r\n  const numerator = UNIT_TO_DPI[size.unit];\r\n  const ratio = 1.0;\r\n\r\n  let width = size.width * ratio * dpi / numerator;\r\n  let height = size.height * ratio * dpi / numerator;\r\n\r\n  width = Math.floor(width);\r\n  height = Math.floor(height);\r\n\r\n  if (isLandscape) {\r\n    return {\r\n      width: height,\r\n      height: width,\r\n    };\r\n  }\r\n\r\n  return {\r\n    width: width,\r\n    height: height,\r\n  };\r\n}\r\n\r\n\r\nexport function getSurfaceSize_px_600dpi(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"600dpi\"], isLandscape);\r\n}\r\n\r\nexport function getSurfaceSize_inch(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, 1, isLandscape);\r\n}\r\n\r\nexport function getSurfaceSize_mm(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"mm\"], isLandscape);\r\n}\r\n\r\nexport function getSurfaceSize_css(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"css\"], isLandscape);\r\n}\r\n\r\n\r\nexport function getSurfaceSize_pu(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"pu\"], isLandscape);\r\n}\r\n\r\nexport function isPortrait(size: ISize) {\r\n  return size.width < size.height;\r\n}\r\n\r\nexport function getCssDpi() {\r\n  return UNIT_TO_DPI[\"css\"];\r\n}\r\n\r\n\r\n\r\nexport function isSamePage(pg1: IPageSOBP, pg2: IPageSOBP): boolean {\r\n  if (pg1.page !== pg2.page || pg1.book !== pg2.book || pg1.owner !== pg2.owner || pg1.section !== pg2.section) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeRasterizer.tsx",["586","587","588"],"import { UNIT_TO_DPI, IPageSOBP, IPointDpi, IRectDpi, autoSetDpi, } from \"../DataStructure/Structures\";\r\n\r\nimport NcodeFetcher from \"./NcodeFetcher\";\r\nimport { INcodeSurfaceDesc, IPaperSize } from \"./SurfaceDataTypes\";\r\n\r\n// import expect from \"expect.js\";\r\nimport { getSurfaceSize_dpi } from \"./SurfaceInfo\";\r\nimport { devideSurfaceAreaTo, getCellMatrixShape } from \"./SurfaceSplitter\";\r\nimport { IPrintOption } from \"../NcodePrint/PrintDataTypes\";\r\nimport { NCODE_CLASS6_NUM_DOTS } from \"./NcodeConstans\";\r\n\r\n// import { PrintContextConsumer } from \"react-to-print\";\r\n\r\nconst debugNcode_w = 200;\r\nconst debugNcode_h = 500;\r\n\r\n\r\n\r\nexport function drawArrow(context: CanvasRenderingContext2D, fromx: number, fromy: number, tox: number, toy: number) {\r\n  const headlen = 100; // length of head in pixels\r\n  const dx = tox - fromx;\r\n  const dy = toy - fromy;\r\n  const angle = Math.atan2(dy, dx);\r\n\r\n  context.beginPath();\r\n  context.moveTo(fromx, fromy);\r\n  context.lineTo(tox, toy);\r\n  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));\r\n  context.moveTo(tox, toy);\r\n  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));\r\n  context.stroke();\r\n}\r\n\r\nconst codePos: { [key: string]: { code: number; dx: number, dy: number, } } = {\r\n  \"u\": { code: 0, dx: +1, dy: +1 },\r\n  \"d\": { code: 1, dx: -1, dy: +1 },\r\n  \"l\": { code: 2, dx: -1, dy: -1 },\r\n  \"r\": { code: 3, dx: +1, dy: -1 },\r\n  \"n\": { code: -1, dx: 0, dy: 0 },\r\n}\r\n\r\n/** (dx,dy) ~ (dw=width, dh=height) */\r\ntype IPdfPixelArea = {\r\n  dx: number,\r\n  dy: number,\r\n  dw: number,\r\n  dh: number,\r\n}\r\n\r\n\r\n\r\n/**\r\n * rotation이 90이면 회전시켜서 내용물을 그려야 한다.\r\n *\r\n * areas에 있는 값은, 회전한 다음을 가정하고 있음.\r\n *\r\n *    ctx.save();\r\n *    ctx.translate(canvas.width, 0);\r\n *    ctx.rotate( -90 * Math.PI/180);\r\n *    ... drawing operation ...\r\n *    ctx.restore(); *\r\n */\r\nexport interface IAreasDesc {\r\n  rotation: number;\r\n  areas: IRectDpi[];\r\n}\r\n\r\nexport type INcodeAreaDesc = {\r\n  success: boolean,\r\n\r\n  dpi: number,\r\n  pixelsPerDot: number,\r\n  dotsPerCell: number,\r\n\r\n  pageInfo: IPageSOBP,\r\n  rect: IRectDpi,\r\n  // x_nu: number,\r\n  // y_nu: number,\r\n  // width_nu: number,\r\n  // height_nu: number,\r\n}\r\n\r\n/**\r\n * canvasAreas.rotation이 90이면 회전시켜서 내용물을 그려야 한다.\r\n *\r\n * areas에 있는 값은, 회전한 다음을 가정하고 있음.\r\n *\r\n *    ctx.save();\r\n *    ctx.translate(canvas.width, 0);\r\n *    ctx.rotate( -90 * Math.PI/180);\r\n *    ... drawing operation ...\r\n *    ctx.restore(); *\r\n */\r\nexport type ICellsOnSheetDesc = {\r\n  canvas: HTMLCanvasElement;\r\n  canvasAreas: IAreasDesc;\r\n  ncodeAreas: INcodeAreaDesc[];\r\n}\r\n\r\nexport type ICanvasContextForCodeDraw = {\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n}\r\n\r\nexport type IPagesPerSheetNumbers = 1 | 4 | 9 | 16 | 25 | 2 | 8 | 18 | 32;\r\n/**\r\n * srcDirection은, PDF 파일 전체의 landscape/portrait를 넣어야 한다.\r\n */\r\nexport interface IPrepareSurfaceParam {\r\n  mediaSize: IPaperSize,\r\n  srcDirection: \"auto\" | \"portrait\" | \"landscape\",\r\n  dpi: number,\r\n  numItems: IPagesPerSheetNumbers\r\n  pageInfos: IPageSOBP[],\r\n\r\n  hasToPutNcode: boolean,\r\n\r\n  debugMode: 0 | 1 | 2 | 3,\r\n}\r\n\r\n/**\r\n * Class\r\n */\r\nexport default class NcodeRasterizer {\r\n\r\n  // private ncodeSurfaceDesc: INcodeSurfaceDesc = null;\r\n\r\n  private glyphDistancePx_canvas = 8;\r\n\r\n  printOption: IPrintOption;\r\n\r\n  // private rotation: number = 0;\r\n\r\n  fetcher: NcodeFetcher = null;\r\n\r\n\r\n  constructor(printOption: IPrintOption) {\r\n    this.printOption = { ...printOption };\r\n  }\r\n\r\n  private drawAreaArrow = (ctx, area) => {\r\n    const { x, y, width, height } = area;\r\n    // drawArrow(ctx, area.x, area.y, area.x + area.width, area.y + area.height);\r\n\r\n    ctx.save();\r\n    ctx.font = \"150px Arial\";\r\n\r\n    ctx.strokeStyle = \"rgba(255, 0, 255)\";     // 투명 캔버스\r\n    // ctx.fillStyle = \"rgb(255, 0, 0)\";     // 투명 캔버스\r\n    ctx.lineWidth = 10;\r\n    ctx.lineCap = \"round\";\r\n    ctx.strokeRect(area.x, area.y, area.width - ctx.lineWidth, area.height - ctx.lineWidth);\r\n\r\n    // ctx.strokeStyle = \"rgba(0, 0,0)\";     // 투명 캔버스\r\n    // drawArrow(ctx, area.x + 100, area.y, area.x + 100, area.y + area.height - 100);\r\n    // drawArrow(ctx, area.x, area.y + 100, area.x + area.width - 100, area.y + 100);\r\n\r\n    ctx.strokeStyle = \"rgb(0,0,255)\";\r\n    ctx.fillStyle = \"rgb(0,0, 255)\";\r\n    drawArrow(ctx, x + 50, y + 200, x + width - 100, y + 200);\r\n    ctx.fillText(\"x\", x + width / 2, y + 350);\r\n\r\n    ctx.strokeStyle = \"rgb(255,0,0)\";\r\n    ctx.fillStyle = \"rgb(255,0, 0)\";\r\n    drawArrow(ctx, x + 200, y + 50, x + 200, y + height - 100);\r\n    ctx.fillText(\"y\", x + 250, y + height / 2);\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * 이 함수 내부에서 쓰이는 모든 단위는 600dpi 인쇄를 기준으로 한 pixel 값\r\n   *\r\n   * @param mediaSize\r\n   * @param numItems\r\n   * @param srcDirection\r\n   */\r\n  public prepareNcodePlane = async (options: IPrepareSurfaceParam): Promise<ICellsOnSheetDesc> => {\r\n    const { mediaSize, srcDirection, numItems, pageInfos, hasToPutNcode } = options;\r\n    let dpi = options.dpi;\r\n    dpi = 600;  // kitty  2020/11/29, 코드 제네레이터는 600 dpi로 고정\r\n\r\n    // expect(pageInfos.length).to.be(numItems);\r\n\r\n    // temp canvas size를 구한다.\r\n    let isLandscape = (srcDirection === \"landscape\");\r\n    const isRotationNeeded = getCellMatrixShape(numItems, srcDirection).rotation === 90;\r\n    if (isRotationNeeded) isLandscape = !isLandscape;\r\n    const size = getSurfaceSize_dpi(mediaSize, dpi, isLandscape);\r\n    // let logicalSize = { ...size };\r\n\r\n\r\n\r\n    // sheet의 면을 cell로 나누고,\r\n    const entireRect = { x: 0, y: 0, ...size };\r\n    const canvasAreas = devideSurfaceAreaTo(this.printOption, entireRect, numItems);\r\n    const { areas } = canvasAreas;\r\n\r\n    // 캔버스를 준비\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = size.width;\r\n    canvas.height = size.height;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgba(255, 255, 255, 0)\";     // 투명 캔버스\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n\r\n    if (options.debugMode > 0) {\r\n      ctx.strokeStyle = \"rgba(0, 255, 0, 255)\";     // 외곽\r\n      ctx.lineWidth = 70;\r\n      ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    // 좌표계의 논리적 회전이 필요하면 회전, when numItems === 2 | 8 | 18 | 32\r\n    // if (canvasAreas.rotation === 90) {\r\n    //   ctx.translate(canvas.width, 0);\r\n    //   ctx.rotate(Math.PI / 2);\r\n    // }\r\n\r\n\r\n    // 출력할 페이지/시트의 실제 출력 대상의 페이지 수 보다 적을 수 있다\r\n    const ncodeAreas = [];\r\n    for (let i = 0; i < areas.length; i++) {\r\n      // 디버깅용 화살표를 그린다. debug mode 1이상\r\n      const drawingContext: ICanvasContextForCodeDraw = { ctx, ...areas[i], };\r\n      const area = areas[i];\r\n      if (this.printOption.debugMode > 0) {\r\n        this.drawAreaArrow(ctx, area);\r\n      }\r\n\r\n      // Calibration 십자가를 그린다.\r\n      if (numItems === 1) {\r\n        this.drawCrossMark(drawingContext, null);\r\n      }\r\n\r\n      // 코드를 그린다\r\n      if (hasToPutNcode && i < pageInfos.length) {\r\n        const pageInfo = pageInfos[i];\r\n        const fetcher = new NcodeFetcher(pageInfo);\r\n        const ncodeSurfaceDesc = await fetcher.getNcodeData(pageInfos[i]);\r\n\r\n        // (left, top) margin을 세팅\r\n        if (this.printOption.marginLeft_nu === -1) {\r\n          this.printOption.marginLeft_nu = ncodeSurfaceDesc.margin.Xmin;\r\n        }\r\n\r\n        if (this.printOption.marginTop_nu === -1) {\r\n          this.printOption.marginTop_nu = ncodeSurfaceDesc.margin.Ymin;\r\n        }\r\n        // 코드를 그린다\r\n\r\n        // ctx.strokeStyle = \"rgba(0, 255, 0, 255)\";     // 투명 캔버스\r\n        // ctx.lineWidth = 70;\r\n        // ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n        const ncodeArea = await this.drawNcode(drawingContext, ncodeSurfaceDesc, dpi);\r\n        ncodeAreas.push(ncodeArea);\r\n\r\n      }\r\n    }\r\n    ctx.restore();\r\n\r\n    const result: ICellsOnSheetDesc = {\r\n      canvas,\r\n      canvasAreas,\r\n      ncodeAreas,\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public putCode = async (context: ICanvasContextForCodeDraw, pageInfo: IPageSOBP, srcMapped: IPdfPixelArea): Promise<any> => {\r\n    // return new Promise( (resolve) => resolve() );   // kitty\r\n    // this.rotation = rotation;\r\n\r\n    // 코드 정보를 받아온다\r\n    // 코드 정보를 받아올 때 나중에는 x margin, y margin도 서버에서 받아오게 해야 한다\r\n    this.fetcher = new NcodeFetcher(pageInfo);\r\n    const ncodeSurfaceDesc = await this.fetcher.getNcodeData(pageInfo);\r\n    // this.ncodeSurfaceDesc = result;\r\n\r\n    // (left, top) margin을 세팅\r\n    if (this.printOption.marginLeft_nu === -1) {\r\n      this.printOption.marginLeft_nu = ncodeSurfaceDesc.margin.Xmin;\r\n    }\r\n\r\n    if (this.printOption.marginTop_nu === -1) {\r\n      this.printOption.marginTop_nu = ncodeSurfaceDesc.margin.Ymin;\r\n    }\r\n\r\n    // 코드를 그린다\r\n    await this.drawNcode(context, ncodeSurfaceDesc, 600);\r\n  }\r\n\r\n  private drawSingleCrossMark = (context: ICanvasContextForCodeDraw, x: number, y: number) => {\r\n    const ctx = context.ctx;\r\n    const line_width = 5;\r\n    const line_len = 100;\r\n\r\n\r\n    ctx.strokeStyle = \"rgb(255, 0, 0)\";\r\n    ctx.save();\r\n\r\n    ctx.beginPath();\r\n    ctx.lineWidth = line_width;\r\n    // 2020/08/31 kitty\r\n    // canvas_context.arc(x, y, r, r, 0, Math.PI * 2, true); // Outer circle\r\n    ctx.moveTo(x, y - line_len);\r\n    ctx.lineTo(x, y + line_len);\r\n    ctx.moveTo(x - line_len, y);\r\n    ctx.lineTo(x + line_len, y);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawCrossMark = (context: ICanvasContextForCodeDraw, srcMapped: IPdfPixelArea = null) => {\r\n\r\n    // 이전 버전과 호환성을 위해\r\n    if (srcMapped === null) {\r\n      srcMapped = { dx: 0, dy: 0, dw: context.width, dh: context.height };\r\n    }\r\n\r\n    const ratio = 0.1;\r\n    const d = srcMapped.dw * ratio;\r\n    const x0 = srcMapped.dx + d;\r\n    const y0 = srcMapped.dy + d;\r\n    const x1 = srcMapped.dx + srcMapped.dw - d;\r\n    const y1 = srcMapped.dy + srcMapped.dh - d;\r\n\r\n    this.drawSingleCrossMark(context, x0, y0);\r\n    // this.drawSingleCrossMark(canvas, x0, y1);\r\n    this.drawSingleCrossMark(context, x1, y1);\r\n    // this.drawSingleCrossMark(canvas, x1, y0);\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param context\r\n   * @param code_txt\r\n   * @param y\r\n   * @param fullOfGlyphs - for debugging\r\n   */\r\n  private drawNcodeSingleLine = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs= true): Promise<void> => {\r\n    // if (this.printOption.codeDensity > 2) {\r\n    //   return this.drawNcodeSingleLine_BOLD(context, code_txt, y, fullOfGlyphs);\r\n    // }\r\n    // else {\r\n    //   return this.drawNcodeSingleLine_NORMAL(context, code_txt, y, fullOfGlyphs);\r\n    // }\r\n\r\n    return this.drawNcodeSingleLine_DOT(context, code_txt, y, width, fullOfGlyphs);\r\n  }\r\n\r\n  private drawNcodeSingleLine_DOT = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs = true): Promise<void> => {\r\n    const { ctx, x: baseX, y: baseY } = context;\r\n\r\n    const glyphStringSkipLeft = Math.round(this.printOption.marginLeft_nu * NCODE_CLASS6_NUM_DOTS);\r\n\r\n    return new Promise(resolve => {\r\n      const glyphDistancePx_canvas = this.glyphDistancePx_canvas;\r\n      /** for debugging */\r\n      if (!fullOfGlyphs) width = debugNcode_w;\r\n\r\n      ctx.fillStyle = \"rgba(0,0,0,255)\";\r\n      ctx.lineWidth = 0;\r\n\r\n      let charIndex = glyphStringSkipLeft;\r\n      for (let x = 0; x < width; x += glyphDistancePx_canvas) {\r\n        if (charIndex >= 0) {\r\n          const glyph = code_txt[charIndex];\r\n          const pos = codePos[glyph];\r\n          let dx = 0, dy = 0;\r\n          if (pos) {\r\n            dx = pos.dx;\r\n            dy = pos.dy;\r\n          }\r\n\r\n          ctx.beginPath();\r\n          ctx.rect(baseX + x + dx, baseY + y + dy, 1, 1);\r\n          ctx.fill();\r\n        }\r\n        charIndex++;\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  private drawNcodeSingleLine_NORMAL = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs = true): Promise<void> => {\r\n    const { ctx, x: baseX, y: baseY } = context;\r\n\r\n    const glyphStringSkipLeft = Math.round(this.printOption.marginLeft_nu * NCODE_CLASS6_NUM_DOTS);\r\n\r\n    return new Promise(resolve => {\r\n      const glyphDistancePx_canvas = this.glyphDistancePx_canvas;\r\n      /** for debugging */\r\n      if (!fullOfGlyphs) width = debugNcode_w;\r\n      const codeDensity = this.printOption.codeDensity;\r\n\r\n      ctx.fillStyle = \"rgba(0,0,0,255)\";\r\n      ctx.lineWidth = 0;\r\n\r\n      let charIndex = 0;\r\n      for (let x = 0; x < width; x += glyphDistancePx_canvas) {\r\n        if (charIndex + glyphStringSkipLeft >= 0) {\r\n          const glyph = code_txt[charIndex + glyphStringSkipLeft];\r\n\r\n          const pos = codePos[glyph];\r\n          let dx = 0, dy = 0;\r\n          if (pos) {\r\n            dx = pos.dx;\r\n            dy = pos.dy;\r\n          }\r\n\r\n          ctx.beginPath();\r\n          ctx.rect(baseX + x + dx, baseY + y + dy, codeDensity, codeDensity);\r\n          // ctx.rect(baseX + x + dx, baseY + y + dy, 1, 1);\r\n          ctx.fill();\r\n\r\n        }\r\n        charIndex++;\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  private drawNcodeSingleLine_BOLD = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs = true): Promise<void> => {\r\n    const { ctx, x: baseX, y: baseY } = context;\r\n\r\n    const glyphStringSkipLeft = Math.round(this.printOption.marginLeft_nu * NCODE_CLASS6_NUM_DOTS);\r\n\r\n    return new Promise(resolve => {\r\n      const glyphDistancePx_canvas = this.glyphDistancePx_canvas;\r\n      /** for debugging */\r\n      if (!fullOfGlyphs) width = debugNcode_w;\r\n      // const codeDensity = this.printOption.codeDensity;\r\n\r\n      let charIndex = 0;\r\n      for (let x = 0; x < width; x += glyphDistancePx_canvas) {\r\n        if (charIndex + glyphStringSkipLeft >= 0) {\r\n          const glyph = code_txt[charIndex + glyphStringSkipLeft];\r\n\r\n          const pos = codePos[glyph];\r\n          let dx = 0, dy = 0;\r\n          if (pos) {\r\n            dx = pos.dx;\r\n            dy = pos.dy;\r\n          }\r\n\r\n          const radius = 1.35;\r\n          ctx.beginPath();\r\n          ctx.arc(baseX + x + dx, baseY + y + dy, radius, 0, 2 * Math.PI, false);\r\n          // ctx.rect(x + dx, y + dy, codeDensity, codeDensity);\r\n          ctx.fillStyle = \"black\";\r\n          ctx.lineWidth = 0;\r\n          ctx.fill();\r\n        }\r\n        charIndex++;\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n\r\n  private drawNcode = (\r\n    context: ICanvasContextForCodeDraw,\r\n    surfaceDesc: INcodeSurfaceDesc,\r\n    dpi: number)\r\n    : Promise<INcodeAreaDesc> => {\r\n\r\n    // kitty\r\n    const DEBUG_MODE = this.printOption.debugMode;\r\n\r\n    const { glyphData } = surfaceDesc;\r\n    const { width, height } = context;\r\n    const glyphDistancePx_canvas = Math.round(dpi * 8 / 600);\r\n    const glyphStringSkipTop = Math.round(this.printOption.marginTop_nu * NCODE_CLASS6_NUM_DOTS);\r\n    const codeDrawingPromises = new Array(0);\r\n\r\n    const result: INcodeAreaDesc = {\r\n      success: false,\r\n      dpi,\r\n      pixelsPerDot: glyphDistancePx_canvas,\r\n      dotsPerCell: NCODE_CLASS6_NUM_DOTS,\r\n\r\n      pageInfo: { section: -1, owner: -1, book: -1, page: -1 },\r\n\r\n      rect: {\r\n        unit: \"nu\",\r\n        x: 0, y: 0, width: 0, height: 0,\r\n      }\r\n    };\r\n\r\n\r\n    if (glyphData.length < 1) {\r\n      console.log(\"ERROR: no ncode data given\");\r\n      return Promise.resolve(result);\r\n    }\r\n\r\n    const ctx = context.ctx;\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgba(0,0,0,255)\";\r\n\r\n\r\n    try {\r\n      // const PRINT_RESOLUTION = getPrintResolution();\r\n\r\n      const glyphStrings = glyphData.split(\"\\r\\n\");\r\n      if (glyphStrings.length < 7) {\r\n        return Promise.resolve(result);\r\n      }\r\n      //  const glyph_y = codePaperInfo.Ymin * dotsInACell;\r\n      let glyph_y = glyphStringSkipTop;\r\n\r\n      let y = 0;\r\n      for (y = 0; y < debugNcode_h; y += glyphDistancePx_canvas) {\r\n        if (glyph_y >= 0) {\r\n          const codeTxtSingleLine = glyphStrings[glyph_y];\r\n          const pr = this.drawNcodeSingleLine(context, codeTxtSingleLine, y, width, true);\r\n          codeDrawingPromises.push(pr);\r\n        }\r\n        glyph_y++;\r\n      }\r\n\r\n      for (; y < height; y += glyphDistancePx_canvas) {\r\n        if (glyph_y >= 0) {\r\n          const codeTxtSingleLine = glyphStrings[glyph_y];\r\n          const pr = this.drawNcodeSingleLine(context, codeTxtSingleLine, y, width, !(DEBUG_MODE > 1));\r\n          codeDrawingPromises.push(pr);\r\n        }\r\n        glyph_y++;\r\n      }\r\n\r\n      ctx.restore();\r\n\r\n    } catch (e) {\r\n      ctx.restore();\r\n\r\n      console.error(e);\r\n      return Promise.resolve(result);\r\n    }\r\n\r\n    return new Promise(resolve => {\r\n      Promise.all(codeDrawingPromises).then(() => {\r\n        result.success = true;\r\n        result.dpi = dpi;\r\n        result.pixelsPerDot = glyphDistancePx_canvas;\r\n        result.dotsPerCell = NCODE_CLASS6_NUM_DOTS;\r\n\r\n        result.pageInfo = { ...surfaceDesc.pageInfo };\r\n        result.rect.unit = \"nu\";\r\n        result.rect.x = this.printOption.marginLeft_nu;\r\n        result.rect.y = this.printOption.marginTop_nu;\r\n        result.rect.width = Math.ceil(width / (NCODE_CLASS6_NUM_DOTS * glyphDistancePx_canvas));\r\n        result.rect.height = Math.ceil(height / (NCODE_CLASS6_NUM_DOTS * glyphDistancePx_canvas));\r\n\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n\r\n}\r\n\r\nfunction isPtInRect(x: number, y: number, rect: IRectDpi) {\r\n  const x0 = rect.x;\r\n  const x1 = x0 + rect.width;\r\n  const y0 = rect.y;\r\n  const y1 = y0 + rect.height;\r\n\r\n  if (x >= x0 && x <= x1 && y >= y0 && y <= y1) return true;\r\n  return false;\r\n}\r\n\r\nexport function getNcodeAtCanvasPixel(pt: IPointDpi, areas: ICellsOnSheetDesc)\r\n  : IPointDpi {\r\n\r\n  if (areas.ncodeAreas.length < 1) return null;\r\n\r\n  let { x, y } = pt;\r\n  const scale = areas.ncodeAreas[0].dpi / pt.dpi;\r\n  x *= scale;\r\n  y *= scale;\r\n\r\n  for (let i = 0; i < areas.ncodeAreas.length; i++) {\r\n    const cArea = areas.canvasAreas.areas[i];\r\n\r\n    if (isPtInRect(x, y, cArea)) {\r\n      const dx_cu = x - cArea.x;\r\n      const dy_cu = y - cArea.y;\r\n\r\n      const nArea = areas.ncodeAreas[i];\r\n      const ncodeUnit = nArea.dotsPerCell * nArea.pixelsPerDot;\r\n      const dx_nu = dx_cu / ncodeUnit;\r\n      const dy_nu = dy_cu / ncodeUnit;\r\n\r\n      const x_nu = dx_nu + nArea.rect.x;\r\n      const y_nu = dy_nu + nArea.rect.y;\r\n\r\n      return { unit: \"nu\", dpi: UNIT_TO_DPI[\"nu\"], x: x_nu, y: y_nu };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getNcodeRectAtCanvasPixel(rc: IRectDpi, areas: ICellsOnSheetDesc)\r\n  : IRectDpi {\r\n\r\n  if (areas.ncodeAreas.length < 1) return null;\r\n\r\n  rc = autoSetDpi(rc);\r\n  const scale = areas.ncodeAreas[0].dpi / rc.dpi;\r\n  const center: IPointDpi = {\r\n    x: rc.x + (rc.width / 2),\r\n    y: rc.y + (rc.height / 2),\r\n    dpi: rc.dpi,\r\n  };\r\n\r\n\r\n  const center_nu = getNcodeAtCanvasPixel(center, areas);\r\n  if (!center_nu) return null;\r\n\r\n  const nArea = areas.ncodeAreas[0];    // 0과 다른 부분면(splitted area)는 항상 같다\r\n  const ncodeUnit = nArea.dotsPerCell * nArea.pixelsPerDot;\r\n\r\n  return {\r\n    unit: \"nu\",\r\n    x: center_nu.x - (rc.width / 2 * scale / ncodeUnit),\r\n    y: center_nu.y - (rc.height / 2 * scale / ncodeUnit),\r\n    width: (rc.width * scale / ncodeUnit),\r\n    height: (rc.height * scale / ncodeUnit),\r\n  }\r\n}\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageForPrint.tsx",["589","590"],"import React, { Component } from 'react';\r\nimport * as PdfJs from 'pdfjs-dist';\r\nimport { IPageSOBP, ISize, ICssSize, IRectDpi, } from '../DataStructure/Structures';\r\nimport NcodeRasterizer, { IPagesPerSheetNumbers, IPrepareSurfaceParam, drawArrow, IAreasDesc, } from \"../NcodeSurface/NcodeRasterizer\";\r\nimport { CSS_DPI, IPrintOption } from './PrintDataTypes';\r\nimport { IPageOverview } from './PagesForPrint';\r\nimport { getSurfaceSize_css } from '../NcodeSurface';\r\nimport { getCellMatrixShape } from '../NcodeSurface/SurfaceSplitter';\r\nimport { IPdfPageCanvasDesc } from '../NeoPdf/NeoPdfPage';\r\nimport NeoPdfDocument from '../NeoPdf/NeoPdfDocument';\r\nimport { uuidv4 } from './UtilFunc';\r\n\r\nlet debug = 0;\r\n\r\ntype ICanvasShapeDesc = {\r\n  /** before applying rotation */\r\n  originalPixel: ISize,\r\n\r\n  /** after applying rotation */\r\n  pixel: ISize,\r\n  rotation: number,\r\n\r\n  /** based on originalPixel */\r\n  css: ICssSize,\r\n\r\n  /** based on originalPixel */\r\n  isLandscape: boolean,\r\n}\r\n\r\n\r\n\r\ninterface Props {\r\n  /** start from 0 */\r\n  sheetIndex: number,\r\n  pdf: NeoPdfDocument,\r\n\r\n  /** null이면 화면 전용 */\r\n  OnPagePrepared: Function,\r\n  printOption: IPrintOption,\r\n  pageNums: number[],\r\n  pagesOverview: IPageOverview[],\r\n\r\n  name: string,\r\n}\r\n\r\n\r\ninterface State {\r\n  status: string,\r\n  page: PdfJs.PDFPageProxy,\r\n  width: string,\r\n  height: string,\r\n\r\n  isLandscape: boolean,\r\n}\r\n\r\n\r\n/**\r\n * Class\r\n */\r\nexport class PageForPrint extends Component<Props, State> {\r\n  canvas: HTMLCanvasElement = null;\r\n  // pageImageDescs: IPdfPageCanvasDesc[] = [];\r\n  entireRotation = 0;\r\n\r\n  uuid: string;\r\n  state = {\r\n    /** @type {string} */\r\n    status: 'N/A',\r\n\r\n    /** @type {} */\r\n    page: null,\r\n    width: \"0px\",\r\n    height: \"0px\",\r\n    isLandscape: false,\r\n  };\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    this.uuid = uuidv4();\r\n    // this.pageImageDescs = new Array(props.printOption.pagesPerSheet);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param canvas\r\n   */\r\n  setCanvasRef = (canvas: HTMLCanvasElement) => {\r\n    this.canvas = canvas;\r\n  };\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    // let shoudUpdate = true;\r\n    return this.props.pdf !== nextProps.pdf || this.state.status !== nextState.status;\r\n  }\r\n\r\n  componentDidUpdate(nextProps: Props, nextState: State) {\r\n    // this._update(nextProps.pdf, nextProps.printOption);\r\n\r\n    // console.log(\"[test updated] CHECK START\");\r\n    // for (const [key, value] of Object.entries(nextProps)) {\r\n    //   if (this.props[key] !== value) {\r\n    //     console.log(`[test updated] property[${key}] was changed, from \"${this.props[key]} to \"${value}\"`);\r\n    //   }\r\n    // }\r\n\r\n    // for (const [key, value] of Object.entries(nextState)) {\r\n    //   if (this.state[key] !== value) {\r\n    //     console.log(`[test updated] state[${key}] was changed, from \"${this.state[key]} to \"${value}\"`);\r\n    //   }\r\n    // }\r\n    // console.log(\"[test updated] CHECK END\");\r\n\r\n    this._update(nextProps.pdf, nextProps.printOption);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const { pdf, printOption } = this.props;\r\n    this._update(pdf, printOption);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param pdf\r\n   */\r\n  _update = (pdf: NeoPdfDocument, printOption: IPrintOption) => {\r\n    if (pdf) {\r\n      this.prepareSheet(pdf, printOption);\r\n    } else {\r\n      this.setState({ status: 'loading' });\r\n    }\r\n  };\r\n\r\n\r\n  prepareSheet = async (pdf: NeoPdfDocument, printOption: IPrintOption) => {\r\n    if (!this.canvas) return;\r\n\r\n    // console.log(\"[xxx] PageForPrint loadPage\");\r\n    const status = this.state.status;\r\n    const { sheetIndex } = this.props;\r\n    if (status === 'rendering' || status === 'rendered' || this.state.page !== null) return;\r\n\r\n    this.setState({ status: 'rendering' });\r\n\r\n    // 렌더링할 페이지 번호들\r\n    const pageNums = this.props.pageNums;\r\n\r\n    // Main canvas를 준비\r\n    const canvasDesc = await this.prepareMainCanvas(printOption);\r\n\r\n    // PDF 이미지를 canvas버퍼에 넣어 둔다.\r\n    let pageImagesDesc = await this.preparePdfPageImages(pdf, pageNums);    // this.pageImageDescs\r\n\r\n    // 분할된 Ncode plane을 준비\r\n    const ncodePlane = await this.prepareSplittedNcodePlane(pageNums, printOption);\r\n    const { canvas: codeCanvas, canvasAreas, } = ncodePlane;\r\n    this.reportProgress({ sheetIndex, pageNums, completion: 50 });\r\n\r\n    // main canvas를 준비\r\n    const mainCanvas = this.canvas;\r\n    const ctx = mainCanvas.getContext(\"2d\");\r\n    ctx.fillStyle = \"rgba(255, 255, 255, 255)\";     // 투명 캔버스\r\n    ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);\r\n    ctx.save();\r\n\r\n    ctx.imageSmoothingEnabled = false;\r\n\r\n    // main canvas에 PDF 이미지를 조합\r\n    pageImagesDesc = this.putPdfPageImagesOnMainCanvas(ctx, canvasAreas, pageImagesDesc);\r\n    this.reportProgress({ sheetIndex, pageNums, completion: 70 });\r\n\r\n    // 필요하면 debugging용 화살표를, debig level 1 이상\r\n    this.drawDebugLines(mainCanvas, ctx, printOption);\r\n\r\n    // main canvas에 Ncode 이미지를 오버레이\r\n    this.overlayNcodePlaneOnMainCanvas(ctx, codeCanvas, printOption);\r\n    this.reportProgress({ sheetIndex, pageNums, completion: 90 });\r\n\r\n    // PDF와 ncode의 mapping table에 추가\r\n    const pagesPerSheet = printOption.pagesPerSheet as number;\r\n    pdf.setDocumentId(pagesPerSheet);\r\n    for (let i = 0; i < pageImagesDesc.length; i++) {\r\n      pageImagesDesc[i].pdfPageInfo.id = pdf.id;\r\n    }\r\n\r\n    pdf.registerMappingItem(pageImagesDesc, ncodePlane, printOption.assignNewCode);\r\n\r\n\r\n    // 캔버스의 색상 값 디버깅용, debug level 3 이상\r\n    this.debugCheckColorValues(mainCanvas, ctx, printOption);\r\n    ctx.restore();\r\n\r\n    const { width: css_width, height: css_height } = canvasDesc.css;\r\n    this.setState({ status: 'rendered', width: css_width, height: css_height });\r\n\r\n    this.reportProgress({ sheetIndex, pageNums, completion: 100 });\r\n  }\r\n\r\n  private drawDebugLines = (mainCanvas, ctx, printOption: IPrintOption) => {\r\n    if (printOption.debugMode < 1) return;\r\n\r\n    ctx.save();\r\n\r\n    ctx.lineWidth = 10;\r\n    ctx.strokeStyle = \"rgb(0,0,0)\";\r\n    ctx.strokeRect(1, 1, mainCanvas.width - 1, mainCanvas.height - 1);\r\n\r\n    ctx.lineWidth = 50;\r\n    ctx.lineCap = \"round\";\r\n    const { width, height } = mainCanvas;\r\n\r\n    ctx.font = \"200px Verdana\";\r\n    // ctx.beginPath();\r\n    // ctx.moveTo(100, 100);\r\n    // ctx.lineTo(width - 100, 100);\r\n    // ctx.lineTo(width - 100, 120);\r\n    // ctx.lineTo(100, 120);\r\n    // ctx.moveTo(100, 100);\r\n    // ctx.stroke();\r\n    ctx.strokeStyle = \"rgb(0,0,0)\";\r\n    ctx.fillStyle = \"rgb(0,0, 0)\";\r\n    drawArrow(ctx, 50, 100, width - 100, 100);\r\n    ctx.fillText(\"X\", width - 300, 300);\r\n\r\n    drawArrow(ctx, 100, 50, 100, height - 100);\r\n    ctx.fillText(\"Y\", 150, height - 100);\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  private reportProgress = (arg: { sheetIndex: number, pageNums: number[], completion: number }) => {\r\n    const OnPagePrepared = this.props.OnPagePrepared;\r\n    if (OnPagePrepared) OnPagePrepared(arg);\r\n\r\n  }\r\n\r\n\r\n  private debugCheckColorValues = (mainCanvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, printOption: IPrintOption) => {\r\n    if (!printOption.debugMode || printOption.debugMode < 3) return;\r\n\r\n    debug++;\r\n    console.log(`color check = ${debug}`);\r\n    const { width, height } = mainCanvas;\r\n    const id = ctx.getImageData(0, 0, width, height);\r\n    const pd = id.data;\r\n    let index = 0;\r\n\r\n    const m: { [key: string]: number } = {};\r\n    for (let y = 0; y < height; y++) {\r\n      for (let x = 0; x < width; x++) {\r\n        const r = pd[index];\r\n        const g = pd[index + 1];\r\n        const b = pd[index + 2];\r\n        const a = pd[index + 3];\r\n\r\n        // const str = r + \".\" + g + \".\" + b + \".\" + a;\r\n        const str = a + \".\";\r\n        if (!m.hasOwnProperty(str)) {\r\n          console.log(`found rgba=(${r}, ${g}, ${b}, ${a})`);\r\n          m[str] = 0;\r\n        }\r\n        m[str] = m[str] + 1;\r\n\r\n        index += 4;\r\n      }\r\n    }\r\n  }\r\n\r\n  private prepareSplittedNcodePlane = async (pageNums: number[], printOption: IPrintOption) => {\r\n\r\n    // 분할된 Ncode plane을 준비\r\n    const { pagesPerSheet, debugMode, printDpi, direction, mediaSize, hasToPutNcode } = printOption;\r\n    const pageInfos: IPageSOBP[] = [];\r\n\r\n    // const pageNums: number[] = [];\r\n    for (let i = 0; i < pageNums.length; i++) {\r\n      const pageNo = pageNums[i];\r\n\r\n      const p: IPageSOBP = {\r\n        ...printOption.pageInfo,\r\n        page: printOption.pageInfo.page + pageNo - 1,\r\n      }\r\n      pageInfos.push(p);\r\n    }\r\n\r\n    const options: IPrepareSurfaceParam = {\r\n      numItems: pagesPerSheet as IPagesPerSheetNumbers,\r\n      srcDirection: direction,\r\n      dpi: printDpi,\r\n      mediaSize,\r\n      debugMode,\r\n      pageInfos,\r\n      hasToPutNcode,\r\n    };\r\n\r\n    const rasterizer = new NcodeRasterizer(printOption);\r\n    const ncodePlane = await rasterizer.prepareNcodePlane(options);\r\n\r\n    return ncodePlane;\r\n  }\r\n\r\n  private putPdfPageImagesOnMainCanvas = (ctx: CanvasRenderingContext2D,\r\n    canvasAreas: IAreasDesc, pageImageDescs: IPdfPageCanvasDesc[]) => {\r\n    // for (let i = 0; i < this.pageImageDescs.length; i++) {\r\n    //   const desc = this.pageImageDescs[i];\r\n\r\n    for (let i = 0; i < pageImageDescs.length; i++) {\r\n      const desc = pageImageDescs[i];\r\n      if (!desc) continue;\r\n\r\n      const area = canvasAreas.areas[i];\r\n      const { x, y, width, height } = area;\r\n      const canvas = desc.canvas;\r\n      // console.log(`[Multipage] draw page ${i} ${canvas.width},${canvas.height} ==> (${x},${y})~(${width}, ${height})`)\r\n\r\n      const zoom_x = width / canvas.width;\r\n      const zoom_y = height / canvas.height;\r\n      const zoom = Math.min(zoom_x, zoom_y);\r\n\r\n      const dw = canvas.width * zoom;\r\n      const dh = canvas.height * zoom;\r\n      const dx = (width - dw) / 2;\r\n      const dy = (height - dh) / 2;\r\n\r\n      ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, x + dx, y + dy, dw, dh);\r\n\r\n      const rc: IRectDpi = {\r\n        unit: \"600dpi\",\r\n        x: x + dx,\r\n        y: y + dy,\r\n        width: dw,\r\n        height: dh,\r\n      }\r\n      desc.drawnRect = rc;\r\n    }\r\n\r\n    return pageImageDescs;\r\n\r\n  }\r\n\r\n  private overlayNcodePlaneOnMainCanvas = (ctx: CanvasRenderingContext2D, codeCanvas: HTMLCanvasElement, printOption: IPrintOption) => {\r\n    if (printOption.codeDensity === 3) {\r\n      ctx.drawImage(codeCanvas, 0, 0);\r\n      ctx.drawImage(codeCanvas, 1, 0);\r\n      ctx.drawImage(codeCanvas, 2, 0);\r\n\r\n      ctx.drawImage(codeCanvas, 0, 1);\r\n      ctx.drawImage(codeCanvas, 1, 1);\r\n      ctx.drawImage(codeCanvas, 2, 1);\r\n\r\n      ctx.drawImage(codeCanvas, 0, 2);\r\n      ctx.drawImage(codeCanvas, 1, 2);\r\n      ctx.drawImage(codeCanvas, 2, 2);\r\n    }\r\n    else {\r\n      ctx.drawImage(codeCanvas, 0, 0);\r\n      ctx.drawImage(codeCanvas, 1, 0);\r\n\r\n      ctx.drawImage(codeCanvas, 0, 1);\r\n      ctx.drawImage(codeCanvas, 1, 1);\r\n    }\r\n  }\r\n\r\n\r\n\r\n  prepareMainCanvas = async (printOption: IPrintOption): Promise<ICanvasShapeDesc> => {\r\n    /** Prepare main canvas */\r\n\r\n    const mainCanvas = this.canvas;\r\n\r\n    if (!mainCanvas) {\r\n      console.log(\"main canvas is null\");\r\n      return;\r\n    }\r\n    const { printDpi: dpi, pagesPerSheet, direction } = printOption;\r\n\r\n    const { width: width_css, height: height_css } = getSurfaceSize_css(printOption.mediaSize);\r\n    // const { width: width_dpi, height: height_dpi } = getSurfaceSize_dpi(printOption.mediaSize, dpi);\r\n\r\n    const width_dpi = width_css * dpi / CSS_DPI;\r\n    const height_dpi = height_css * dpi / CSS_DPI;\r\n\r\n\r\n    /** 가로 세로의 비율을 원래대로 지키는 것이 아주 중요, 그렇지 않으면 프린터가 점을 깬다 */\r\n    // const dpi_css_scale_width = width_dpi / width_css;\r\n    // const dpi_css_scale_height = height_dpi / height_css;\r\n\r\n    // const toAvoidPageBreak = 1;\r\n    // let mediaCssWidth = Math.floor(width_css);\r\n    // let mediaCssHeight = Math.floor(height_css);\r\n    const mediaCssWidth = width_css;\r\n    const mediaCssHeight = height_css;\r\n\r\n    /** 이렇게 css의 크기를 변경해 주면, pixel의 크기도 변경해야 한다. 그때 가로 세로의 원래 비율을 유지하는 것이 굉장히 중요 */\r\n    // mediaCssWidth -= toAvoidPageBreak;\r\n    // mediaCssHeight -= toAvoidPageBreak;\r\n\r\n    let isLandscape = (direction === \"landscape\");\r\n\r\n    const { rotation } = getCellMatrixShape(pagesPerSheet, direction);\r\n    // console.log(`[yyy] prepareMainCanvas -${printOption.direction}, rotation=${rotation}`);\r\n\r\n    const isRotationNeeded = rotation === 90;\r\n    if (isRotationNeeded) isLandscape = !isLandscape;\r\n\r\n\r\n    /** 그래픽 크기와 상관 없이, rotation이 들어가 있는 경우 */\r\n    let canvasDesc: ICanvasShapeDesc = {\r\n      css: {\r\n        width: mediaCssWidth + \"px\",\r\n        height: mediaCssHeight + \"px\",\r\n      },\r\n\r\n      originalPixel: {\r\n        // width: Math.floor(mediaCssWidth * dpi_css_scale_width),\r\n        // height: Math.floor(mediaCssHeight * dpi_css_scale_height),\r\n        width: width_dpi,\r\n        height: height_dpi,\r\n      },\r\n\r\n      pixel: {\r\n        // width: Math.floor(mediaCssWidth * dpi_css_scale_width),\r\n        // height: Math.floor(mediaCssHeight * dpi_css_scale_height),\r\n        width: width_dpi,\r\n        height: height_dpi,\r\n      },\r\n      isLandscape: printOption.direction === \"landscape\",\r\n      rotation: 0,\r\n    };\r\n\r\n    if (isLandscape) {\r\n      canvasDesc = {\r\n        ...canvasDesc,\r\n        css: {\r\n          width: canvasDesc.css.height,\r\n          height: canvasDesc.css.width,\r\n        },\r\n        pixel: {\r\n          width: canvasDesc.pixel.height,\r\n          height: canvasDesc.pixel.width,\r\n        }\r\n      }\r\n    }\r\n\r\n    mainCanvas.width = canvasDesc.pixel.width;\r\n    mainCanvas.height = canvasDesc.pixel.height;\r\n\r\n    // console.log(`[size] mainCanvas = (${mainCanvas.width},${mainCanvas.height})`);\r\n    this.setState({ width: mediaCssWidth + \"px\", height: mediaCssHeight + \"px\" });\r\n\r\n    return canvasDesc;\r\n  }\r\n\r\n  /**\r\n   * this.pdfCanvasDescs에 canvasDesc들을 넣어 둔다.\r\n   */\r\n  private preparePdfPageImages = async (pdf: NeoPdfDocument, pageNums: number[])\r\n    : Promise<IPdfPageCanvasDesc[]> => {\r\n\r\n    const printOption = this.props.printOption;\r\n    const { pagesPerSheet, pdfRenderingDpi } = printOption;\r\n\r\n    const pdfDpi = pdfRenderingDpi / pagesPerSheet;\r\n    const descs = await pdf.renderPages_dpi(pageNums, pdfDpi, printOption.colorMode);\r\n    this.entireRotation = descs[0].rotation;\r\n\r\n    return descs;\r\n  }\r\n\r\n\r\n  /** imageRendering: \"pixelated\"가 굉장히 중요 */\r\n  render() {\r\n    const { sheetIndex } = this.props;\r\n    const { width, height, status } = this.state;\r\n    // console.log(`status [${status}],  Page orientation: ${isLandscape ? \"LandscapeOrientation\" : \"PortraitOrientation\"}`);\r\n    const style = {\r\n      // width, height,\r\n      // transform: `rotate(${-rotation}deg)`,\r\n      // WebkitTransform: `rotate(${-rotation}deg)`,\r\n      // msTransform: `rotate(${-rotation}deg)`,\r\n    };\r\n\r\n\r\n    return (\r\n      <div className={`pdf-sheet-${sheetIndex}${this.uuid} ${status}`} style={style} >\r\n        {/* <PortraitOrientation /> */}\r\n        <canvas ref={this.setCanvasRef} style={{ imageRendering: \"pixelated\", width, height }} />\r\n      </div >\r\n    );\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeConstans.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeSurfaceDataJson.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeFetcher.ts",["591","592","593"],"import { IPageSOBP } from \"../DataStructure/Structures\";\r\nimport * as Zlib from \"zlib\";\r\nimport { INcodeSurfaceDesc } from \"./SurfaceDataTypes\";\r\nimport { getNPaperInfo, isSamePage } from \"./SurfaceInfo\";\r\n\r\n\r\n/**\r\n * Class\r\n */\r\nexport default class NcodeFetcher {\r\n  private codeText: string = \"\";\r\n  private fetchPromise: Promise<string> = Promise.resolve(\"\");\r\n  pageInfo: IPageSOBP;\r\n\r\n  constructor(pageInfo: IPageSOBP) {\r\n    this.pageInfo = pageInfo;\r\n    this.fetchPromise = this.fetchNcodeData(pageInfo);\r\n    this.fetchPromise.then(txt => this.codeText = txt);\r\n  }\r\n\r\n\r\n  /**\r\n   * 코드 정보를 받아온다\r\n   * 코드 정보를 받아올 때 나중에는 x margin, y margin도 서버에서 받아오게 해야 한다 2020/11/26\r\n   * @param pageInfo\r\n   */\r\n  public getNcodeData = async (pageInfo: IPageSOBP): Promise<INcodeSurfaceDesc> => {\r\n    // glyph text를 받아 온다.\r\n    if (isSamePage(this.pageInfo, pageInfo)) {\r\n      console.log(\"reuse downloaded glyph data file\");\r\n      const txt = await this.fetchPromise;\r\n      this.codeText = txt;\r\n    }\r\n    else {\r\n      console.log(\"download glyph data file\");\r\n      const promise = this.fetchNcodeData(pageInfo);\r\n      this.fetchPromise = promise;\r\n      const txt = await this.fetchPromise;\r\n\r\n      this.pageInfo = pageInfo;\r\n      this.codeText = txt;\r\n    }\r\n\r\n    const result: INcodeSurfaceDesc = getNPaperInfo(pageInfo);\r\n    result.glyphData = this.codeText;\r\n\r\n    return result;\r\n  }\r\n\r\n\r\n  private fetchNcodeData = async (pageInfo: IPageSOBP): Promise<string> => {\r\n    return new Promise(async (resolve, reject) => {\r\n      // console.log(`[fetch] ${pageInfo.section}.${pageInfo.owner}.${pageInfo.book}.${pageInfo.page}`);\r\n      const url = this.getRawCodeDataUrl(pageInfo);\r\n\r\n      const blob = await fetch(url).then((r) => {\r\n\r\n        if (r.ok) {\r\n          return r.blob();\r\n        }\r\n\r\n        resolve(\"\");\r\n      });\r\n\r\n      function gunzipCallback(decompressed) {\r\n        // console.log(decompressed);\r\n        const txt = new TextDecoder(\"utf-8\").decode(decompressed);\r\n        resolve(txt);\r\n      }\r\n\r\n      if (blob != null) {\r\n        try {\r\n          const buffer = await blob.arrayBuffer();\r\n          const u8buf = new Uint8Array(buffer);\r\n          // eslint-disable-next-line\r\n          const gunzip = new Zlib.gunzip(u8buf, (err, result) => {\r\n            // console.error(err);\r\n            if (err) {\r\n              console.log(err);\r\n              resolve(\"\");\r\n            }\r\n            gunzipCallback(result);\r\n          });\r\n        } catch (e) {\r\n          resolve(\"\");\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n\r\n  private getAbsoluteURL = (base: string, relative: string): string => {\r\n    const stack = base.split(\"/\");\r\n    const parts = relative.split(\"/\");\r\n\r\n    stack.pop(); // remove current file name (or empty string)\r\n\r\n    // (omit if \"base\" is the current folder without trailing slash)\r\n    for (let i = 0; i < parts.length; i++) {\r\n      if (parts[i] === \".\") continue;\r\n      if (parts[i] === \"..\") stack.pop();\r\n      else stack.push(parts[i]);\r\n    }\r\n    return stack.join(\"/\");\r\n  }\r\n\r\n\r\n  private getRawCodeDataUrl = (pageInfo: IPageSOBP): string => {\r\n\r\n    const { section, owner, book, page } = pageInfo;\r\n\r\n    const ncode_idx = \"s\" + section + \"-o\" + owner + \"-b\" + book + \"-p\" + page;\r\n    const dir_name = \"s\" + section + \"-o\" + owner + \"-b\" + book;\r\n\r\n    const filename = \"./ncode_data/\" + dir_name + \"/\" + ncode_idx + \".code.gz\";\r\n    const doc_url = document.location.href;\r\n    const url = this.getAbsoluteURL(doc_url, filename);\r\n\r\n    return url;\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\DataTypes.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\CoordinateTanslater.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\SolveTransform.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\EchelonMatrix.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\GaussianElimination.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Posts.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderWorker.tsx",["594","595","596","597","598","599","600"],"import \"../../types\";\r\nimport { fabric } from \"fabric\";\r\nimport { PLAYSTATE } from \"./RenderWorkerBase\";\r\nimport { InkStorage } from \"../..\";\r\nimport { PATH_THICKNESS_SCALE, drawPath } from \"./DrawCurves\";\r\nimport { NCODE_TO_SCREEN_SCALE } from \"../../constants\";\r\nimport { paperInfo } from \"../../noteserver/PaperInfo\";\r\nimport { ILineOptions, IRectOptions } from \"fabric/fabric-impl\";\r\n\r\nconst timeTickDuration = 20; // ms\r\nconst DISABLED_STROKE_COLOR = \"rgba(0, 0, 0, 0.1)\";\r\n// const INVISIBLE_STROKE_COLOR = \"rgba(255, 255, 255, 0)\";\r\n// const INCOMPLETE_STROKE_COLOR = \"rgba(255, 0, 255, 0.4)\";\r\n// const CURRENT_POINT_STROKE_COLOR = \"rgba(255, 255, 255, 1)\";\r\n\r\n\r\n\r\n/**\r\n * @enum {string}\r\n */\r\n\r\nexport enum ZoomFitEnum {\r\n  ACTUAL,\r\n  WIDTH,\r\n  HEIGHT,\r\n  FULL,\r\n}\r\n\r\nconst STROKE_OBJECT_ID = \"ns\";\r\nconst GRID_OBJECT_ID = \"g\";\r\n\r\nexport default class StorageRenderWorker {\r\n  /**\r\n   *\r\n   * @param {{canvasName:string, storage:InkStorage, viewFit:ZoomFitEnum, autoStop:boolean, playTimeHandler:function, playStateHandler:function, }} options\r\n   */\r\n\r\n  viewFit;\r\n\r\n  /** @type {InkStorage} */\r\n  storage;\r\n\r\n  base_scale = NCODE_TO_SCREEN_SCALE;\r\n  offset_x = 0;\r\n  offset_y = 0;\r\n\r\n  initialSize = { width: 0, height: 0 };\r\n\r\n  currSize = { width: 0, height: 0 };\r\n\r\n  livePaths = {};\r\n\r\n  surfaceInfo = {\r\n    section: 3,\r\n    owner: 27,\r\n    book: 168,\r\n    page: 1,\r\n\r\n    Xmin: 3.12,\r\n    Ymin: 3.12,\r\n    Xmax: 91.68,\r\n    Ymax: 128.36,\r\n    Mag: 1,\r\n  }\r\n\r\n  scrollAnimateInterval = null;\r\n\r\n  // 재생 시간과 관련된 변수\r\n\r\n  playingTimeHandler;\r\n  playStateHandler;\r\n\r\n\r\n  /**\r\n   * relative time\r\n   * absolute time(unix ms) = playingTime + startTime_whole\r\n   */\r\n  playingTime = -1;\r\n\r\n  /**\r\n   * absolute time(unix ms)\r\n   * relative time = absolute time - this.startTime_whole\r\n   */\r\n  startTime_page = 0;\r\n  endTime_page = 0;\r\n\r\n  startTime_whole = 0;\r\n  endTime_whole = 0;\r\n\r\n  /**\r\n   * the page info now being played\r\n   */\r\n  rel_auto_play_endtime = 0;\r\n  autoStop;\r\n  //\r\n  canvasName;\r\n  canvas = null;\r\n  frameconfig = 1;\r\n  bgcolor = 0;\r\n  bgurl = \"\";\r\n  strokWidth;\r\n  strokHeight = this.initialSize.height;\r\n  lineScale = [1, 3, 5, 7, 10];\r\n  pathArray = []; // Rendering Path\r\n\r\n  scaleX = 1;\r\n  scaleY = 1;\r\n  // for replay\r\n  renderTime = 0;\r\n  replaySpeed = 1;\r\n  dotArray = [];\r\n  strokes = null; // neoink format stroke\r\n  backgroundImage = null;\r\n\r\n  timer = null;\r\n\r\n  timeStr = \"\";\r\n  pageNumber = 0;\r\n\r\n  rect = { x: 0, y: 0, width: 800, height: 1000 };\r\n\r\n  scale;\r\n\r\n  seekCallback;\r\n\r\n  tempPath;\r\n\r\n  tempPath_disabled;\r\n\r\n  constructor(options) {\r\n    const { canvasName, viewFit, storage, playTimeHandler, playStateHandler, autoStop } = options;\r\n\r\n    if (!(storage instanceof InkStorage)) {\r\n      console.error(\"storage is not an instance of InkStorage\");\r\n    }\r\n\r\n    this.viewFit = viewFit;\r\n\r\n    /** @type {InkStorage} */\r\n    this.storage = storage;\r\n\r\n    /** @type {number} */\r\n    // this.ncode_to_screen_scale = NCODE_TO_SCREEN_SCALE;\r\n\r\n    this.base_scale = NCODE_TO_SCREEN_SCALE;\r\n    this.offset_x = 0;\r\n    this.offset_y = 0;\r\n\r\n    /** @type {{width:number, height:number}} */\r\n    this.initialSize = { width: 0, height: 0 };\r\n\r\n    /** @type {{width:number, height:number}} */\r\n    this.currSize = { width: 0, height: 0 };\r\n\r\n    /** @type {Object.<string, {stroke:NeoStroke, path:fabric.Path}>} */\r\n    this.livePaths = {};\r\n\r\n    /** @type {{section?:number, owner?:number, book?:number, page?:number, Xmin:number, Ymin:number, Xmax:number, Ymax:number, Mag?:number}} */\r\n    this.surfaceInfo = {\r\n      section: 3,\r\n      owner: 27,\r\n      book: 168,\r\n      page: 1,\r\n\r\n      Xmin: 3.12,\r\n      Ymin: 3.12,\r\n      Xmax: 91.68,\r\n      Ymax: 128.36,\r\n      Mag: 1,\r\n    }\r\n\r\n    this.scrollAnimateInterval = null;\r\n\r\n    // 재생 시간과 관련된 변수\r\n\r\n    this.playingTimeHandler = playTimeHandler;\r\n    this.playStateHandler = playStateHandler;\r\n\r\n\r\n    /**\r\n     * relative time\r\n     * absolute time(unix ms) = playingTime + startTime_whole\r\n     */\r\n    this.playingTime = -1;\r\n\r\n    /**\r\n     * absolute time(unix ms)\r\n     * relative time = absolute time - this.startTime_whole\r\n     */\r\n    this.startTime_page = 0;\r\n    this.endTime_page = 0;\r\n\r\n    this.startTime_whole = 0;\r\n    this.endTime_whole = 0;\r\n\r\n    /**\r\n     * the page info now being played\r\n     */\r\n    this.rel_auto_play_endtime = 0;\r\n    this.autoStop = autoStop;\r\n    //\r\n    this.canvasName = canvasName;\r\n    this.canvas = null;\r\n    this.frameconfig = 1;\r\n    this.bgcolor = 0;\r\n    this.bgurl = \"\";\r\n    this.strokWidth = this.initialSize.width;\r\n    this.strokHeight = this.initialSize.height;\r\n    this.lineScale = [1, 3, 5, 7, 10];\r\n    this.pathArray = []; // Rendering Path\r\n\r\n    this.scaleX = 1;\r\n    this.scaleY = 1;\r\n    // for replay\r\n    this.renderTime = 0;\r\n    this.replaySpeed = 1;\r\n    this.dotArray = [];\r\n    this.strokes = null; // neoink format stroke\r\n    this.backgroundImage = null;\r\n\r\n    this.timer = null;\r\n\r\n    this.timeStr = \"\";\r\n    this.pageNumber = 0;\r\n\r\n    this.rect = { x: 0, y: 0, width: 800, height: 1000 };\r\n  }\r\n\r\n\r\n\r\n  //step 1: canvas set size and background image\r\n  setCanvas = (size, bgurl) => {\r\n    this.bgurl = bgurl;\r\n    this.initialSize = { ...size };\r\n    this.currSize = { ...size };\r\n    this.canvas = new fabric.Canvas(this.canvasName, {\r\n      backgroundColor: \"rgb(255,255,255)\",\r\n      // selectionColor: 'blue',\r\n      selection: false,\r\n      controlsAboveOverlay: true,\r\n      // centeredScaling: true,\r\n      // allowTouchScrolling: true,\r\n      selectionLineWidth: 4,\r\n      width: size.width,\r\n      height: size.height,\r\n    });\r\n\r\n    const canvas = this.canvas;\r\n\r\n    canvas.on('mouse:down', this.onCanvasMouseDown);\r\n    canvas.on('mouse:move', this.onCanvasMouseMove);\r\n    canvas.on('mouse:up', this.onCanvasMousUp);\r\n    canvas.on('mouse:wheel', this.onCanvasMouseWheel);\r\n\r\n\r\n    // // this.canvas.isDrawingMode = true\r\n    // return new Promise((resolve, reject) => {\r\n    //   fabric.Image.fromURL( bgurl, (img) => {\r\n    //       // console.log(\"bgurl !!!!!!!!!!!!!!!\",bgurl);\r\n    //       img.scaleToWidth(size.width);\r\n    //       // img.scaleToHeight(size.height)\r\n    //       this.backgroundImage = img;\r\n    //       img.selectable = false;\r\n    //       this.canvas.setBackgroundImage( img, this.canvas.renderAll.bind(this.canvas) );\r\n    //       // console.log(\"image size\", size, img.width, img.height);\r\n    //       resolve();\r\n    //     },\r\n    //     { crossOrigin: \"Anonymous\" }\r\n    //   );\r\n    // });\r\n  }\r\n\r\n  drawPageLayout = () => {\r\n    const canvas = this.canvas;\r\n\r\n    // 지우기\r\n    if (this.canvas) {\r\n      const objects = this.canvas.getObjects();\r\n      const strokes = objects.filter(obj => obj.objType === GRID_OBJECT_ID);\r\n\r\n      strokes.forEach((obj) => {\r\n        this.canvas.remove(obj);\r\n      });\r\n    }\r\n\r\n    // 그리기\r\n    const paperWidth = this.surfaceInfo.Xmax - this.surfaceInfo.Xmin;\r\n    const paperHeight = this.surfaceInfo.Ymax - this.surfaceInfo.Ymin;\r\n\r\n    const size = {\r\n      width: paperWidth * this.base_scale,\r\n      height: paperHeight * this.base_scale,\r\n    };\r\n\r\n    // console.log(`Grid: scale=${this.base_scale} (width, height)=(${size.width}, ${size.height})`);\r\n\r\n    const ratio = 1;\r\n\r\n    const rect = new fabric.Rect({\r\n      width: size.width * ratio - 5,\r\n      height: size.height * ratio - 5,\r\n      strokeWidth: 5,\r\n      stroke: 'rgba(0,0,0,1)',\r\n      fill: 'rgb(100,100,200, 0.1)',\r\n      left: size.width * (1 - ratio) * 0.5,\r\n      top: size.height * (1 - ratio) * 0.5,\r\n      // lockMovementX: true,\r\n      // lockMovementY: true,\r\n      selectable: false,\r\n      objType: GRID_OBJECT_ID,\r\n    } as IRectOptions);\r\n\r\n    canvas.add(rect);\r\n\r\n    for (let x = 0; x < size.width; x += 10) {\r\n      const line = new fabric.Line([x, 0, x, size.height], {\r\n        strokeWidth: 0.5,\r\n        stroke: \"rgba(0,0,0,0.1)\",\r\n        hasControls: false,\r\n        hasBorders: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        objType: GRID_OBJECT_ID,\r\n      } as ILineOptions);\r\n\r\n      canvas.add(line);\r\n    }\r\n\r\n\r\n    for (let y = 0; y < size.height; y += 10) {\r\n      const line = new fabric.Line([0, y, size.width, y], {\r\n        strokeWidth: 0.5,\r\n        stroke: \"rgba(0,0,0,0.1)\",\r\n        hasControls: false,\r\n        hasBorders: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        objType: GRID_OBJECT_ID,\r\n      } as ILineOptions);\r\n\r\n      canvas.add(line);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {Object} opt \r\n   */\r\n  onCanvasMouseDown = (opt) => {\r\n    const canvas = this.canvas;\r\n\r\n    const evt = opt.e;\r\n    if (evt.altKey === true) {\r\n      canvas.isDragging = true;\r\n      canvas.selection = false;\r\n      canvas.lastPosX = evt.clientX;\r\n      canvas.lastPosY = evt.clientY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {Object} opt \r\n   */\r\n  onCanvasMouseMove = (opt) => {\r\n    const canvas = this.canvas;\r\n\r\n    if (canvas.isDragging) {\r\n      const e = opt.e;\r\n      // console.log(`Point ${e.clientX}, ${e.clientY}`);\r\n      const vpt = canvas.viewportTransform;\r\n      vpt[4] += e.clientX - canvas.lastPosX;\r\n      vpt[5] += e.clientY - canvas.lastPosY;\r\n\r\n      this.scrollBoundaryCheck();\r\n\r\n      // canvas.setViewportTransform(vpt);\r\n      canvas.requestRenderAll();\r\n      canvas.lastPosX = e.clientX;\r\n      canvas.lastPosY = e.clientY;\r\n\r\n      // this.canvasBoundaryCheck();\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {Object} opt \r\n   */\r\n  onCanvasMousUp = (opt) => {\r\n    const canvas = this.canvas;\r\n\r\n\r\n    // on mouse up we want to recalculate new interaction\r\n    // for all objects, so we call setViewportTransform\r\n    canvas.setViewportTransform(canvas.viewportTransform);\r\n    canvas.isDragging = false;\r\n    canvas.selection = false;\r\n\r\n\r\n    // let vpt = canvas.viewportTransform;\r\n    // console.log(vpt);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {Object} opt \r\n   */\r\n  onCanvasMouseWheel = (opt) => {\r\n    const canvas = this.canvas;\r\n\r\n    const delta = opt.e.deltaY;\r\n    let zoom = canvas.getZoom();\r\n    zoom *= 0.999 ** delta;\r\n\r\n    this.setCanvasZoom(zoom, opt);\r\n  }\r\n\r\n\r\n  scrollBoundaryCheck = () => {\r\n\r\n    const canvas = this.canvas;\r\n    const zoom = canvas.getZoom();\r\n\r\n    // http://fabricjs.com/fabric-intro-part-5#pan_zoom\r\n    const vpt = canvas.viewportTransform;\r\n\r\n    if (vpt[4] >= 0) {\r\n      vpt[4] = 0;\r\n    }\r\n    else if (vpt[4] < canvas.getWidth() - this.currSize.width * zoom) {\r\n      vpt[4] = canvas.getWidth() - this.currSize.width * zoom;\r\n    }\r\n\r\n    if (vpt[5] >= 0) {\r\n      vpt[5] = 0;\r\n    }\r\n    else if (vpt[5] < canvas.getHeight() - this.currSize.height * zoom) {\r\n      vpt[5] = canvas.getHeight() - this.currSize.height * zoom;\r\n    }\r\n\r\n    if (zoom < 1) {\r\n      vpt[4] = (this.currSize.width - this.currSize.width * zoom) / 2;\r\n      vpt[5] = (this.currSize.height - this.currSize.height * zoom) / 2;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {number} zoom\r\n   * @param {Object} opt \r\n   */\r\n  setCanvasZoom = (zoom, opt) => {\r\n    const canvas = this.canvas;\r\n\r\n    if (zoom > 20) zoom = 20;\r\n    if (zoom < 0.01) zoom = 0.01;\r\n\r\n    if (opt) canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);\r\n    else canvas.setZoom(zoom);\r\n\r\n    opt.e.preventDefault();\r\n    opt.e.stopPropagation();\r\n\r\n    this.scrollBoundaryCheck();\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {{x:number, y:number}} dot \r\n   */\r\n  focusToDot = (dot) => {\r\n    const margin_to_go_ratio = 0.25;\r\n    const canvas_xy = this.getCanvasXY(dot);\r\n    const screen_xy = this.getScreenXY(canvas_xy);\r\n\r\n    let dx = 0, dy = 0;\r\n    let shouldScroll = false;\r\n\r\n    const canvas = this.canvas;\r\n    const vpt = canvas.viewportTransform;\r\n    const offset_x = vpt[4];\r\n    const offset_y = vpt[5];\r\n\r\n    if (screen_xy.x < 0) {\r\n      // scroll to left\r\n      const target = this.currSize.width * margin_to_go_ratio;\r\n      dx = target - screen_xy.x;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.y < 0) {\r\n      // scroll to top\r\n      const target = this.currSize.height * margin_to_go_ratio;\r\n      dy = target - screen_xy.y;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.x > this.currSize.width) {\r\n      // scroll to right\r\n      const target = this.currSize.width * (1 - margin_to_go_ratio);\r\n      dx = target - screen_xy.x;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.y > this.currSize.height) {\r\n      // scroll to bottom\r\n      const target = this.currSize.height * (1 - margin_to_go_ratio);\r\n      dy = target - screen_xy.y;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (shouldScroll) {\r\n\r\n      const new_offset_x = offset_x + dx;\r\n      const new_offset_y = offset_y + dy;\r\n\r\n      this.scrollCanvasToPoint({ x: new_offset_x, y: new_offset_y }, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{x:number, y:number}} point \r\n   * @param {boolean} animate\r\n   */\r\n  scrollCanvasToPoint = (point, animate) => {\r\n    const canvas = this.canvas;\r\n    const vpt = canvas.viewportTransform;\r\n\r\n    if (animate) {\r\n      if (this.scrollAnimateInterval) {\r\n        clearInterval(this.scrollAnimateInterval);\r\n        this.scrollAnimateInterval = null;\r\n      }\r\n      let x0 = vpt[4];\r\n      let y0 = vpt[5];\r\n      const x1 = point.x;\r\n      const y1 = point.y;\r\n\r\n      const div = 10;\r\n      const step_x = (x1 - x0) / div;\r\n      const step_y = (y1 - y0) / div;\r\n      let count = 0;\r\n\r\n      this.scrollAnimateInterval = setInterval(() => {\r\n        x0 += step_x;\r\n        y0 += step_y;\r\n        vpt[4] = x0;\r\n        vpt[5] = y0;\r\n        canvas.requestRenderAll();\r\n\r\n        count++;\r\n        if (count === div) {\r\n          clearInterval(this.scrollAnimateInterval);\r\n          this.scrollAnimateInterval = null;\r\n          canvas.setViewportTransform(canvas.viewportTransform);\r\n        }\r\n      }, 20);\r\n    }\r\n    else {\r\n      vpt[4] = point.x;\r\n      vpt[5] = point.y;\r\n      this.scrollBoundaryCheck();\r\n      canvas.requestRenderAll();\r\n      canvas.setViewportTransform(canvas.viewportTransform);\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {{x:number, y:number, f?:number}} ncodeXY \r\n   */\r\n  getCanvasXY = (ncodeXY) => {\r\n    const { x, y, f } = ncodeXY;\r\n    const { Xmin, Ymin } = this.surfaceInfo;\r\n\r\n    const scale = this.base_scale;\r\n\r\n    const cx = (x - Xmin) * scale + this.offset_x;\r\n    const cy = (y - Ymin) * scale + this.offset_y;\r\n\r\n    return { x: cx, y: cy, f };\r\n  }\r\n\r\n\r\n  /**\r\n * \r\n * @param {{x:number, y:number, f?:number}} ncodeXY \r\n */\r\n  getCanvasXY_scaled = (ncodeXY) => {\r\n    const { x, y, f } = ncodeXY;\r\n    const { Xmin, Ymin } = this.surfaceInfo;\r\n\r\n    const scale = this.base_scale;\r\n\r\n    let cx = (x - Xmin) * scale + this.offset_x;\r\n    let cy = (y - Ymin) * scale + this.offset_y;\r\n\r\n    cx *= PATH_THICKNESS_SCALE;\r\n    cy *= PATH_THICKNESS_SCALE;\r\n\r\n    return { x: cx, y: cy, f };\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{x:number, y:number}} canvasXY \r\n   */\r\n  getScreenXY = (canvasXY) => {\r\n    const { x, y } = canvasXY;\r\n\r\n    const canvas = this.canvas;\r\n    const vpt = canvas.viewportTransform;\r\n\r\n    const zoom = this.canvas.getZoom();\r\n    const offset_x = vpt[4];\r\n    const offset_y = vpt[5];\r\n\r\n\r\n    const sx = x * zoom + offset_x;\r\n    const sy = y * zoom + offset_y;\r\n\r\n    return { x: sx, y: sy };\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {{x:number, y:number}} screenXY \r\n   */\r\n  getNcodeXY = (screenXY) => {\r\n    const { x, y } = screenXY;\r\n\r\n    const scale = this.base_scale;\r\n\r\n    const nx = (x - this.offset_x) / scale;\r\n    const ny = (y - this.offset_y) / scale;\r\n\r\n    return { x: nx, y: ny };\r\n  }\r\n\r\n\r\n\r\n  clear = () => {\r\n    this.canvas.clear();\r\n  };\r\n\r\n  // resize = size => {\r\n  //   let zoom = size.width / this.initialSize.width;\r\n  //   this.canvas.setZoom(zoom);\r\n  //   this.canvas.setHeight(size.height);\r\n  //   this.canvas.setWidth(size.width);\r\n  // };\r\n  redrawPage = () => {\r\n    // kitty, 임시\r\n    this.resetPathArray();\r\n\r\n    const pageInfo = this.storage.getLastPageInfo();\r\n    let strokes = this.storage.getPageStrokes(pageInfo);\r\n    const live_strokes = this.storage.getPageStrokes_live(pageInfo);\r\n    strokes = strokes.concat(live_strokes);\r\n\r\n    if (strokes && strokes.length > 0) {\r\n      const page_start_time = strokes[0].dotArray[0].time;\r\n\r\n      this.initPathArray(strokes, 1, page_start_time);\r\n    }\r\n\r\n    this.drawPageAtTime(-1);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {ZoomFitEnum} mode \r\n   * @param {{width:number, height:number}} szPaper \r\n   * @param {number} currViewFit\r\n   */\r\n  calcScaleFactor(mode, szPaper, currViewFit) {\r\n    const szCanvas = this.currSize;\r\n    let scale = 1;\r\n    switch (mode) {\r\n      case ZoomFitEnum.WIDTH:\r\n        scale = szCanvas.width / szPaper.width;\r\n\r\n        break;\r\n\r\n      case ZoomFitEnum.HEIGHT:\r\n        scale = szCanvas.height / szPaper.height;\r\n        break;\r\n\r\n      case ZoomFitEnum.FULL:\r\n        scale = Math.min(szCanvas.width / szPaper.width, szCanvas.height / szPaper.height);\r\n        break;\r\n\r\n      case ZoomFitEnum.ACTUAL:\r\n        scale = NCODE_TO_SCREEN_SCALE;\r\n        break;\r\n\r\n      default:\r\n        scale = currViewFit;\r\n\r\n        break;\r\n\r\n    }\r\n    return scale;\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {number} section\r\n   * @param {number} owner\r\n   * @param {number} book\r\n   * @param {number} page\r\n   * @param {boolean} forceToRefresh\r\n   */\r\n  changePage = (section, owner, book, page, forceToRefresh) => {\r\n    const currPage = this.surfaceInfo;\r\n\r\n    if ((!forceToRefresh)\r\n      && (section === currPage.section\r\n        && owner === currPage.owner\r\n        && book === currPage.book\r\n        && page === currPage.page)) return;\r\n\r\n\r\n    // 페이지 정보와 scale을 조정한다.\r\n    const info = paperInfo.getPaperInfo({ section, owner, book, page });\r\n    if (info) {\r\n      this.surfaceInfo = {\r\n        section, owner, book, page,\r\n        Xmin: info.Xmin, Ymin: info.Ymin, Xmax: info.Xmax, Ymax: info.Ymax,\r\n        Mag: info.Mag\r\n      };\r\n\r\n    }\r\n    const szPaper = paperInfo.getPaperSize({ section, owner, book, page });\r\n    this.base_scale = this.calcScaleFactor(this.viewFit, szPaper, this.base_scale);\r\n\r\n\r\n    // 현재 모든 stroke를 지운다.\r\n    this.drawPageLayout();\r\n    this.resetPathArray();\r\n\r\n    // 페이지의 stroke를 그린다\r\n    const pageInfo = { section, owner, book, page };\r\n    const strokes = this.storage.getPageStrokes(pageInfo);\r\n\r\n    if (strokes && strokes.length > 0) {\r\n      const page_start_time = strokes[0].dotArray[0].time;\r\n      this.initPathArray(strokes, 1, page_start_time);\r\n    }\r\n\r\n    this.drawPageAtTime(-1);\r\n  }\r\n\r\n  /**\r\n   * Pen Down이 들어왔다. 그러나 아직 page 정보가 들어오지 않아서, \r\n   * 이 페이지에 붙여야 할 것인가 아니면, 새로운 페이지에 붙여야 할 것인가를 모른다.\r\n   * \r\n   * 렌더러 처리 순서\r\n   * 1) Pen Down: live stroke의 path를 생성\r\n   * 2) Page Info: 페이지를 전환하고, 잉크 스토리지에 있는 이전의 스트로크를 path로 등록한다.\r\n   * 3) Pen Move: \r\n   *      3-1) live stroke path의 처음 나오는 점이면, path를 canvas에 등록한다.\r\n   *      3-2) 두번째 점부터는 path에 append 한다.\r\n   * 4) Pen Up: Live stroke path는 없애고, 잉크스토리지에 2) 이후의 stroke를 받아 path에 추가 등록한다.\r\n   * \r\n   * @public \r\n   * @param {{strokeKey:string, mac:string, time:number, stroke:NeoStroke}} event \r\n   */\r\n  createLiveStroke = (event) => {\r\n    this.livePaths[event.strokeKey] = {\r\n      stroke: event.stroke,\r\n      path: null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, dot:NeoDot}} event \r\n   */\r\n  pushLiveDot = (event) => {\r\n    const pathData = this.livePaths[event.strokeKey];\r\n    let path = pathData.path;\r\n    const stroke = pathData.stroke;\r\n\r\n    if (path) {\r\n      this.canvas.remove(path);\r\n    }\r\n\r\n    const color = stroke.color;\r\n    // const zoom = this.canvas.getZoom();\r\n    // const thickness = stroke.thickness * zoom;\r\n    const thickness = stroke.thickness;\r\n    path = this.createPathFromDots(stroke.dotArray, color, thickness);\r\n\r\n    if (this.canvas) {\r\n      this.canvas.add(path);\r\n      pathData.path = path;\r\n    }\r\n\r\n    const dot = event.dot;\r\n    this.focusToDot(dot);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke, section:number, owner:number, book:number, page:number}} event \r\n   */\r\n  closeLiveStroke = (event) => {\r\n    const pathData = this.livePaths[event.strokeKey];\r\n    const path = pathData.path;\r\n\r\n    if (path) {\r\n      this.pathArray.push(path);\r\n      path.fill = path.color;\r\n      path.stroke = path.color;\r\n      // this.canvas.renderAll();\r\n    }\r\n\r\n    delete this.livePaths[event.strokeKey];\r\n  }\r\n\r\n  setReplaySpeed = (speed) => {\r\n    this.replaySpeed = speed;\r\n    // console.log(\"set speed\", speed)\r\n  };\r\n\r\n  resize = (size) => {\r\n    const zoom = size.width / this.initialSize.width;\r\n    this.currSize = { ...size };\r\n\r\n    this.canvas.setHeight(size.height);\r\n    this.canvas.setWidth(size.width);\r\n\r\n    this.canvas.setZoom(zoom);\r\n  };\r\n\r\n  stopInterval() {\r\n    if (this.timer) {\r\n      clearInterval(this.timer);\r\n      this.timer = null;\r\n    }\r\n  }\r\n\r\n  replayPause = () => {\r\n    this.stopInterval();\r\n  };\r\n\r\n  replayStop = () => {\r\n    this.playingTime = 0;\r\n    this.playingTimeHandler(this.playingTime);\r\n    this.drawPageAtTime(this.playingTime);\r\n  };\r\n\r\n  replayRewind = () => {\r\n    this.playingTime = this.rewindToPageStart();\r\n    this.playingTimeHandler(this.playingTime);\r\n    this.drawPageAtTime(this.playingTime);\r\n  };\r\n\r\n  setTimePoint = (ms) => {\r\n    this.playingTime = ms;\r\n    this.drawPageAtTime(this.playingTime);\r\n    // this.playingTimeHandler(this.playingTime);\r\n  };\r\n\r\n  setAutoStop = (sw) => {\r\n    this.autoStop = sw;\r\n  }\r\n  setPage = (page) => {\r\n    this.pageNumber = page.pageNumber;\r\n  };\r\n\r\n  rewindToPageStart = () => {\r\n    const newTime = this.startTime_page - this.startTime_whole - 1;\r\n    return newTime;\r\n  };\r\n\r\n  setPageStrokes = (page, strokeStream) => {\r\n    const { section, owner, book, pageNumber } = page;\r\n    const strokes_kitty = strokeStream.strokes.filter(\r\n      (s) =>\r\n        s.book === book &&\r\n        s.owner === owner &&\r\n        s.section === section &&\r\n        s.pageNum === pageNumber\r\n    );\r\n    console.log(strokes_kitty);\r\n\r\n    let lastStroke, lastDot;\r\n\r\n    // 페이지, 시작시간, 끝시각\r\n    const page_start_time = strokes_kitty[0].dotArray[0].time;\r\n    lastStroke = strokes_kitty[strokes_kitty.length - 1];\r\n    lastDot = lastStroke.dotArray[lastStroke.dotArray.length - 1];\r\n    const page_end_time = lastDot.time;\r\n\r\n    this.startTime_page = page_start_time;\r\n    this.endTime_page = page_end_time + 1;\r\n\r\n    // 전체 필기, 시작시간, 끝시간\r\n    const whole_start_time = strokeStream.strokes[0].dotArray[0].time;\r\n    lastStroke = strokeStream.strokes[strokeStream.strokes.length - 1];\r\n    lastDot = lastStroke.dotArray[lastStroke.dotArray.length - 1];\r\n    const whole_end_time = lastDot.time;\r\n\r\n    this.startTime_whole = whole_start_time;\r\n    this.endTime_whole = whole_end_time + 1;\r\n\r\n    this.playingTime = -1; // absolute time (unix ms) = playingTime + startTime_whole\r\n\r\n    return { strokes_kitty, start_time: page_start_time };\r\n  };\r\n\r\n  // Drawing iOS Data Format\r\n  preparePage = (rect, size, scale) => {\r\n    // let strokeStream = this.storage;\r\n    // // console.log(\"Page data\", page, rect, size, scale)\r\n    this.strokWidth = size.width;\r\n    this.strokHeight = size.height;\r\n    this.rect = rect;\r\n    this.scale = scale;\r\n    this.scaleX = (size.width / rect.width / scale);\r\n    this.scaleY = (size.height / rect.height / scale);\r\n    // let strokes = page.strokes;\r\n    // this.strokes = strokes;\r\n\r\n    // let stroke_data = this.setPageStrokes(page, strokeStream);\r\n    // let strokes_kitty = stroke_data.strokes_kitty;\r\n    // let page_start_time = stroke_data.start_time;\r\n\r\n    // this.resetPathArray();\r\n    // this.initPathArray(strokes_kitty, scale, page_start_time);\r\n\r\n    // // this.playingTime = this.rewindToPageStart();\r\n    // this.drawPageAtTime(this.playingTime);\r\n  };\r\n\r\n  resetPathArray = () => {\r\n    if (this.canvas) {\r\n      const objects = this.canvas.getObjects();\r\n      const strokes = objects.filter(obj => obj.objType === STROKE_OBJECT_ID);\r\n\r\n      strokes.forEach((path) => {\r\n        this.canvas.remove(path);\r\n      });\r\n    }\r\n  };\r\n\r\n  initPathArray = (strokes, scale, startTime) => {\r\n    strokes.forEach((stroke) => {\r\n      if (stroke.dotArray.length > 0) {\r\n        const color = stroke.color;\r\n        // const zoom = this.canvas.getZoom();\r\n        // const thickness = stroke.thickness * zoom;\r\n        const thickness = stroke.thickness;\r\n\r\n        const path = this.createPathFromDots(stroke.dotArray, color, thickness);\r\n        this.pathArray.push(path);\r\n        if (this.canvas) {\r\n          this.canvas.add(path);\r\n          // console.log(\"Add Path\", path);\r\n        }\r\n\r\n      }\r\n    });\r\n  };\r\n\r\n  // Draw Dot from Pen\r\n  createPathFromDots = (dots, color, thickness) => {\r\n    // let scale = this.base_scale;\r\n\r\n    // console.log(\"dot Count\", dots.length);\r\n    // let rect = this.rect;\r\n    // console.log(rect);\r\n\r\n    const pointArray = [];\r\n    dots.forEach((dot) => {\r\n      const pt = this.getCanvasXY_scaled(dot);\r\n      pointArray.push(pt);\r\n    });\r\n\r\n    // Draw Stroke\r\n    // let color = this.color;\r\n    // let thickness = this.thickness;\r\n\r\n    // console.log(\"Color, thickness\", color, thickness);\r\n    // console.log(pointArray.length, pointArray[0]);\r\n    const pathOption = {\r\n      objectCaching: false,\r\n\r\n      color: color,\r\n      stroke: color,\r\n      fill: color,\r\n      opacity: 1,\r\n      // strokeWidth: 10,\r\n      originX: 'left',\r\n      originY: 'top',\r\n      selectable: false,\r\n\r\n      objType: STROKE_OBJECT_ID,    // neostroke\r\n      // selectable: false,\r\n      //  hasRotatingPoint: false\r\n\r\n      // strokeWidth: 2,\r\n      // strokeWidth: tempThickness;\r\n      // strokeLineCap: \"round\",\r\n\r\n      // selectable: false,\r\n      // evented: true,\r\n\r\n      // base_scale: scale,\r\n    };\r\n\r\n    const strokeThickness = this.base_scale * thickness;\r\n    // console.log(strokeThickness);\r\n    // if ( strokeThickness < 0.5 ) strokeThickness = 0.5;\r\n    const pathData = drawPath(pointArray, strokeThickness);\r\n    // let pathData = drawLinePath(pointArray);\r\n    const path = new fabric.Path(pathData, pathOption);\r\n\r\n    return path;\r\n  };\r\n\r\n  // Event\r\n  setSeekHandeler = (handler) => {\r\n    this.seekCallback = handler;\r\n  };\r\n\r\n  eventHandler = (event) => {\r\n    // console.log(event, event.target.time)\r\n    this.seekCallback(event.target.time + 1);\r\n  };\r\n\r\n  /**\r\n   * time tick\r\n   */\r\n  onTick = () => {\r\n    const delta_time = timeTickDuration * this.replaySpeed;\r\n    const playTime = this.playingTime + delta_time;\r\n\r\n    // if (Math.floor(playTime / 1000) !== Math.floor(this.playingTime / 1000))\r\n    this.playingTimeHandler(this.playingTime);\r\n\r\n    this.playingTime = playTime;\r\n\r\n    let rel_endtime = this.endTime_whole - this.startTime_whole;\r\n    if (this.autoStop) {\r\n      // relative time\r\n      rel_endtime = this.rel_auto_play_endtime;\r\n    }\r\n\r\n    if (playTime > rel_endtime + delta_time) {\r\n      this.drawPageAtTime(playTime);\r\n      this.playStateHandler(PLAYSTATE.pause);\r\n    }\r\n  };\r\n\r\n  replayStart = () => {\r\n    if (this.timer) {\r\n      clearInterval(this.timer);\r\n      this.timer = null;\r\n    }\r\n\r\n    // 자동 멈춤 지점을 설정\r\n    this.rel_auto_play_endtime = this.endTime_page - this.startTime_whole;\r\n\r\n    this.timer = setInterval(this.onTick, timeTickDuration);\r\n    this.playingTimeHandler(this.playingTime);\r\n  };\r\n\r\n\r\n\r\n\r\n  /**\r\n   * stroke replay by kitty\r\n   * @param {number=} playingTime - millisecond from 0 (relative to whole strokes)\r\n   */\r\n  drawPageAtTime = (playingTime) => {\r\n    if (playingTime === -1) {\r\n      playingTime = Number.MAX_VALUE;\r\n\r\n      this.pathArray.forEach((path) => {\r\n        path.fill = path.color;\r\n        path.stroke = path.color;\r\n      });\r\n    }\r\n    else {\r\n      const time_base = this.startTime_whole;\r\n\r\n      const time_abs = playingTime + time_base;\r\n      this.pathArray.forEach((path) => {\r\n\r\n        if (time_abs <= path.startTime) {\r\n          path.fill = DISABLED_STROKE_COLOR;\r\n          path.stroke = DISABLED_STROKE_COLOR;\r\n        }\r\n        // else if (path.startTime < time_abs && time_abs <= path.endTime) {\r\n        //   path.fill = INVISIBLE_STROKE_COLOR;\r\n        //   path.stroke = INVISIBLE_STROKE_COLOR;\r\n\r\n        //   this.drawIncompletedPath(path, time_abs);\r\n        // } \r\n        else {\r\n          path.fill = path.color;\r\n          path.stroke = path.color;\r\n        }\r\n      });\r\n\r\n      if (this.pathArray.length > 0) {\r\n        const endTime = this.pathArray[this.pathArray.length - 1].endTime;\r\n        // 모든 획이 다 그려져야 하는 상황이면 temp 획을 안보이게 한다.\r\n        if (endTime && endTime < time_abs) {\r\n          this.canvas.remove(this.tempPath);\r\n          this.tempPath = null;\r\n\r\n          this.canvas.remove(this.tempPath_disabled);\r\n          this.tempPath_disabled = null;\r\n\r\n          // 확인 사살, 맨 마지막 획만\r\n          const path = this.pathArray[this.pathArray.length - 1];\r\n          path.fill = path.color;\r\n          path.stroke = path.color;\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n\r\n    this.canvas.requestRenderAll();\r\n  };\r\n\r\n  // /**\r\n  //  *\r\n  //  * @param {fabric.Path} path - path to draw\r\n  //  * @param {number} t - playTime in real-time (unixtime ms)\r\n  //  */\r\n  // drawIncompletedPath = (path, t) => {\r\n  //   let dots = path.dots;\r\n  //   let scale = path.base_scale;\r\n\r\n  //   // console.log(\"dot Count\", dots.length);\r\n  //   let rect = this.rect;\r\n  //   // console.log(rect);\r\n\r\n  //   let pointArray = [];\r\n  //   let pointArray_disabled = [];\r\n\r\n  //   let last_completed_dot = null;\r\n\r\n  //   dots.forEach((dot) => {\r\n  //     if (dot.time <= t) {\r\n  //       let pt = this.getXYPfromDot(dot, rect, scale);\r\n  //       if (pt) pointArray.push(pt);\r\n  //       last_completed_dot = dot;\r\n  //     } else {\r\n  //       let pt = this.getXYPfromDot(dot, rect, scale);\r\n\r\n  //       if (last_completed_dot) {\r\n  //         let pt_last = this.getXYPfromDot(last_completed_dot, rect, scale);\r\n  //         if (pt_last) pointArray_disabled.push(pt_last);\r\n  //         last_completed_dot = null;\r\n  //       }\r\n\r\n  //       if (pt) pointArray_disabled.push(pt);\r\n  //     }\r\n  //   });\r\n\r\n  //   let path_new = this.createRealTimePathObject(\r\n  //     pointArray,\r\n  //     path.color,\r\n  //     this.thickness\r\n  //   );\r\n  //   let path_new_disabled = this.createRealTimePathObject(\r\n  //     pointArray_disabled,\r\n  //     INCOMPLETE_STROKE_COLOR,\r\n  //     this.thickness\r\n  //   );\r\n\r\n  //   if (this.canvas) {\r\n  //     this.canvas.add(path_new);\r\n  //     this.canvas.remove(this.tempPath);\r\n  //     this.tempPath = path_new;\r\n\r\n  //     this.canvas.add(path_new_disabled);\r\n  //     this.canvas.remove(this.tempPath_disabled);\r\n  //     this.tempPath_disabled = path_new_disabled;\r\n  //     // console.log(\"Add Path\", path);\r\n  //   }\r\n\r\n  //   // let canvas_ktty = this.canvasRef.current;\r\n  //   // let ctx = canvas_ktty.getContext(\"2d\");\r\n  // };\r\n\r\n  // createRealTimePathObject = (pointArray, color, thickness) => {\r\n  //   // Draw Stroke\r\n\r\n  //   const pathOption = {\r\n  //     objectCaching: false,\r\n  //   };\r\n\r\n  //   pathOption.stroke = color;\r\n  //   let tempThickness = this.scaleX * thickness * 0.5;\r\n  //   pathOption.strokeWidth = tempThickness;\r\n  //   pathOption.strokeLineCap = \"round\";\r\n  //   pathOption.fill = color;\r\n  //   pathOption.selectable = false;\r\n\r\n  //   let pathData = drawPath(pointArray, this.scaleX * thickness);\r\n\r\n  //   let path_new = new fabric.Path(pathData, pathOption);\r\n  //   path_new.color = color;\r\n  //   // TODO: selectable and evented\r\n  //   path_new.selectable = false;\r\n  //   path_new.evented = true;\r\n\r\n  //   return path_new;\r\n  // };\r\n\r\n  // getXYPfromDot = (dot, rect, scale) => {\r\n  //   const scaleXY = (dot_x, dot_y, scale) => {\r\n  //     const offset = 0;\r\n\r\n  //     return {\r\n  //       x: ((dot_x - offset) * scale),\r\n  //       y: ((dot_y - offset) * scale),\r\n  //     };\r\n  //   };\r\n\r\n  //   let scaled = scaleXY(dot.x, dot.y, scale);\r\n\r\n  //   let p = dot.f;\r\n  //   let x = scaled.x - rect.x;\r\n  //   let y = scaled.y - rect.y;\r\n  //   if (\r\n  //     x > rect.width * this.scaleX ||\r\n  //     y > rect.height * this.scaleY ||\r\n  //     x < 0 ||\r\n  //     y < 0\r\n  //   ) {\r\n  //     // console.log(\"튀었음\", dot)\r\n  //     return;\r\n  //   }\r\n  //   x *= this.scaleX;\r\n  //   y *= this.scaleY;\r\n\r\n  //   return { x, y, p };\r\n  // };\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderer.tsx",["601","602"],"import React from \"react\";\r\nimport { InkStorage, PenEventName, } from \"../..\";\r\n\r\nimport StorageRenderWorker, { ZoomFitEnum } from \"./StorageRenderWorker\";\r\n// import { Paper } from \"@material-ui/core\";\r\nimport { PenManager } from \"../../index\";\r\nimport { uuidv4 } from \"../../utils/UtilsFunc\";\r\nimport { IPageSOBP } from \"../../../NcodePrintLib/DataStructure/Structures\";\r\n\r\n\r\ntype Props = {\r\n  pageId,\r\n  scale,\r\n  width,\r\n  height,\r\n\r\n}\r\n\r\ntype State = {\r\n  renderer: StorageRenderWorker;\r\n  pageId: string;\r\n  sizeUpdate: number;\r\n\r\n  penEventCount: number;\r\n  strokeCount: number;\r\n  liveDotCount: number;\r\n\r\n  pageInfo: IPageSOBP;\r\n\r\n  viewFit: ZoomFitEnum;\r\n\r\n  scale: number;\r\n}\r\n\r\n/**\r\n * 스토리지와 자동으로 연결되는 renderer \r\n * TO DO: 2020/11/05\r\n *    1)  현재는 연결된 모든 펜들의 stroke가 나오게 되어 있는데, \r\n *        pen의 ID로 filtering할 수 있도록 property를 넣을 수 있게 할 것\r\n * \r\n *    2)  본 컴포는트는 Storage에서 Event를 받아 rendering하는 것이므로,\r\n *        Pen에서 realtime으로 event를 받아 rendering하는 별도의 component를 만들 것\r\n */\r\nclass StorageRenderer extends React.Component<Props, State> {\r\n  state = {\r\n    /** @type {StorageRenderWorker} */\r\n    renderer: null,\r\n    pageId: \"\",\r\n\r\n    // rect: {\r\n    //   x: 0,\r\n    //   y: 0,\r\n    //   width: 88.58 * 8 / 600 * 72,\r\n    //   height: 125.28 * 8 / 600 * 72,\r\n    // },\r\n    sizeUpdate: 0,\r\n\r\n    penEventCount: 0,\r\n    strokeCount: 0,\r\n    liveDotCount: 0,\r\n\r\n    pageInfo: {\r\n      section: -1,\r\n      owner: -1,\r\n      book: -1,\r\n      page: -1,\r\n    },\r\n\r\n    scale: 1,\r\n\r\n    viewFit: ZoomFitEnum.WIDTH,\r\n  };\r\n\r\n  canvasRef;\r\n  myRef;\r\n\r\n  inkStorage;\r\n  canvasId;\r\n\r\n  size;\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    // kitty\r\n    this.canvasRef = React.createRef();\r\n    this.myRef = React.createRef();\r\n\r\n    const { pageId, scale } = props;\r\n    let inkStorage = props.inkStorage;\r\n\r\n    if (!inkStorage) {\r\n      inkStorage = InkStorage.getInstance();\r\n    }\r\n\r\n    this.inkStorage = inkStorage;\r\n\r\n    this.state = {\r\n      pageId,\r\n      scale,\r\n      ...this.state\r\n    };\r\n\r\n    // // 실시간 데이터 전송을 위해, penStorage와 view를 연결한다.\r\n    if (this.inkStorage) {\r\n      const filter = { mac: null };\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this), filter);\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this), filter);\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this), filter);\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this), filter);\r\n    }\r\n\r\n    this.canvasId = uuidv4();\r\n  }\r\n\r\n\r\n  /**\r\n   * @public\r\n   * @param {NeoSmartpen} pen \r\n   */\r\n  listenPenEvent(pen) {\r\n    pen.addEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this));\r\n    pen.addEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this));\r\n    pen.addEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this));\r\n    pen.addEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this));\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * @param {NeoSmartpen} pen \r\n   */\r\n  ignorePenEvent(pen) {\r\n    pen.removeEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this));\r\n    pen.removeEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this));\r\n    pen.removeEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this));\r\n    pen.removeEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this));\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, time:number, stroke:NeoStroke}} event \r\n   */\r\n  onLivePenDown = (event) => {\r\n    // console.log(event);\r\n    if (this.state.renderer) {\r\n      this.state.renderer.createLiveStroke(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, section:number, owner:number, book:number, page:number}} event \r\n   */\r\n  onLivePenPageInfo = (event) => {\r\n    const { penEventCount } = this.state;\r\n    const { section, owner, book, page } = event;\r\n\r\n    this.setState({\r\n      penEventCount: penEventCount + 1,\r\n      pageInfo: { section, owner, book, page }\r\n    });\r\n\r\n    const inkStorage = this.inkStorage;\r\n    if (inkStorage) {\r\n      const pageStrokesCount = inkStorage.getPageStrokes(event).length;\r\n      this.setState({ strokeCount: pageStrokesCount });\r\n    }\r\n\r\n    if (this.state.renderer) {\r\n      this.state.renderer.changePage(section, owner, book, page, false);\r\n    }\r\n    // console.log(event);\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, dot:NeoDot}} event \r\n   */\r\n\r\n  onLivePenMove = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.pushLiveDot(event);\r\n    }\r\n    // const { liveDotCount } = this.state;\r\n\r\n    // this.setState({ liveDotCount: liveDotCount + 1 });\r\n    // console.log(event);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke, section:number, owner:number, book:number, page:number}} event \r\n   */\r\n  onLivePenUp = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.closeLiveStroke(event);\r\n    }\r\n\r\n    // const { penEventCount, inkStorage } = this.state;\r\n    // this.setState({ penEventCount: penEventCount + 1 });\r\n    // if (inkStorage) {\r\n    //   let pageStrokesCount = inkStorage.getPageStrokes(event).length;\r\n    //   this.setState({ strokeCount: pageStrokesCount });\r\n    // }\r\n    // console.log(event);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @return {{section:number, owner:number, book:number, page:number}}\r\n   */\r\n  getPageIdNumbers() {\r\n    /** @type {Array.<string>} */\r\n    const numbers = this.state.pageId.split(\".\");\r\n\r\n    const section = parseInt(numbers[0]);\r\n    const owner = parseInt(numbers[1]);\r\n    const book = parseInt(numbers[2]);\r\n    const page = parseInt(numbers[3]);\r\n\r\n    return {\r\n      section, owner, book, page\r\n    }\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    const ret_val = true;\r\n\r\n    return ret_val;\r\n  }\r\n\r\n  initRenderer(size) {\r\n    const {\r\n      scale,\r\n      width,\r\n      height\r\n    } = this.props;\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    // const page = pages.filter((p) => p.pageNumber === pageId)[0];\r\n\r\n    const inkStorage = this.inkStorage;\r\n    const options = {\r\n      canvasName: this.canvasId,\r\n      storage: inkStorage,\r\n      viewFit: this.state.viewFit,\r\n    };\r\n\r\n    const renderer = new StorageRenderWorker(options);\r\n\r\n    // let bg_header = EXAM_FILE_RESOURCES[tab_value].bg_img_header;\r\n    // let bgurl = window.location.origin + bg_header + pageId + \".jpg\";\r\n    // // let bgurl = window.location.origin + \"/img/3_27_1089_\" + pageId + \".jpg\";\r\n\r\n    renderer.setCanvas(size, \"\");\r\n\r\n    // renderer.setPage(page);\r\n    renderer.preparePage(rect, size, scale);\r\n    // renderer.setSeekHandeler(this.props.seekHandler);\r\n    this.setState({ renderer: renderer });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const node = this.myRef.current;\r\n    if (node) {\r\n\r\n      const parentHeight = node.offsetHeight;\r\n      const parentWidth = node.offsetWidth;\r\n\r\n      console.log(`(width, height) = (${parentHeight}, ${parentWidth})`);\r\n    }\r\n\r\n    const size = this.size;\r\n    const { pageId, width, height } = this.props;\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n\r\n    // const page = pages.filter((p) => p.pageNumber === pageId)[0];\r\n    console.log(\"Draw Stroke size\", pageId, \"canvas size\", size, \"rect\", rect);\r\n\r\n    this.initRenderer(this.size);\r\n    window.addEventListener(\"resize\", this.resizeListener);\r\n\r\n\r\n    // penManager에 연결 \r\n    const penManager = PenManager.getInstance();\r\n    penManager.registerRenderContainer(this);\r\n  }\r\n\r\n  resizeListener = () => {\r\n    this.setState({ sizeUpdate: this.state.sizeUpdate + 1 });\r\n\r\n    // const { classes, scaleType, scale } = this.props;\r\n    const { scale, width, height } = this.props;\r\n\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    // const { penEventCount } = this.state;\r\n    this.size = this.getSize(scale, rect);\r\n\r\n    if (this.state.renderer) {\r\n      // console.log(\"render resize\", this.size)\r\n      this.state.renderer.resize(this.size);\r\n    }\r\n  };\r\n\r\n  // getSize_old = (scale, rect) => {\r\n\r\n\r\n  //   const vertical_margin = 0;\r\n  //   const horizontal_margin = 0; // left 200, right 200\r\n\r\n  //   const pageHeight = window.innerHeight - vertical_margin;\r\n  //   let h = pageHeight - 20; // for divider\r\n  //   let w = window.innerWidth - horizontal_margin;\r\n\r\n  //   h = h * scale;\r\n  //   w = (h * rect.width) / rect.height;\r\n  //   // scale to width\r\n\r\n  //   console.log(\"!!!!!!!!!\", w, h, rect.height, rect.width);\r\n  //   console.log(this);\r\n\r\n  //   let size = {\r\n  //     w: w,\r\n  //     h: h,\r\n  //   };\r\n\r\n  //   return size;\r\n  // };\r\n\r\n  getSize = (scale, rect) => {\r\n    const size = {\r\n      width: rect.width,\r\n      height: rect.height,\r\n    };\r\n\r\n    return size;\r\n  };\r\n\r\n  componentWillUnmount() {\r\n    // this.state.renderer.stopInterval();\r\n    window.removeEventListener(\"resize\", this.resizeListener);\r\n\r\n    // penManager에 연결 해제\r\n    const penManager = PenManager.getInstance();\r\n    penManager.unregisterRenderContainer(this);\r\n\r\n    // ink storage와 연결 해제\r\n    // // 실시간 데이터 전송을 위해, penStorage와 view를 연결한다.\r\n    if (this.inkStorage) {\r\n      const inkStorage = this.inkStorage;\r\n\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this));\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this));\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this));\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this));\r\n    }\r\n\r\n\r\n  }\r\n\r\n  render() {\r\n    // const { classes, scaleType, scale } = this.props;\r\n    const { scale, width, height } = this.props;\r\n    const { section, owner, book, page } = this.state.pageInfo;\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    const { penEventCount } = this.state;\r\n    this.size = this.getSize(scale, rect);\r\n\r\n    return (\r\n      <div id=\"replayContainer\" ref={this.myRef}>\r\n        <h1>StorageRenderer</h1><h2>{section}.{owner}.{book}.{page}:{penEventCount}</h2>\r\n        <canvas id={this.canvasId} ref={this.canvasRef} style={{ height: this.size.height, width: this.size.width }} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// StorageRenderer.propTypes = propTypes;\r\n// StorageRenderer.defaultProps = defaultProps;\r\n\r\n// export default withStyles(styles)(StorageRenderer);\r\nexport default StorageRenderer;\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\constants.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\index.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Post.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\About.tsx",[],{"ruleId":"603","severity":1,"message":"604","line":4,"column":26,"nodeType":"605","messageId":"606","endLine":4,"endColumn":41},{"ruleId":"603","severity":1,"message":"607","line":7,"column":7,"nodeType":"605","messageId":"606","endLine":7,"endColumn":19},{"ruleId":"603","severity":1,"message":"608","line":68,"column":22,"nodeType":"605","messageId":"606","endLine":68,"endColumn":27},{"ruleId":"603","severity":1,"message":"609","line":3,"column":19,"nodeType":"605","messageId":"606","endLine":3,"endColumn":31},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"612","line":3,"column":10,"nodeType":"605","messageId":"606","endLine":3,"endColumn":17},{"ruleId":"603","severity":1,"message":"613","line":18,"column":11,"nodeType":"605","messageId":"606","endLine":18,"endColumn":16},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"609","line":3,"column":19,"nodeType":"605","messageId":"606","endLine":3,"endColumn":31},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"609","line":3,"column":19,"nodeType":"605","messageId":"606","endLine":3,"endColumn":31},{"ruleId":"603","severity":1,"message":"609","line":3,"column":19,"nodeType":"605","messageId":"606","endLine":3,"endColumn":31},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"609","line":3,"column":19,"nodeType":"605","messageId":"606","endLine":3,"endColumn":31},{"ruleId":"603","severity":1,"message":"609","line":4,"column":19,"nodeType":"605","messageId":"606","endLine":4,"endColumn":31},{"ruleId":"603","severity":1,"message":"610","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":26},{"ruleId":"603","severity":1,"message":"611","line":1,"column":28,"nodeType":"605","messageId":"606","endLine":1,"endColumn":36},{"ruleId":"603","severity":1,"message":"609","line":3,"column":19,"nodeType":"605","messageId":"606","endLine":3,"endColumn":31},{"ruleId":"603","severity":1,"message":"614","line":21,"column":25,"nodeType":"605","messageId":"606","endLine":21,"endColumn":39},{"ruleId":"603","severity":1,"message":"615","line":21,"column":41,"nodeType":"605","messageId":"606","endLine":21,"endColumn":55},{"ruleId":"603","severity":1,"message":"616","line":1,"column":34,"nodeType":"605","messageId":"606","endLine":1,"endColumn":38},{"ruleId":"603","severity":1,"message":"617","line":269,"column":26,"nodeType":"605","messageId":"606","endLine":269,"endColumn":69},{"ruleId":"603","severity":1,"message":"618","line":186,"column":29,"nodeType":"605","messageId":"606","endLine":186,"endColumn":40},{"ruleId":"603","severity":1,"message":"619","line":138,"column":21,"nodeType":"605","messageId":"606","endLine":138,"endColumn":29},{"ruleId":"603","severity":1,"message":"615","line":91,"column":43,"nodeType":"605","messageId":"606","endLine":91,"endColumn":59},{"ruleId":"603","severity":1,"message":"620","line":35,"column":24,"nodeType":"605","messageId":"606","endLine":35,"endColumn":59},{"ruleId":"603","severity":1,"message":"620","line":36,"column":26,"nodeType":"605","messageId":"606","endLine":36,"endColumn":57},{"ruleId":"603","severity":1,"message":"615","line":209,"column":43,"nodeType":"605","messageId":"606","endLine":209,"endColumn":59},{"ruleId":"603","severity":1,"message":"621","line":6,"column":10,"nodeType":"605","messageId":"606","endLine":6,"endColumn":17},{"ruleId":"603","severity":1,"message":"622","line":8,"column":7,"nodeType":"605","messageId":"606","endLine":8,"endColumn":16},{"ruleId":"623","severity":1,"message":"624","line":29,"column":26,"nodeType":"605","messageId":"625","endLine":29,"endColumn":34},{"ruleId":"603","severity":1,"message":"626","line":63,"column":72,"nodeType":"605","messageId":"606","endLine":63,"endColumn":76},{"ruleId":"603","severity":1,"message":"627","line":4,"column":3,"nodeType":"605","messageId":"606","endLine":4,"endColumn":12},{"ruleId":"603","severity":1,"message":"628","line":5,"column":3,"nodeType":"605","messageId":"606","endLine":5,"endColumn":16},{"ruleId":"603","severity":1,"message":"629","line":6,"column":3,"nodeType":"605","messageId":"606","endLine":6,"endColumn":15},{"ruleId":"603","severity":1,"message":"630","line":22,"column":3,"nodeType":"605","messageId":"606","endLine":22,"endColumn":7},{"ruleId":"603","severity":1,"message":"631","line":23,"column":3,"nodeType":"605","messageId":"606","endLine":23,"endColumn":7},{"ruleId":"603","severity":1,"message":"632","line":24,"column":3,"nodeType":"605","messageId":"606","endLine":24,"endColumn":7},{"ruleId":"603","severity":1,"message":"633","line":25,"column":3,"nodeType":"605","messageId":"606","endLine":25,"endColumn":8},{"ruleId":"603","severity":1,"message":"634","line":26,"column":3,"nodeType":"605","messageId":"606","endLine":26,"endColumn":9},{"ruleId":"603","severity":1,"message":"635","line":27,"column":3,"nodeType":"605","messageId":"606","endLine":27,"endColumn":14},{"ruleId":"603","severity":1,"message":"636","line":28,"column":3,"nodeType":"605","messageId":"606","endLine":28,"endColumn":14},{"ruleId":"603","severity":1,"message":"637","line":29,"column":3,"nodeType":"605","messageId":"606","endLine":29,"endColumn":16},{"ruleId":"603","severity":1,"message":"620","line":44,"column":26,"nodeType":"605","messageId":"606","endLine":44,"endColumn":57},{"ruleId":"603","severity":1,"message":"638","line":401,"column":21,"nodeType":"605","messageId":"606","endLine":401,"endColumn":29},{"ruleId":"603","severity":1,"message":"639","line":11,"column":18,"nodeType":"605","messageId":"606","endLine":11,"endColumn":27},{"ruleId":"603","severity":1,"message":"640","line":3,"column":3,"nodeType":"605","messageId":"606","endLine":3,"endColumn":6},{"ruleId":"603","severity":1,"message":"641","line":4,"column":3,"nodeType":"605","messageId":"606","endLine":4,"endColumn":9},{"ruleId":"603","severity":1,"message":"642","line":5,"column":3,"nodeType":"605","messageId":"606","endLine":5,"endColumn":9},{"ruleId":"603","severity":1,"message":"643","line":6,"column":3,"nodeType":"605","messageId":"606","endLine":6,"endColumn":9},{"ruleId":"603","severity":1,"message":"644","line":7,"column":3,"nodeType":"605","messageId":"606","endLine":7,"endColumn":7},{"ruleId":"603","severity":1,"message":"645","line":8,"column":3,"nodeType":"605","messageId":"606","endLine":8,"endColumn":7},{"ruleId":"603","severity":1,"message":"645","line":15,"column":3,"nodeType":"605","messageId":"606","endLine":15,"endColumn":7},{"ruleId":"603","severity":1,"message":"646","line":16,"column":3,"nodeType":"605","messageId":"606","endLine":16,"endColumn":11},{"ruleId":"603","severity":1,"message":"647","line":17,"column":3,"nodeType":"605","messageId":"606","endLine":17,"endColumn":11},{"ruleId":"603","severity":1,"message":"648","line":18,"column":3,"nodeType":"605","messageId":"606","endLine":18,"endColumn":9},{"ruleId":"603","severity":1,"message":"649","line":20,"column":3,"nodeType":"605","messageId":"606","endLine":20,"endColumn":13},{"ruleId":"603","severity":1,"message":"650","line":27,"column":3,"nodeType":"605","messageId":"606","endLine":27,"endColumn":14},{"ruleId":"603","severity":1,"message":"651","line":28,"column":3,"nodeType":"605","messageId":"606","endLine":28,"endColumn":18},{"ruleId":"603","severity":1,"message":"652","line":29,"column":3,"nodeType":"605","messageId":"606","endLine":29,"endColumn":24},{"ruleId":"603","severity":1,"message":"653","line":30,"column":3,"nodeType":"605","messageId":"606","endLine":30,"endColumn":14},{"ruleId":"603","severity":1,"message":"654","line":31,"column":3,"nodeType":"605","messageId":"606","endLine":31,"endColumn":12},{"ruleId":"603","severity":1,"message":"655","line":32,"column":3,"nodeType":"605","messageId":"606","endLine":32,"endColumn":16},{"ruleId":"603","severity":1,"message":"656","line":34,"column":3,"nodeType":"605","messageId":"606","endLine":34,"endColumn":17},{"ruleId":"603","severity":1,"message":"657","line":35,"column":3,"nodeType":"605","messageId":"606","endLine":35,"endColumn":17},{"ruleId":"603","severity":1,"message":"658","line":36,"column":3,"nodeType":"605","messageId":"606","endLine":36,"endColumn":15},{"ruleId":"603","severity":1,"message":"659","line":37,"column":3,"nodeType":"605","messageId":"606","endLine":37,"endColumn":18},{"ruleId":"603","severity":1,"message":"660","line":39,"column":3,"nodeType":"605","messageId":"606","endLine":39,"endColumn":20},{"ruleId":"603","severity":1,"message":"640","line":47,"column":3,"nodeType":"605","messageId":"606","endLine":47,"endColumn":6},{"ruleId":"603","severity":1,"message":"661","line":48,"column":3,"nodeType":"605","messageId":"606","endLine":48,"endColumn":9},{"ruleId":"603","severity":1,"message":"662","line":49,"column":3,"nodeType":"605","messageId":"606","endLine":49,"endColumn":9},{"ruleId":"603","severity":1,"message":"641","line":50,"column":3,"nodeType":"605","messageId":"606","endLine":50,"endColumn":9},{"ruleId":"603","severity":1,"message":"663","line":51,"column":3,"nodeType":"605","messageId":"606","endLine":51,"endColumn":8},{"ruleId":"603","severity":1,"message":"664","line":52,"column":3,"nodeType":"605","messageId":"606","endLine":52,"endColumn":14},{"ruleId":"603","severity":1,"message":"665","line":17,"column":10,"nodeType":"605","messageId":"606","endLine":17,"endColumn":27},{"ruleId":"603","severity":1,"message":"666","line":17,"column":29,"nodeType":"605","messageId":"606","endLine":17,"endColumn":41},{"ruleId":"603","severity":1,"message":"667","line":20,"column":8,"nodeType":"605","messageId":"606","endLine":20,"endColumn":24},{"ruleId":"603","severity":1,"message":"668","line":24,"column":8,"nodeType":"605","messageId":"606","endLine":24,"endColumn":14},{"ruleId":"603","severity":1,"message":"669","line":68,"column":24,"nodeType":"605","messageId":"606","endLine":68,"endColumn":25},{"ruleId":"603","severity":1,"message":"669","line":329,"column":45,"nodeType":"605","messageId":"606","endLine":329,"endColumn":46},{"ruleId":"603","severity":1,"message":"615","line":72,"column":43,"nodeType":"605","messageId":"606","endLine":72,"endColumn":59},{"ruleId":"603","severity":1,"message":"670","line":57,"column":16,"nodeType":"605","messageId":"606","endLine":57,"endColumn":32},{"ruleId":"603","severity":1,"message":"669","line":86,"column":26,"nodeType":"605","messageId":"606","endLine":86,"endColumn":27},{"ruleId":"603","severity":1,"message":"669","line":105,"column":31,"nodeType":"605","messageId":"606","endLine":105,"endColumn":32},{"ruleId":"603","severity":1,"message":"671","line":223,"column":11,"nodeType":"605","messageId":"606","endLine":223,"endColumn":16},{"ruleId":"672","severity":1,"message":"673","line":43,"column":3,"nodeType":"674","messageId":"675","endLine":43,"endColumn":22,"fix":"676"},{"ruleId":"603","severity":1,"message":"677","line":188,"column":30,"nodeType":"605","messageId":"606","endLine":188,"endColumn":46},{"ruleId":"603","severity":1,"message":"678","line":188,"column":48,"nodeType":"605","messageId":"606","endLine":188,"endColumn":64},{"ruleId":"603","severity":1,"message":"677","line":203,"column":22,"nodeType":"605","messageId":"606","endLine":203,"endColumn":38},{"ruleId":"603","severity":1,"message":"678","line":203,"column":40,"nodeType":"605","messageId":"606","endLine":203,"endColumn":56},{"ruleId":"603","severity":1,"message":"611","line":1,"column":17,"nodeType":"605","messageId":"606","endLine":1,"endColumn":25},{"ruleId":"603","severity":1,"message":"679","line":90,"column":6,"nodeType":"605","messageId":"606","endLine":90,"endColumn":18},{"ruleId":"603","severity":1,"message":"680","line":93,"column":30,"nodeType":"605","messageId":"606","endLine":93,"endColumn":36},{"ruleId":"603","severity":1,"message":"681","line":97,"column":9,"nodeType":"605","messageId":"606","endLine":97,"endColumn":19},{"ruleId":"603","severity":1,"message":"669","line":97,"column":23,"nodeType":"605","messageId":"606","endLine":97,"endColumn":24},{"ruleId":"603","severity":1,"message":"682","line":101,"column":9,"nodeType":"605","messageId":"606","endLine":101,"endColumn":17},{"ruleId":"603","severity":1,"message":"683","line":187,"column":13,"nodeType":"605","messageId":"606","endLine":187,"endColumn":19},{"ruleId":"603","severity":1,"message":"684","line":188,"column":13,"nodeType":"605","messageId":"606","endLine":188,"endColumn":19},{"ruleId":"603","severity":1,"message":"685","line":235,"column":13,"nodeType":"605","messageId":"606","endLine":235,"endColumn":15},{"ruleId":"603","severity":1,"message":"686","line":84,"column":11,"nodeType":"605","messageId":"606","endLine":84,"endColumn":14},{"ruleId":"603","severity":1,"message":"687","line":86,"column":11,"nodeType":"605","messageId":"606","endLine":86,"endColumn":23},{"ruleId":"603","severity":1,"message":"614","line":103,"column":22,"nodeType":"605","messageId":"606","endLine":103,"endColumn":42},{"ruleId":"603","severity":1,"message":"688","line":132,"column":43,"nodeType":"605","messageId":"606","endLine":132,"endColumn":55},{"ruleId":"603","severity":1,"message":"640","line":4,"column":3,"nodeType":"605","messageId":"606","endLine":4,"endColumn":6},{"ruleId":"603","severity":1,"message":"641","line":5,"column":3,"nodeType":"605","messageId":"606","endLine":5,"endColumn":9},{"ruleId":"603","severity":1,"message":"642","line":6,"column":3,"nodeType":"605","messageId":"606","endLine":6,"endColumn":9},{"ruleId":"603","severity":1,"message":"643","line":7,"column":3,"nodeType":"605","messageId":"606","endLine":7,"endColumn":9},{"ruleId":"603","severity":1,"message":"644","line":8,"column":3,"nodeType":"605","messageId":"606","endLine":8,"endColumn":7},{"ruleId":"603","severity":1,"message":"645","line":9,"column":3,"nodeType":"605","messageId":"606","endLine":9,"endColumn":7},{"ruleId":"603","severity":1,"message":"689","line":14,"column":3,"nodeType":"605","messageId":"606","endLine":14,"endColumn":7},{"ruleId":"603","severity":1,"message":"690","line":15,"column":3,"nodeType":"605","messageId":"606","endLine":15,"endColumn":7},{"ruleId":"603","severity":1,"message":"691","line":16,"column":3,"nodeType":"605","messageId":"606","endLine":16,"endColumn":6},{"ruleId":"603","severity":1,"message":"692","line":17,"column":3,"nodeType":"605","messageId":"606","endLine":17,"endColumn":6},{"ruleId":"603","severity":1,"message":"693","line":18,"column":3,"nodeType":"605","messageId":"606","endLine":18,"endColumn":6},{"ruleId":"603","severity":1,"message":"694","line":20,"column":3,"nodeType":"605","messageId":"606","endLine":20,"endColumn":7},{"ruleId":"603","severity":1,"message":"695","line":21,"column":3,"nodeType":"605","messageId":"606","endLine":21,"endColumn":7},{"ruleId":"603","severity":1,"message":"696","line":23,"column":3,"nodeType":"605","messageId":"606","endLine":23,"endColumn":7},{"ruleId":"603","severity":1,"message":"697","line":54,"column":6,"nodeType":"605","messageId":"606","endLine":54,"endColumn":18},{"ruleId":"603","severity":1,"message":"698","line":55,"column":3,"nodeType":"605","messageId":"606","endLine":55,"endColumn":15},{"ruleId":"603","severity":1,"message":"699","line":56,"column":3,"nodeType":"605","messageId":"606","endLine":56,"endColumn":13},{"ruleId":"603","severity":1,"message":"700","line":57,"column":3,"nodeType":"605","messageId":"606","endLine":57,"endColumn":12},{"ruleId":"603","severity":1,"message":"701","line":345,"column":21,"nodeType":"605","messageId":"606","endLine":345,"endColumn":24},{"ruleId":"672","severity":1,"message":"673","line":1,"column":59,"nodeType":"702","messageId":"675","endLine":1,"endColumn":78,"fix":"703"},{"ruleId":"704","severity":1,"message":"705","line":145,"column":21,"nodeType":"605","messageId":"706","endLine":145,"endColumn":29},{"ruleId":"603","severity":1,"message":"707","line":9,"column":10,"nodeType":"605","messageId":"606","endLine":9,"endColumn":27},{"ruleId":"708","severity":1,"message":"709","line":22,"column":2,"nodeType":"710","messageId":"711","endLine":22,"endColumn":3,"fix":"712"},{"ruleId":"603","severity":1,"message":"713","line":53,"column":32,"nodeType":"605","messageId":"606","endLine":53,"endColumn":35},{"ruleId":"603","severity":1,"message":"614","line":81,"column":22,"nodeType":"605","messageId":"606","endLine":81,"endColumn":31},{"ruleId":"603","severity":1,"message":"615","line":81,"column":33,"nodeType":"605","messageId":"606","endLine":81,"endColumn":42},{"ruleId":"603","severity":1,"message":"714","line":1,"column":47,"nodeType":"605","messageId":"606","endLine":1,"endColumn":59},{"ruleId":"603","severity":1,"message":"715","line":2,"column":24,"nodeType":"605","messageId":"606","endLine":2,"endColumn":33},{"ruleId":"603","severity":1,"message":"716","line":4,"column":10,"nodeType":"605","messageId":"606","endLine":4,"endColumn":21},{"ruleId":"672","severity":1,"message":"717","line":36,"column":3,"nodeType":"674","messageId":"675","endLine":36,"endColumn":28,"fix":"718"},{"ruleId":"719","severity":1,"message":"720","line":54,"column":13,"nodeType":"721","messageId":"722","endLine":54,"endColumn":27},{"ruleId":"672","severity":1,"message":"717","line":133,"column":67,"nodeType":"702","messageId":"675","endLine":133,"endColumn":95,"fix":"723"},{"ruleId":"672","severity":1,"message":"717","line":157,"column":60,"nodeType":"702","messageId":"675","endLine":157,"endColumn":88,"fix":"724"},{"ruleId":"672","severity":1,"message":"717","line":161,"column":55,"nodeType":"702","messageId":"675","endLine":161,"endColumn":83,"fix":"725"},{"ruleId":"672","severity":1,"message":"717","line":165,"column":53,"nodeType":"702","messageId":"675","endLine":165,"endColumn":81,"fix":"726"},{"ruleId":"672","severity":1,"message":"717","line":169,"column":54,"nodeType":"702","messageId":"675","endLine":169,"endColumn":82,"fix":"727"},{"ruleId":"672","severity":1,"message":"717","line":174,"column":53,"nodeType":"702","messageId":"675","endLine":174,"endColumn":81,"fix":"728"},{"ruleId":"603","severity":1,"message":"729","line":276,"column":84,"nodeType":"605","messageId":"606","endLine":276,"endColumn":108},{"ruleId":"672","severity":1,"message":"717","line":394,"column":121,"nodeType":"702","messageId":"675","endLine":394,"endColumn":149,"fix":"730"},{"ruleId":"672","severity":1,"message":"717","line":432,"column":119,"nodeType":"702","messageId":"675","endLine":432,"endColumn":147,"fix":"731"},{"ruleId":"603","severity":1,"message":"615","line":96,"column":40,"nodeType":"605","messageId":"606","endLine":96,"endColumn":56},{"ruleId":"719","severity":1,"message":"720","line":257,"column":16,"nodeType":"721","messageId":"722","endLine":257,"endColumn":30},{"ruleId":"672","severity":1,"message":"673","line":11,"column":3,"nodeType":"674","messageId":"675","endLine":11,"endColumn":33,"fix":"732"},{"ruleId":"733","severity":1,"message":"734","line":52,"column":24,"nodeType":"605","messageId":"735","endLine":52,"endColumn":29},{"ruleId":"603","severity":1,"message":"736","line":52,"column":40,"nodeType":"605","messageId":"606","endLine":52,"endColumn":46},{"ruleId":"603","severity":1,"message":"737","line":23,"column":3,"nodeType":"605","messageId":"606","endLine":23,"endColumn":9},{"ruleId":"603","severity":1,"message":"738","line":24,"column":3,"nodeType":"605","messageId":"606","endLine":24,"endColumn":8},{"ruleId":"603","severity":1,"message":"739","line":25,"column":3,"nodeType":"605","messageId":"606","endLine":25,"endColumn":9},{"ruleId":"603","severity":1,"message":"740","line":26,"column":3,"nodeType":"605","messageId":"606","endLine":26,"endColumn":7},{"ruleId":"603","severity":1,"message":"617","line":393,"column":21,"nodeType":"605","messageId":"606","endLine":393,"endColumn":24},{"ruleId":"603","severity":1,"message":"741","line":959,"column":29,"nodeType":"605","messageId":"606","endLine":959,"endColumn":34},{"ruleId":"603","severity":1,"message":"742","line":959,"column":36,"nodeType":"605","messageId":"606","endLine":959,"endColumn":45},{"ruleId":"603","severity":1,"message":"614","line":227,"column":25,"nodeType":"605","messageId":"606","endLine":227,"endColumn":41},{"ruleId":"603","severity":1,"message":"615","line":227,"column":43,"nodeType":"605","messageId":"606","endLine":227,"endColumn":59},"no-unused-vars","'combineReducers' is defined but never used.","Identifier","unusedVar","'prev_palette' is assigned a value but never used.","'event' is defined but never used.","'TooltipProps' is defined but never used.","'Component' is defined but never used.","'useState' is defined but never used.","'connect' is defined but never used.","'$elem' is assigned a value but never used.","'nextProps' is defined but never used.","'nextState' is defined but never used.","'data' is defined but never used.","'opt' is defined but never used.","'mac' is defined but never used.","'pageInfo' is defined but never used.","'arg' is defined but never used.","'resolve' is defined but never used.","'FOLDER_ID' is assigned a value but never used.","no-self-assign","'folderId' is assigned to itself.","selfAssignment","'resp' is defined but never used.","'BLUEPRINT' is defined but never used.","'ANDROID_STYLE' is defined but never used.","'IPHONE_STYLE' is defined but never used.","'live' is defined but never used.","'play' is defined but never used.","'stop' is defined but never used.","'pause' is defined but never used.","'rewind' is defined but never used.","'trackRewind' is defined but never used.","'setAutoStop' is defined but never used.","'unsetAutoStop' is defined but never used.","'opt' is assigned a value but never used.","'setPageNo' is assigned a value but never used.","'PEN' is defined but never used.","'ERASER' is defined but never used.","'PLAYER' is defined but never used.","'STYLUS' is defined but never used.","'FSIR' is defined but never used.","'NONE' is defined but never used.","'PEN_DOWN' is defined but never used.","'PEN_MOVE' is defined but never used.","'PEN_UP' is defined but never used.","'HOVER_MOVE' is defined but never used.","'ON_PEN_DOWN' is defined but never used.","'ON_PEN_PAGEINFO' is defined but never used.","'ON_PEN_HOVER_PAGEINFO' is defined but never used.","'ON_PEN_MOVE' is defined but never used.","'ON_PEN_UP' is defined but never used.","'ON_HOVER_MOVE' is defined but never used.","'ON_NCODE_ERROR' is defined but never used.","'ON_PW_REQUIRED' is defined but never used.","'ON_CONNECTED' is defined but never used.","'ON_DISCONNECTED' is defined but never used.","'ON_UPGRADE_NEEDED' is defined but never used.","'MARKER' is defined but never used.","'PENCIL' is defined but never used.","'BRUSH' is defined but never used.","'FOUNTAINPEN' is defined but never used.","'IPrintingProgress' is defined but never used.","'IPrintOption' is defined but never used.","'FormControlLabel' is defined but never used.","'Switch' is defined but never used.","'e' is defined but never used.","'performClick_old' is defined but never used.","'paths' is assigned a value but never used.","@typescript-eslint/no-inferrable-types","Type string trivially inferred from a string literal, remove type annotation.","ClassProperty","noInferrableType",{"range":"743","text":"744"},"'prevProps' is defined but never used.","'prevState' is defined but never used.","'maxWidthType' is defined but never used.","'pageNo' is assigned a value but never used.","'handleSave' is assigned a value but never used.","'onChange' is assigned a value but never used.","'pt0_nu' is assigned a value but never used.","'pt1_nu' is assigned a value but never used.","'st' is assigned a value but never used.","'ret' is assigned a value but never used.","'imageChanged' is assigned a value but never used.","'zoom' is defined but never used.","'F121' is defined but never used.","'F120' is defined but never used.","'F51' is defined but never used.","'F50' is defined but never used.","'F30' is defined but never used.","'E100' is defined but never used.","'E101' is defined but never used.","'X100' is defined but never used.","'DEVICE_STATE' is defined but never used.","'disconnected' is defined but never used.","'connecting' is defined but never used.","'connected' is defined but never used.","'buf' is defined but never used.","AssignmentPattern",{"range":"745","text":"744"},"prefer-const","'rotation' is never reassigned. Use 'const' instead.","useConst","'PDF_VIEWPORT_DESC' is defined but never used.","@typescript-eslint/no-extra-semi","Unnecessary semicolon.","EmptyStatement","unexpected",{"range":"746","text":"747"},"'pdf' is defined but never used.","'IPdfPageDesc' is defined but never used.","'IPageSOBP' is defined but never used.","'IPdfDocDesc' is defined but never used.","Type boolean trivially inferred from a boolean literal, remove type annotation.",{"range":"748","text":"744"},"no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn",{"range":"749","text":"744"},{"range":"750","text":"744"},{"range":"751","text":"744"},{"range":"752","text":"744"},{"range":"753","text":"744"},{"range":"754","text":"744"},"'srcMapped' is defined but never used.",{"range":"755","text":"744"},{"range":"756","text":"744"},{"range":"757","text":"744"},"no-async-promise-executor","Promise executor functions should not be async.","async","'reject' is defined but never used.","'ACTUAL' is defined but never used.","'WIDTH' is defined but never used.","'HEIGHT' is defined but never used.","'FULL' is defined but never used.","'scale' is defined but never used.","'startTime' is defined but never used.",[1135,1143],"",[64,72],[588,598],"}\r\n\r\ntype",[951,960],[3047,3056],[3542,3551],[3706,3715],[3848,3857],[4007,4016],[4168,4177],[11887,11896],[13163,13172],[285,293]]