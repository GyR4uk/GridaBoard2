[{"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\index.js":"1","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\serviceWorker.js":"2","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\client\\Root.js":"3","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\shared\\App.js":"4","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\theme.js":"5","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\rootReducer.ts":"6","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\pointerTracer.js":"7","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\authorization.js":"8","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\ui.js":"9","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\index.js":"10","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Post.js":"11","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Posts.js":"12","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\About.js":"13","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Home.tsx":"14","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\InkStorage.ts":"15","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\UpperNav.tsx":"16","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PrintButton.tsx":"17","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\CalibrationMenual.tsx":"18","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\FileLoad.tsx":"19","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\TracePointButton.tsx":"20","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FullScreenButton.tsx":"21","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ZoomButton.tsx":"22","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\RotateButton.tsx":"23","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PageNumbering.tsx":"24","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\BackgroundButton.tsx":"25","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FitButton.tsx":"26","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\ColorButtons.tsx":"27","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ConnectButton.tsx":"28","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\PenTypeButton.tsx":"29","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\index.js":"30","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\index.ts":"31","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\EventSystem.ts":"32","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\PenManager.ts":"33","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\constants.js":"34","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\UtilsFunc.ts":"35","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\ThemeManager.ts":"36","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\neosmartpen.ts":"37","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\PaperInfo.ts":"38","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\NoteserverClient.ts":"39","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderer.js":"40","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\MixedPageView.tsx":"41","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\types\\index.js":"42","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\DefaultOption.ts":"43","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintDataTypes.ts":"44","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Locales\\i18n.ts":"45","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderer.tsx":"46","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\Upload.js":"47","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\CanvasColorConverter.ts":"48","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\index.ts":"49","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\RenderWorkerBase.tsx":"50","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Save\\SavePdf.tsx":"51","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowserButton.tsx":"52","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PdfPrintButton.tsx":"53","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationButton.tsx":"54","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\Enums.ts":"55","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\JsUtils.js":"56","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\Modal\\PrintOptionDialog.tsx":"57","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\index.ts":"58","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoDot.ts":"59","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\NeoPdfViewer.tsx":"60","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfManager.ts":"61","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoStroke.ts":"62","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderWorker.js":"63","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\DrawCurves.ts":"64","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm.ts":"65","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowser.tsx":"66","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderWorker.tsx":"67","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintPdfMain.tsx":"68","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationDialog.tsx":"69","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_event.ts":"70","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfDocument.ts":"71","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_const.ts":"72","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pen_util_func.ts":"73","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\Page.tsx":"74","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_enum.ts":"75","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_base.ts":"76","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\UtilFunc.ts":"77","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceSplitter.ts":"78","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PagesForPrint.tsx":"79","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageOrientation.jsx":"80","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingItem.ts":"81","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingStorage.ts":"82","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfPage.ts":"83","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\DataStructure\\Structures.ts":"84","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\index.ts":"85","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceInfo.ts":"86","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeRasterizer.tsx":"87","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageForPrint.tsx":"88","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeConstans.ts":"89","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\index.ts":"90","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeSurfaceDataJson.ts":"91","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeFetcher.ts":"92","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\index.ts":"93","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\DataTypes.ts":"94","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\CoordinateTanslater.ts":"95","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\SolveTransform.ts":"96","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\EchelonMatrix.ts":"97","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\GaussianElimination.ts":"98"},{"size":829,"mtime":1607317176919,"results":"99","hashOfConfig":"100"},{"size":5227,"mtime":1607317176967,"results":"101","hashOfConfig":"100"},{"size":930,"mtime":1607317176722,"results":"102","hashOfConfig":"100"},{"size":660,"mtime":1607317176968,"results":"103","hashOfConfig":"100"},{"size":1203,"mtime":1607317176984,"results":"104","hashOfConfig":"100"},{"size":402,"mtime":1607317176975,"results":"105","hashOfConfig":"100"},{"size":530,"mtime":1607317176974,"results":"106","hashOfConfig":"100"},{"size":1129,"mtime":1607319735934,"results":"107","hashOfConfig":"100"},{"size":4388,"mtime":1607317176975,"results":"108","hashOfConfig":"100"},{"size":176,"mtime":1607317176965,"results":"109","hashOfConfig":"100"},{"size":139,"mtime":1607317176964,"results":"110","hashOfConfig":"100"},{"size":822,"mtime":1607317176964,"results":"111","hashOfConfig":"100"},{"size":303,"mtime":1607317176962,"results":"112","hashOfConfig":"100"},{"size":9307,"mtime":1607329237452,"results":"113","hashOfConfig":"100"},{"size":9839,"mtime":1607324815358,"results":"114","hashOfConfig":"100"},{"size":690,"mtime":1607317176737,"results":"115","hashOfConfig":"100"},{"size":736,"mtime":1607319611270,"results":"116","hashOfConfig":"100"},{"size":725,"mtime":1607317176731,"results":"117","hashOfConfig":"100"},{"size":1497,"mtime":1607322959888,"results":"118","hashOfConfig":"100"},{"size":1736,"mtime":1607329131062,"results":"119","hashOfConfig":"100"},{"size":1594,"mtime":1607329130893,"results":"120","hashOfConfig":"100"},{"size":881,"mtime":1607329130902,"results":"121","hashOfConfig":"100"},{"size":1895,"mtime":1607329130897,"results":"122","hashOfConfig":"100"},{"size":2848,"mtime":1607322959883,"results":"123","hashOfConfig":"100"},{"size":3463,"mtime":1607329130889,"results":"124","hashOfConfig":"100"},{"size":4150,"mtime":1607322959915,"results":"125","hashOfConfig":"100"},{"size":8836,"mtime":1607322959894,"results":"126","hashOfConfig":"100"},{"size":3031,"mtime":1607323040341,"results":"127","hashOfConfig":"100"},{"size":11766,"mtime":1607322959907,"results":"128","hashOfConfig":"100"},{"size":1445,"mtime":1607317176925,"results":"129","hashOfConfig":"100"},{"size":808,"mtime":1607318826548,"results":"130","hashOfConfig":"100"},{"size":3336,"mtime":1607324316034,"results":"131","hashOfConfig":"100"},{"size":7539,"mtime":1607324316034,"results":"132","hashOfConfig":"100"},{"size":854,"mtime":1607317176925,"results":"133","hashOfConfig":"100"},{"size":2991,"mtime":1607317176961,"results":"134","hashOfConfig":"100"},{"size":5609,"mtime":1607327712869,"results":"135","hashOfConfig":"100"},{"size":15065,"mtime":1607324815358,"results":"136","hashOfConfig":"100"},{"size":6464,"mtime":1607323506473,"results":"137","hashOfConfig":"100"},{"size":5612,"mtime":1607324337388,"results":"138","hashOfConfig":"100"},{"size":13278,"mtime":1607326024058,"results":"139","hashOfConfig":"100"},{"size":4039,"mtime":1607326702179,"results":"140","hashOfConfig":"100"},{"size":24,"mtime":1607317594439,"results":"141","hashOfConfig":"100"},{"size":870,"mtime":1607317176690,"results":"142","hashOfConfig":"100"},{"size":2522,"mtime":1607318820677,"results":"143","hashOfConfig":"100"},{"size":1201,"mtime":1607317176689,"results":"144","hashOfConfig":"100"},{"size":13245,"mtime":1607324900196,"results":"145","hashOfConfig":"100"},{"size":9443,"mtime":1607328785310,"results":"146","hashOfConfig":"100"},{"size":3185,"mtime":1607317176701,"results":"147","hashOfConfig":"100"},{"size":271,"mtime":1607317176924,"results":"148","hashOfConfig":"100"},{"size":18529,"mtime":1607325511556,"results":"149","hashOfConfig":"100"},{"size":1408,"mtime":1607327812175,"results":"150","hashOfConfig":"100"},{"size":1492,"mtime":1607318826548,"results":"151","hashOfConfig":"100"},{"size":7837,"mtime":1607317176696,"results":"152","hashOfConfig":"100"},{"size":1156,"mtime":1607317176716,"results":"153","hashOfConfig":"100"},{"size":863,"mtime":1607323077606,"results":"154","hashOfConfig":"100"},{"size":286,"mtime":1607317176960,"results":"155","hashOfConfig":"100"},{"size":15313,"mtime":1607317176692,"results":"156","hashOfConfig":"100"},{"size":62,"mtime":1607317176937,"results":"157","hashOfConfig":"100"},{"size":528,"mtime":1607317176922,"results":"158","hashOfConfig":"100"},{"size":2898,"mtime":1607326540067,"results":"159","hashOfConfig":"100"},{"size":2396,"mtime":1607317176711,"results":"160","hashOfConfig":"100"},{"size":2645,"mtime":1607323506478,"results":"161","hashOfConfig":"100"},{"size":31295,"mtime":1607326540067,"results":"162","hashOfConfig":"100"},{"size":7529,"mtime":1607324815358,"results":"163","hashOfConfig":"100"},{"size":28941,"mtime":1607324178359,"results":"164","hashOfConfig":"100"},{"size":2599,"mtime":1607317176709,"results":"165","hashOfConfig":"100"},{"size":14814,"mtime":1607325076022,"results":"166","hashOfConfig":"100"},{"size":8496,"mtime":1607317176698,"results":"167","hashOfConfig":"100"},{"size":5823,"mtime":1607329052826,"results":"168","hashOfConfig":"100"},{"size":1813,"mtime":1607324178360,"results":"169","hashOfConfig":"100"},{"size":8000,"mtime":1607327818962,"results":"170","hashOfConfig":"100"},{"size":513,"mtime":1607317176933,"results":"171","hashOfConfig":"100"},{"size":1404,"mtime":1607317176930,"results":"172","hashOfConfig":"100"},{"size":7184,"mtime":1607326256460,"results":"173","hashOfConfig":"100"},{"size":461,"mtime":1607323792452,"results":"174","hashOfConfig":"100"},{"size":9241,"mtime":1607323753733,"results":"175","hashOfConfig":"100"},{"size":739,"mtime":1607317176699,"results":"176","hashOfConfig":"100"},{"size":6983,"mtime":1607317176707,"results":"177","hashOfConfig":"100"},{"size":3510,"mtime":1607327666928,"results":"178","hashOfConfig":"100"},{"size":322,"mtime":1607317176694,"results":"179","hashOfConfig":"100"},{"size":2343,"mtime":1607317176718,"results":"180","hashOfConfig":"100"},{"size":4732,"mtime":1607327801868,"results":"181","hashOfConfig":"100"},{"size":4369,"mtime":1607317176712,"results":"182","hashOfConfig":"100"},{"size":3704,"mtime":1607317176685,"results":"183","hashOfConfig":"100"},{"size":27,"mtime":1607317176700,"results":"184","hashOfConfig":"100"},{"size":4656,"mtime":1607317176706,"results":"185","hashOfConfig":"100"},{"size":19815,"mtime":1607327835834,"results":"186","hashOfConfig":"100"},{"size":15371,"mtime":1607327081604,"results":"187","hashOfConfig":"100"},{"size":905,"mtime":1607317176702,"results":"188","hashOfConfig":"100"},{"size":120,"mtime":1607317176683,"results":"189","hashOfConfig":"100"},{"size":2644,"mtime":1607317176705,"results":"190","hashOfConfig":"100"},{"size":3610,"mtime":1607317176703,"results":"191","hashOfConfig":"100"},{"size":220,"mtime":1607317176708,"results":"192","hashOfConfig":"100"},{"size":3007,"mtime":1607317176679,"results":"193","hashOfConfig":"100"},{"size":7210,"mtime":1607317176679,"results":"194","hashOfConfig":"100"},{"size":3925,"mtime":1607317176682,"results":"195","hashOfConfig":"100"},{"size":1068,"mtime":1607317176680,"results":"196","hashOfConfig":"100"},{"size":2144,"mtime":1607317176681,"results":"197","hashOfConfig":"100"},{"filePath":"198","messages":"199","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"zrql4f",{"filePath":"200","messages":"201","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"202","messages":"203","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"204","messages":"205","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"206","messages":"207","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"208","messages":"209","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"210","messages":"211","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"212","messages":"213","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"214","messages":"215","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"216","messages":"217","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"218","messages":"219","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"220","messages":"221","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"222","messages":"223","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"224","messages":"225","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":6,"source":null},{"filePath":"226","messages":"227","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"229","messages":"230","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"231","messages":"232","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"233","messages":"234","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"235","messages":"236","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"237","messages":"238","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":4,"source":"239","usedDeprecatedRules":"228"},{"filePath":"240","messages":"241","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"242","messages":"243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"244","messages":"245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"246","messages":"247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"248","messages":"249","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"250","messages":"251","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"252","messages":"253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"256","messages":"257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"260"},{"filePath":"261","messages":"262","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"263","messages":"264","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"265","messages":"266","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"267","messages":"268","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"260"},{"filePath":"269","messages":"270","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":4,"source":"271","usedDeprecatedRules":"228"},{"filePath":"272","messages":"273","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":9,"source":null},{"filePath":"274","messages":"275","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"276","messages":"277","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"278","messages":"279","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"280","messages":"281","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":11,"source":"282","usedDeprecatedRules":"260"},{"filePath":"283","messages":"284","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"285","usedDeprecatedRules":"228"},{"filePath":"286","messages":"287","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"260"},{"filePath":"288","messages":"289","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"290","messages":"291","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"292","messages":"293","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"294","messages":"295","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"296","messages":"297","errorCount":0,"warningCount":36,"fixableErrorCount":0,"fixableWarningCount":35,"source":"298","usedDeprecatedRules":"260"},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"301","messages":"302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"303","messages":"304","errorCount":0,"warningCount":44,"fixableErrorCount":0,"fixableWarningCount":44,"source":"305","usedDeprecatedRules":"228"},{"filePath":"306","messages":"307","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"308","usedDeprecatedRules":"228"},{"filePath":"309","messages":"310","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"311","messages":"312","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"313","usedDeprecatedRules":"228"},{"filePath":"314","messages":"315","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"316","messages":"317","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"260"},{"filePath":"320","messages":"321","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"322","messages":"323","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"324","messages":"325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"328","usedDeprecatedRules":"228"},{"filePath":"329","messages":"330","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"331","messages":"332","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"333","messages":"334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"260"},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"337","messages":"338","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"339","messages":"340","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"341","messages":"342","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"343","messages":"344","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"345","messages":"346","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"347","messages":"348","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"349","messages":"350","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"351","usedDeprecatedRules":"228"},{"filePath":"352","messages":"353","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"354","messages":"355","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"356","messages":"357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"358","messages":"359","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"360","messages":"361","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"362","messages":"363","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"364","usedDeprecatedRules":"228"},{"filePath":"365","messages":"366","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"367","usedDeprecatedRules":"228"},{"filePath":"368","messages":"369","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"370","messages":"371","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"260"},{"filePath":"372","messages":"373","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"374","messages":"375","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":3,"source":"376","usedDeprecatedRules":"228"},{"filePath":"377","messages":"378","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"379","usedDeprecatedRules":"228"},{"filePath":"380","messages":"381","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"382","messages":"383","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"384","messages":"385","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"386","usedDeprecatedRules":"228"},{"filePath":"387","messages":"388","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":8,"source":"389","usedDeprecatedRules":"228"},{"filePath":"390","messages":"391","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"392","messages":"393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"398","messages":"399","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"400","usedDeprecatedRules":"228"},{"filePath":"401","messages":"402","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"403","messages":"404","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"405","messages":"406","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"407","usedDeprecatedRules":"228"},{"filePath":"408","messages":"409","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":2,"source":"410","usedDeprecatedRules":"228"},{"filePath":"411","messages":"412","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"228"},{"filePath":"413","messages":"414","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\index.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\serviceWorker.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\client\\Root.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\shared\\App.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\theme.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\rootReducer.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\pointerTracer.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\authorization.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\store\\reducers\\ui.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\index.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Post.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Posts.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\About.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\pages\\Home.tsx",["415","416","417","418","419","420"],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\InkStorage.ts",[],[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\UpperNav.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PrintButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\CalibrationMenual.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\FileLoad.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\TracePointButton.tsx",["421","422","423","424"],"import React, { Component, useState } from \"react\";\r\nimport '../../styles/buttons.css';\r\nimport { connect, useSelector, useDispatch } from 'react-redux';\r\nimport { setPointerTracer } from '../../store/reducers/pointerTracer';\r\nimport jQuery from \"jquery\";\r\nimport { RootState } from '../../store/rootReducer';\r\n\r\nimport icon_point_d from \"../../icons/icon_point_d.png\";\r\nimport icon_point_p from \"../../icons/icon_point_p.png\";\r\nimport icon_point_n from \"../../icons/icon_point_n.png\";\r\n\r\nlet $ = jQuery;\r\n\r\nconst TracePointButton = () => {\r\n  const isTrace = useSelector((state:RootState) => state.pointerTracer.isTrace)\r\n  const dispatch = useDispatch();\r\n\r\n  const setEnable = (elem_name: string, sw: boolean) => {\r\n    let $elem = $(`#${elem_name}`);\r\n    if (sw) {\r\n        let $elem = $(\"#btn_tracepoint\").find(\".c2\");\r\n        $elem.addClass(\"checked\");\r\n    } else {\r\n        let $elem = $(\"#btn_tracepoint\").find(\".c2\");\r\n        $elem.removeClass(\"checked\");\r\n    }\r\n  }\r\n  \r\n  const onTogglePointerTracer = () => {\r\n    dispatch(setPointerTracer(!isTrace));\r\n    setEnable(\"btn_tracepoint\", isTrace);\r\n  }\r\n\r\n    return (\r\n      <button id=\"btn_tracepoint\" type=\"button\" className=\"btn btn-neo btn-neo-vertical\" title=\"Trace Point\"\r\n      onClick = {() => onTogglePointerTracer()}>\r\n          <div className=\"c2 checked\">\r\n              <img src={icon_point_d} className=\"toggle-off normal-image\"></img>\r\n              <img src={icon_point_p} className=\"toggle-off hover-image\"></img>\r\n              <img src={icon_point_n} className=\"toggle-on normal-image\"></img>\r\n              <img src={icon_point_p} className=\"toggle-on hover-image\"></img>\r\n          </div>\r\n      </button>\r\n    );\r\n}\r\nexport default TracePointButton;","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FullScreenButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ZoomButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\RotateButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\PageNumbering.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\BackgroundButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\FitButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\ColorButtons.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\ConnectButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\buttons\\PenTypeButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\index.js",[],[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\EventSystem.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\PenManager.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\constants.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\UtilsFunc.ts",["425","426","427","428","429"],"import { backingStoreRatio } from \"./JsUtils\";\r\nimport * as CONST from \"../constants\";\r\nimport { IPageSOBP } from \"../DataStructure/Structures\";\r\nexport { backingStoreRatio };\r\n\r\n\r\n/**\r\n * @return {string} - uuid\r\n */\r\nexport function uuidv4(): string {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    // let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n    let r = Math.random() * 16 | 0, v = c === 'x' ? r : ((r & 0x3) | 0x8);\r\n    return v.toString(16);\r\n  });\r\n}\r\n\r\nexport function getDisplayRatio(): number {\r\n  let dpr = window.devicePixelRatio || 1;\r\n  return dpr;\r\n}\r\n\r\nexport function scaleCanvas(canvas: HTMLCanvasElement) {\r\n  const context = canvas.getContext('2d');\r\n\r\n  // Get the device pixel ratio, falling back to 1.\r\n  let dpr = window.devicePixelRatio || 1;\r\n  // Get the size of the canvas in CSS pixels.\r\n  let rect = canvas.getBoundingClientRect();\r\n  const { width, height } = rect;\r\n\r\n  // determine the actual ratio we want to draw at\r\n  const ratio = dpr / backingStoreRatio(context);\r\n\r\n  // Give the canvas pixel dimensions of their CSS\r\n  // size * the device pixel ratio.\r\n  canvas.width = rect.width * ratio;\r\n  canvas.height = rect.height * ratio;\r\n  // Scale all drawing operations by the dpr, so you\r\n  // don't have to worry about the difference.\r\n\r\n\r\n  if (devicePixelRatio !== backingStoreRatio(context)) {\r\n    // set the 'real' canvas size to the higher width/height\r\n    canvas.width = width * ratio;\r\n    canvas.height = height * ratio;\r\n\r\n    // ...then scale it back down with CSS\r\n    canvas.style.width = width + 'px';\r\n    canvas.style.height = height + 'px';\r\n  }\r\n  else {\r\n    // this is a normal 1:1 device; just scale it simply\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    canvas.style.width = '';\r\n    canvas.style.height = '';\r\n  }\r\n\r\n  // scale the drawing context so everything will work at the higher ratio\r\n  context.scale(ratio, ratio);\r\n}\r\n\r\n\r\nexport function ncodeToInch(n: number): number {\r\n  return n * CONST.NCODE_TO_INCH_SCALE;\r\n}\r\n\r\nexport function ncodeToDisplayPixel(n: number): number {\r\n  return n * CONST.NCODE_TO_INCH_SCALE * CONST.DISPLAY_DEFAULT_DPI * getDisplayRatio();\r\n}\r\n\r\n\r\n\r\nexport function pdfSizeUnitToInch(n: number): number {\r\n  // 72 DPI\r\n  return n * CONST.PDF_SCALE_TO_INCH;\r\n}\r\n\r\nexport function pdfSizeUnitToDIsplayPixel(n: number): number {\r\n  return n * CONST.PDF_SCALE_TO_INCH * CONST.DISPLAY_DEFAULT_DPI * getDisplayRatio();\r\n}\r\n\r\n\r\nexport function pdfSizeToDIsplayPixel(sz: { width: number, height: number }): { width: number, height: number } {\r\n  return {\r\n    width: pdfSizeUnitToDIsplayPixel(sz.width),\r\n    height: pdfSizeUnitToDIsplayPixel(sz.height),\r\n  };\r\n}\r\n\r\n\r\nexport function isSamePage(page1: IPageSOBP, page2: IPageSOBP): boolean {\r\n  if (page1.page !== page2.page || page1.book !== page2.book || page1.owner !== page2.owner || page1.section !== page2.section) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\styles\\ThemeManager.ts",["430","431","432","433","434","435","436","437","438"],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\neosmartpen.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\PaperInfo.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\noteserver\\NoteserverClient.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderer.js",["439","440","441","442","443","444","445","446","447","448","449","450","451","452"],"import React from \"react\";\r\n// import React, { Component } from 'react';\r\nimport PropTypes from \"prop-types\";\r\nimport { InkStorage, PenEventName } from \"../..\";\r\n\r\nimport StorageRenderWorker, { ZoomFitEnum } from \"./StorageRenderWorker\";\r\n// import { Paper } from \"@material-ui/core\";\r\nimport {  PenManager } from \"../../index\";\r\nimport { uuidv4 } from \"../../utils/UtilsFunc\";\r\nimport { PLAYSTATE } from \"./RenderWorkerBase\";\r\n\r\n\r\n/**\r\n * 스토리지와 자동으로 연결되는 renderer \r\n * TO DO: 2020/11/05\r\n *    1)  현재는 연결된 모든 펜들의 stroke가 나오게 되어 있는데, \r\n *        pen의 ID로 filtering할 수 있도록 property를 넣을 수 있게 할 것\r\n * \r\n *    2)  본 컴포는트는 Storage에서 Event를 받아 rendering하는 것이므로,\r\n *        Pen에서 realtime으로 event를 받아 rendering하는 별도의 component를 만들 것\r\n */\r\nclass StorageRenderer extends React.Component {\r\n  state = {\r\n    /** @type {StorageRenderWorker} */\r\n    renderer: null,\r\n    pageId: \"\",\r\n\r\n    // rect: {\r\n    //   x: 0,\r\n    //   y: 0,\r\n    //   width: 88.58 * 8 / 600 * 72,\r\n    //   height: 125.28 * 8 / 600 * 72,\r\n    // },\r\n    sizeUpdate: 0,\r\n\r\n    penEventCount: 0,\r\n    strokeCount: 0,\r\n    liveDotCount: 0,\r\n\r\n    pageInfo: {\r\n      section: -1,\r\n      owner: -1,\r\n      book: -1,\r\n      page: -1,\r\n    },\r\n\r\n    viewFit: ZoomFitEnum.WIDTH,\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    // kitty\r\n    this.canvasRef = React.createRef();\r\n    this.myRef = React.createRef();\r\n\r\n    /** @type {{pageId:number, inkStorage:InkStorage, scale:number, playState:number }} */\r\n    let { pageId, inkStorage, scale, playState } = props;\r\n\r\n    if (!inkStorage) {\r\n      inkStorage = InkStorage.getInstance();\r\n    }\r\n\r\n    this.inkStorage = inkStorage;\r\n\r\n    this.state = {\r\n      pageId,\r\n      scale,\r\n      playState,\r\n      ...this.state\r\n    };\r\n\r\n    // // 실시간 데이터 전송을 위해, penStorage와 view를 연결한다.\r\n    if (this.inkStorage) {\r\n      let filter = { mac: null };\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this), filter);\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this), filter);\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this), filter);\r\n      inkStorage.addEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this), filter);\r\n    }\r\n\r\n    this.canvasId = uuidv4();\r\n  }\r\n\r\n\r\n  /**\r\n   * @public\r\n   * @param {NeoSmartpen} pen \r\n   */\r\n  listenPenEvent(pen) {\r\n    pen.addEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this));\r\n    pen.addEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this));\r\n    pen.addEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this));\r\n    pen.addEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this));\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * @param {NeoSmartpen} pen \r\n   */\r\n  ignorePenEvent(pen) {\r\n    pen.removeEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this));\r\n    pen.removeEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this));\r\n    pen.removeEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this));\r\n    pen.removeEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this));\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, time:number, stroke:NeoStroke}} event \r\n   */\r\n  onLivePenDown = (event) => {\r\n    // console.log(event);\r\n    if (this.state.renderer) {\r\n      this.state.renderer.createLiveStroke(event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, section:number, owner:number, book:number, page:number}} event \r\n   */\r\n  onLivePenPageInfo = (event) => {\r\n    const { penEventCount } = this.state;\r\n    const { section, owner, book, page } = event;\r\n\r\n    this.setState({\r\n      penEventCount: penEventCount + 1,\r\n      pageInfo: { section, owner, book, page }\r\n    });\r\n\r\n    const inkStorage = this.inkStorage;\r\n    if (inkStorage) {\r\n      let pageStrokesCount = inkStorage.getPageStrokes(event).length;\r\n      this.setState({ strokeCount: pageStrokesCount });\r\n    }\r\n\r\n    if (this.state.renderer) {\r\n      this.state.renderer.changePage(section, owner, book, page, false);\r\n    }\r\n    // console.log(event);\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke:NeoStroke, dot:NeoDot}} event \r\n   */\r\n\r\n  onLivePenMove = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.pushLiveDot(event);\r\n    }\r\n    // const { liveDotCount } = this.state;\r\n\r\n    // this.setState({ liveDotCount: liveDotCount + 1 });\r\n    // console.log(event);\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {{strokeKey:string, mac:string, stroke, section:number, owner:number, book:number, page:number}} event \r\n   */\r\n  onLivePenUp = (event) => {\r\n    if (this.state.renderer) {\r\n      this.state.renderer.closeLiveStroke(event);\r\n    }\r\n\r\n    // const { penEventCount, inkStorage } = this.state;\r\n    // this.setState({ penEventCount: penEventCount + 1 });\r\n    // if (inkStorage) {\r\n    //   let pageStrokesCount = inkStorage.getPageStrokes(event).length;\r\n    //   this.setState({ strokeCount: pageStrokesCount });\r\n    // }\r\n    // console.log(event);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @return {{section:number, owner:number, book:number, page:number}}\r\n   */\r\n  getPageIdNumbers() {\r\n    /** @type {Array.<string>} */\r\n    const numbers = this.state.pageId.split(\".\");\r\n\r\n    const section = parseInt(numbers[0]);\r\n    const owner = parseInt(numbers[1]);\r\n    const book = parseInt(numbers[2]);\r\n    const page = parseInt(numbers[3]);\r\n\r\n    return {\r\n      section, owner, book, page\r\n    }\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    let ret_val = true;\r\n\r\n    if (nextState.penEventCount !== this.state.penEventCount) {\r\n      // re-rendering strokes\r\n      // console.log(`penEventCount: ${nextState.penEventCount}`);\r\n      // this.state.renderer.redrawPage();\r\n    }\r\n\r\n\r\n    if (nextProps.isPlay !== this.props.isPlay) {\r\n      if (nextProps.stopTrigger) {\r\n        this.state.renderer.replayStop();\r\n      }\r\n      if (nextProps.rewindTrigger) {\r\n        this.state.renderer.replayRewind();\r\n      }\r\n\r\n      if (nextProps.isPlay) {\r\n        this.state.renderer.replayStart();\r\n      } else {\r\n        this.state.renderer.replayPause();\r\n      }\r\n      ret_val = false;\r\n    }\r\n\r\n    // if (nextProps.isSaveTrigger !== this.props.isSaveTrigger) {\r\n    //   this.saveCanvas();\r\n    //   return false;\r\n    // }\r\n\r\n    if (nextProps.replaySpeed !== this.props.replaySpeed) {\r\n      this.state.renderer.setReplaySpeed(nextProps.replaySpeed);\r\n      ret_val = false;\r\n    }\r\n\r\n    // if (nextProps.pageId !== this.props.pageId) {\r\n    //   const { pageId, scale } = nextProps;\r\n    //   // let bgurl = window.location.origin + \"/img/3_27_1089_\" + pageId + \".jpg\";\r\n\r\n    //   // let bg_header = EXAM_FILE_RESOURCES[tab_value].bg_img_header;\r\n    //   // let bgurl = window.location.origin + bg_header + pageId + \".jpg\";\r\n\r\n    //   // this.props.playStateHandler(PLAYSTATE.stop);\r\n    //   // this.state.renderer.replayPause();\r\n    //   // this.state.renderer.replayStop();\r\n\r\n    //   // this.state.renderer.setCanvas(this.size, bgurl);\r\n\r\n    //   let page = this.props.pages.filter((p) => p.pageNumber === pageId)[0];\r\n    //   if (page) {\r\n    //     this.state.renderer.setPage(page);\r\n    //     this.state.renderer.preparePage(\r\n    //       page,\r\n    //       this.state.rect,\r\n    //       this.size,\r\n    //       scale\r\n    //     );\r\n    //   }\r\n\r\n    //   ret_val = false;\r\n    // }\r\n\r\n    if (nextProps.playTime !== this.props.playTime) {\r\n      this.state.renderer.setTimePoint(nextProps.playTime);\r\n      ret_val = false;\r\n    }\r\n\r\n    if (nextProps.autoStop !== this.props.autoStop) {\r\n      this.state.renderer.setAutoStop(nextProps.autoStop);\r\n      ret_val = false;\r\n    }\r\n\r\n    if (nextProps.caption !== this.props.caption) {\r\n      console.log(\" caption changed \");\r\n      ret_val = false;\r\n    }\r\n\r\n    if (nextProps.stopTrigger) {\r\n      this.state.renderer.replayStop();\r\n      ret_val = false;\r\n    }\r\n\r\n    if (nextProps.rewindTrigger) {\r\n      this.state.renderer.replayRewind();\r\n      ret_val = false;\r\n    }\r\n\r\n    return ret_val;\r\n  }\r\n\r\n  initRenderer(size) {\r\n    const {\r\n      // pages,\r\n      // pageId,\r\n      scale,\r\n      playTimeHandler,\r\n      playStateHandler,\r\n      // strokeStream,\r\n      autoStop,\r\n      width,\r\n      height\r\n    } = this.props;\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    // const page = pages.filter((p) => p.pageNumber === pageId)[0];\r\n\r\n    const inkStorage = this.inkStorage;\r\n    const options = {\r\n      canvasName: this.canvasId,\r\n      storage: inkStorage,\r\n      autoStop,\r\n      playTimeHandler,\r\n      playStateHandler,\r\n      viewFit: this.state.viewFit,\r\n    };\r\n\r\n    let renderer = new StorageRenderWorker(options);\r\n\r\n    // let bg_header = EXAM_FILE_RESOURCES[tab_value].bg_img_header;\r\n    // let bgurl = window.location.origin + bg_header + pageId + \".jpg\";\r\n    // // let bgurl = window.location.origin + \"/img/3_27_1089_\" + pageId + \".jpg\";\r\n\r\n    renderer.setCanvas(size, \"\");\r\n\r\n    // renderer.setPage(page);\r\n    renderer.preparePage(rect, size, scale);\r\n    // renderer.setSeekHandeler(this.props.seekHandler);\r\n    this.setState({ renderer: renderer });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const node = this.myRef.current;\r\n    if (node) {\r\n\r\n      let parentHeight = node.offsetHeight;\r\n      let parentWidth = node.offsetWidth;\r\n\r\n      console.log(`(width, height) = (${parentHeight}, ${parentWidth})`);\r\n    }\r\n\r\n    let size = this.size;\r\n    const { pageId, width, height } = this.props;\r\n\r\n    let rect = { x: 0, y: 0, width, height };\r\n\r\n    // const page = pages.filter((p) => p.pageNumber === pageId)[0];\r\n    console.log(\"Draw Stroke size\", pageId, \"canvas size\", size, \"rect\", rect);\r\n\r\n    this.initRenderer(this.size);\r\n    window.addEventListener(\"resize\", this.resizeListener);\r\n\r\n\r\n    // penManager에 연결 \r\n    let penManager = PenManager.getInstance();\r\n    penManager.registerRenderContainer(this);\r\n  }\r\n\r\n  resizeListener = () => {\r\n    this.setState({ sizeUpdate: this.state.sizeUpdate + 1 });\r\n\r\n    // const { classes, scaleType, scale } = this.props;\r\n    const { scale, width, height } = this.props;\r\n\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    // const { penEventCount } = this.state;\r\n    this.size = this.getSize(scale, rect);\r\n\r\n    if (this.state.renderer) {\r\n      // console.log(\"render resize\", this.size)\r\n      this.state.renderer.resize(this.size);\r\n    }\r\n  };\r\n\r\n  // getSize_old = (scale, rect) => {\r\n\r\n\r\n  //   const vertical_margin = 0;\r\n  //   const horizontal_margin = 0; // left 200, right 200\r\n\r\n  //   const pageHeight = window.innerHeight - vertical_margin;\r\n  //   let h = pageHeight - 20; // for divider\r\n  //   let w = window.innerWidth - horizontal_margin;\r\n\r\n  //   h = h * scale;\r\n  //   w = (h * rect.width) / rect.height;\r\n  //   // scale to width\r\n\r\n  //   console.log(\"!!!!!!!!!\", w, h, rect.height, rect.width);\r\n  //   console.log(this);\r\n\r\n  //   let size = {\r\n  //     w: w,\r\n  //     h: h,\r\n  //   };\r\n\r\n  //   return size;\r\n  // };\r\n\r\n  getSize = (scale, rect) => {\r\n    let size = {\r\n      width: rect.width,\r\n      height: rect.height,\r\n    };\r\n\r\n    return size;\r\n  };\r\n\r\n  componentWillUnmount() {\r\n    // this.state.renderer.stopInterval();\r\n    window.removeEventListener(\"resize\", this.resizeListener);\r\n\r\n    // penManager에 연결 해제\r\n    let penManager = PenManager.getInstance();\r\n    penManager.unregisterRenderContainer(this);\r\n\r\n    // ink storage와 연결 해제\r\n        // // 실시간 데이터 전송을 위해, penStorage와 view를 연결한다.\r\n    if (this.inkStorage) {\r\n      let inkStorage = this.inkStorage;\r\n\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_DOWN, this.onLivePenDown.bind(this));\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_PAGEINFO, this.onLivePenPageInfo.bind(this));\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_MOVE, this.onLivePenMove.bind(this));\r\n      inkStorage.removeEventListener(PenEventName.ON_PEN_UP, this.onLivePenUp.bind(this));\r\n    }\r\n\r\n\r\n  }\r\n\r\n  render() {\r\n    // const { classes, scaleType, scale } = this.props;\r\n    const { scale, width, height } = this.props;\r\n    const { section, owner, book, page } = this.state.pageInfo;\r\n\r\n    const rect = { x: 0, y: 0, width, height };\r\n    // const { rect } = this.state;\r\n    const { penEventCount } = this.state;\r\n    this.size = this.getSize(scale, rect);\r\n\r\n    return (\r\n      <div id=\"replayContainer\" ref={this.myRef}>\r\n        <h1>StorageRenderer</h1><h2>{section}.{owner}.{book}.{page}:{penEventCount}</h2>\r\n          <canvas id={this.canvasId} ref={this.canvasRef} style={{ height: this.size.height, width: this.size.width }}/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// StorageRenderer.propTypes = propTypes;\r\n// StorageRenderer.defaultProps = defaultProps;\r\n\r\n// export default withStyles(styles)(StorageRenderer);\r\nexport default StorageRenderer;\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\MixedPageView.tsx",["453","454"],"import React, { CSSProperties } from \"react\";\r\nimport PenBasedRenderer, { PLAYSTATE } from \"./pageviewer/PenBasedRenderer\";\r\nimport NeoPdfViewer from \"./pdf/NeoPdfViewer\";\r\nimport { IPageSOBP } from \"../DataStructure/Structures\";\r\nimport { NeoSmartpen } from \"../pencomm/neosmartpen\";\r\nimport * as PdfJs from \"pdfjs-dist\";\r\n\r\ninterface Props {\r\n  pageInfo?: IPageSOBP;\r\n  pdfUrl: string;\r\n  pageNo: number;\r\n  pens: NeoSmartpen[];\r\n\r\n  scale: number,\r\n  playState: PLAYSTATE;\r\n}\r\n\r\ninterface State {\r\n  pageInfo: IPageSOBP;\r\n  pdfUrl: string;\r\n\r\n  /** NOTE: pageNo라고 씌어 있는 것은, 항상 PDF의 페이지번호(1부터 시작)를 나타내기로 한다.  */\r\n  pageNo: number;\r\n  canvasPosition: { offsetX: number, offsetY: number, zoom: number },\r\n\r\n  renderCount: number;\r\n}\r\n\r\nconst tempStyle: CSSProperties = {\r\n  position: \"absolute\",\r\n  // height: \"100%\",\r\n  // width: \"100%\",\r\n  left: \"0px\",\r\n  top: \"0px\",\r\n  overflow: \"hidden\",\r\n}\r\n\r\nexport default class MixedPageView extends React.Component<Props, State> {\r\n  waitingForFirstStroke = true;\r\n  pdf: PdfJs.PDFDocumentProxy;\r\n  rendererRef: React.RefObject<PenBasedRenderer> = React.createRef();\r\n\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n\r\n    let { pageInfo, pdfUrl, pageNo } = props;\r\n\r\n    if (!pageInfo) {\r\n      pageInfo = { section: -1, owner: -1, book: -1, page: -1, }\r\n    }\r\n\r\n    const canvasPosition = { offsetX: 0, offsetY: 0, zoom: 1 };\r\n    this.state = { pageInfo, pdfUrl, pageNo, canvasPosition, renderCount: 0 };\r\n  }\r\n\r\n  onReportPdfInfo = (pdf: PdfJs.PDFDocumentProxy) => {\r\n    this.pdf = pdf;\r\n  }\r\n\r\n  onNcodePageChanged = (pageInfo: IPageSOBP) => {\r\n    if (this.pdf) {\r\n      const numPages = this.pdf.numPages;\r\n\r\n      let pageDelta = 0;\r\n      if (this.waitingForFirstStroke) {\r\n        pageDelta = 0;\r\n        this.waitingForFirstStroke = false;\r\n        this.setState({ pageInfo });\r\n      }\r\n      else {\r\n        pageDelta = pageInfo.page - this.state.pageInfo.page;\r\n        pageDelta += numPages;\r\n        pageDelta = pageDelta % numPages;\r\n      }\r\n      this.setState({ pageNo: pageDelta + 1 });\r\n\r\n    }\r\n    /** 여기까지 임시 내용 */\r\n  }\r\n\r\n  onCanvasShapeChanged = (arg: { offsetX: number, offsetY: number, zoom: number }) => {\r\n    console.log(arg);\r\n    this.setState({ canvasPosition: arg });\r\n\r\n    const r = this.state.renderCount;\r\n    this.setState({ renderCount: r + 1 });\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    if (nextProps.pdfUrl !== this.props.pdfUrl) {\r\n      this.setState({ pdfUrl: nextProps.pdfUrl });\r\n      return false;\r\n    }\r\n    // console.log(\"update requested\");\r\n    return true;\r\n  }\r\n\r\n  render() {\r\n    const pdfCanvas: CSSProperties = {\r\n      position: \"absolute\",\r\n      // height: \"100%\",\r\n      // width: \"100%\",\r\n      left: this.state.canvasPosition.offsetX + \"px\",\r\n      top: this.state.canvasPosition.offsetY + \"px\",\r\n      // zoom: this.state.canvasPosition.zoom,\r\n      overflow: \"hidden\",\r\n    }\r\n\r\n    // console.log(this.state.canvasPosition);\r\n    return (\r\n      <div id={\"mixed_view\"} style={{\r\n        // position: \"absolute\",\r\n        left: \"0px\", top: \"0px\",\r\n        flexDirection: \"row-reverse\", display: \"flex\",\r\n        width: \"100%\", height: \"100%\",\r\n        alignItems: \"center\",\r\n        zIndex: 1,\r\n      }}>\r\n        <div id={\"pdf_layer\"} style={pdfCanvas}>\r\n          <NeoPdfViewer\r\n            url={this.state.pdfUrl} pageNo={this.state.pageNo} onReportPdfInfo={this.onReportPdfInfo}\r\n            position={this.state.canvasPosition}\r\n          />\r\n        </div>\r\n        <div id={\"ink_layer\"} style={tempStyle}>\r\n          <PenBasedRenderer\r\n            scale={1}\r\n            pageInfo={{ section: 0, owner: 0, book: 0, page: 0 }}\r\n            playState={PLAYSTATE.live} pens={this.props.pens}\r\n            onNcodePageChanged={this.onNcodePageChanged}\r\n            onCanvasShapeChanged={this.onCanvasShapeChanged}\r\n            ref={this.rendererRef}\r\n          />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\types\\index.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\DefaultOption.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintDataTypes.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Locales\\i18n.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderer.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\components\\navbar\\Upload.js",["455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478","479","480","481","482","483","484","485","486","487","488","489","490"],"import React from 'react';\r\nimport { gapi } from 'gapi-script';\r\nimport { GoogleLogin } from 'react-google-login';\r\nimport * as PdfJs from \"pdfjs-dist\";\r\n\r\nimport { resolve } from 'path';\r\n\r\nlet FOLDER_ID = \"root\";\r\n\r\nexport default class Upload extends React.Component {\r\n  \r\n  mappingInfoUploadProcess = async () => {\r\n    let self = this;\r\n    let folderId;\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', async function () {\r\n        const folderResponse = await gapi.client.drive.files.list({\r\n          q: \"mimeType = 'application/vnd.google-apps.folder'\" //폴더만 걸러주는 filter\r\n        })\r\n\r\n        let folders = folderResponse.result.items;\r\n        let isGridaFolderExist = false;\r\n\r\n        if (folders && folders.length > 0) {\r\n          for (let i = 0; i < folders.length; i++) {\r\n            let folder = folders[i];\r\n            if (folder.title === 'Grida') {\r\n              isGridaFolderExist = true;\r\n              folderId = folderId;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (isGridaFolderExist) {\r\n          //mappingInfo.json 있는지 확인 후 없으면\r\n          const fileResponse = await gapi.client.drive.files.list();\r\n          let files = fileResponse.result.items;\r\n          let isMappingFileExist = false;\r\n          if (files && files.length > 0) {\r\n            for (let i = 0; i < files.length; i++) {\r\n              let file = files[i];\r\n              if (file.title === 'mappingInfo.json') {\r\n                let fileId = file.id;\r\n                let getFileRequest = gapi.client.drive.files.get({\r\n                  fileId: fileId,\r\n                  alt: 'media'\r\n                })\r\n                let content = `\r\n                  {\"sobp\" : {\"s\":3,\"o\":281,\"b\":123,\"p\":2},\r\n                   \"pdf_info\" : {\"file_name\" : \"filename\",\"fp\" : \"finger print\"}\r\n                  }\r\n                `; //여기에다가 새로운 content 내용을 받을거야\r\n                getFileRequest.then(await function(response) {\r\n\r\n                  let currentMappingObj = JSON.parse(response.body);\r\n                  let newMappingObj = JSON.parse(content);\r\n\r\n                  currentMappingObj.mapping_info.push(newMappingObj);\r\n                  \r\n                  content = JSON.stringify(currentMappingObj);\r\n                  \r\n                  let contentBlob = new Blob([content], {'type': 'application/json'});\r\n                  self.updateMappingInfo(fileId, contentBlob, function(resp) {\r\n                  });\r\n                }, function(error) {\r\n                  console.error(error)\r\n                })\r\n                isMappingFileExist = true;\r\n                break;\r\n              } \r\n              if (!isMappingFileExist) {\r\n                self.createNewMappingInfo(folderId);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        else if (!isGridaFolderExist) {\r\n          await self.createGridaFolder();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  updateMappingInfo = (fileId, contentBlob, callback) => {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.responseType = 'json';\r\n    xhr.onreadystatechange = function() {\r\n      if (xhr.readyState != XMLHttpRequest.DONE) {\r\n        return;\r\n      }\r\n      callback(xhr.response);\r\n    };\r\n    xhr.open('PATCH', 'https://www.googleapis.com/upload/drive/v3/files/' + fileId + '?uploadType=media');\r\n    xhr.setRequestHeader('Authorization', 'Bearer ' + gapi.auth.getToken().access_token);\r\n    xhr.send(contentBlob);\r\n  }\r\n\r\n  createNewMappingInfo = async (folderId) => {\r\n    let fileContent = `\r\n    {\"mapping_info\":[\r\n      {\"sobp\" : {\"s\":3,\"o\":281,\"b\":123,\"p\":1},\r\n       \"pdf_info\" : {\"file_name\" : \"filename\",\"fp\" : \"finger print\"}\r\n      }\r\n    ]}`; //sobp object와 pdf info를 object로 받아서 stringfy해준 뒤 fileContent에 삽입\r\n    let file = new Blob([fileContent], {type: 'text/plain'});\r\n    let metadata = {\r\n        'name': 'mappingInfo.json', // Filename at Google Drive\r\n        'mimeType': 'application/json', // mimeType at Google Drive\r\n        'parents': [folderId], // Folder ID at Google Drive\r\n    };\r\n    \r\n    let accessToken = gapi.auth.getToken().access_token; // Here gapi is used for retrieving the access token.\r\n\r\n    let form = new FormData();\r\n    form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));\r\n    form.append('file', file);\r\n    \r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('post', 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id');\r\n    xhr.setRequestHeader('Authorization', 'Bearer ' + accessToken);\r\n    xhr.responseType = 'json';\r\n    xhr.onload = () => {\r\n        console.log('mapping info file id : ');\r\n        console.log(xhr.response.id); // Retrieve uploaded file ID.\r\n    };\r\n    xhr.send(form);\r\n  }\r\n\r\n  createGridaFolder = async () => {\r\n    let self = this;\r\n    let access_token = gapi.auth.getToken().access_token;\r\n\r\n    let request = gapi.client.request({\r\n        'path': '/drive/v2/files/',\r\n        'method': 'POST',\r\n        'headers': {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': 'Bearer ' + access_token,             \r\n        },\r\n        'body':{\r\n            \"title\" : \"Grida\",\r\n            \"mimeType\" : \"application/vnd.google-apps.folder\",\r\n        }\r\n    });\r\n\r\n    request.execute(await function(resp) { \r\n      self.createNewMappingInfo(resp.id);\r\n    });\r\n  }\r\n\r\n  listFiles = () => {\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', function () {\r\n\r\n        let fileId = \"\";\r\n\r\n        gapi.client.drive.files.list({\r\n          'pageSize': 10,\r\n          'fields': \"*\"\r\n        }).then(function(response) {\r\n          console.log(response);\r\n          let files = response.result.items;\r\n          console.log(response.result.items);\r\n    \r\n          if (files && files.length > 0) {\r\n            for (let i = 0; i < files.length; i++) {\r\n              let file = files[i];\r\n              if (file.title === 'hi.pdf') {\r\n                console.log('file : ');\r\n                console.log(file);\r\n                fileId = file.id;\r\n              }\r\n            }\r\n          }\r\n\r\n          let request = gapi.client.drive.files.get({\r\n            fileId: fileId,\r\n            alt: 'media'\r\n          })\r\n          request.then(function(response) {\r\n            console.log(response);\r\n          }, function(error) {\r\n            console.error(error)\r\n          })\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  readMappingInfo = () => {\r\n\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', async function () {\r\n        const fileResponse = await gapi.client.drive.files.list();\r\n        let files = fileResponse.result.items;\r\n\r\n        if (files && files.length > 0) {\r\n          for (let i = 0; i < files.length; i++) {\r\n            let file = files[i];\r\n            if (file.title === 'mappingInfo.json') {\r\n              let fileId = file.id;\r\n              let getFileRequest = gapi.client.drive.files.get({\r\n                fileId: fileId,\r\n                alt: 'media'\r\n              })\r\n\r\n              getFileRequest.then(await function(response) {\r\n                let currentMappingObj = JSON.parse(response.body);\r\n                let content = JSON.stringify(currentMappingObj);\r\n                console.log(content);\r\n              }, function(error) {\r\n                console.error(error)\r\n              })\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  readPDF = () => {\r\n    gapi.load('client', function () {\r\n      gapi.client.load('drive', 'v2', async function () {\r\n        const fileResponse = await gapi.client.drive.files.list();\r\n        let files = fileResponse.result.items;\r\n\r\n        if (files && files.length > 0) {\r\n          for (let i = 0; i < files.length; i++) {\r\n            let file = files[i];\r\n            let fileId = file.id;\r\n            let getFileRequest = gapi.client.drive.files.get({\r\n              fileId: fileId,\r\n              alt: 'media',\r\n            });\r\n\r\n            if (file.mimeType === 'application/pdf') {\r\n              console.log(getFileRequest);\r\n              console.log(file.mimeType);\r\n\r\n              getFileRequest.then(await function(response) {\r\n                let docInitParams = { data: response.body };\r\n                PdfJs.getDocument(docInitParams).promise.then(function(pdf) {\r\n                  console.log('finger : ');\r\n                  console.log(pdf.fingerprint);\r\n                });\r\n              }, function(error) {\r\n                console.error(error)\r\n              })\r\n            }\r\n          }\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  render() {\r\n      return (\r\n        <div>\r\n        <button id=\"mapping_info_process\" onClick={this.mappingInfoUploadProcess}>\r\n          Upload Mapping Info\r\n        </button>\r\n        <button id=\"read_mapping_info\" onClick={this.readMappingInfo}>\r\n          Read Mapping Info\r\n        </button>\r\n        <button id=\"read_mapping_info\" onClick={this.readPDF}>\r\n          Read PDF\r\n        </button>\r\n          <GoogleLogin \r\n            clientId=\"169738066451-5u100n2i6rko17jhmtpvq0bnjuedj7g4.apps.googleusercontent.com\"\r\n            buttonText=\"Login\"\r\n            onSuccess={this.responseGoogle}\r\n            onFailure={this.responseGoogle}\r\n            cookiePolicy={'single_host_origin'}\r\n          />\r\n        </div>\r\n      )\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\CanvasColorConverter.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\RenderWorkerBase.tsx",["491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522","523","524","525","526","527","528","529","530","531","532","533","534"],"import \"../../types\";\r\nimport { fabric } from \"fabric\";\r\nimport { InkStorage } from \"../..\";\r\nimport { PATH_THICKNESS_SCALE } from \"./DrawCurves\";\r\n// import { NCODE_TO_SCREEN_SCALE } from \"../../constants\";\r\nimport { IWritingSurfaceInfo, ISize } from \"../../DataStructure/Structures\";\r\nimport { ncodeToDisplayPixel } from \"../../utils/UtilsFunc\";\r\n// import { paperInfo } from \"../../noteserver/PaperInfo\";\r\n// import { plugToRequest } from \"react-cookies\";\r\n// import { scaleCanvas } from \"../../utils/UtilsFunc\";\r\n// import { IRectOptions } from \"fabric/fabric-impl\";\r\n\r\n// const timeTickDuration = 20; // ms\r\n// const DISABLED_STROKE_COLOR = \"rgba(0, 0, 0, 0.1)\";\r\n// const INVISIBLE_STROKE_COLOR = \"rgba(255, 255, 255, 0)\";\r\n// const INCOMPLETE_STROKE_COLOR = \"rgba(255, 0, 255, 0.4)\";\r\n// const CURRENT_POINT_STROKE_COLOR = \"rgba(255, 255, 255, 1)\";\r\n\r\n\r\nexport enum PLAYSTATE {\r\n  live,\r\n  play,\r\n  stop,\r\n  pause,\r\n  rewind,\r\n  trackRewind,\r\n  setAutoStop,\r\n  unsetAutoStop,\r\n}\r\n\r\nexport enum ZoomFitEnum {\r\n  ACTUAL,\r\n  WIDTH,\r\n  HEIGHT,\r\n  FULL,\r\n}\r\n\r\n\r\nexport type IRenderWorkerOption = {\r\n  canvasId: string,\r\n\r\n  canvasRef: React.RefObject<HTMLCanvasElement>,\r\n  width: number,\r\n  height: number,\r\n  viewFit: ZoomFitEnum,\r\n  bgColor?: string,\r\n  mouseAction?: boolean,\r\n  shouldDisplayGrid?: boolean,\r\n  storage?: InkStorage,\r\n\r\n  onCanvasShapeChanged: (arg: { offsetX, offsetY, zoom }) => void,\r\n}\r\n\r\n/**\r\n * @enum {string}\r\n */\r\n\r\n// const STROKE_OBJECT_ID = \"ns\";\r\nconst GRID_OBJECT_ID = \"g\";\r\n\r\n/**\r\n * @typedef {Object} RenderWorkerOption\r\n * @property {string} canvasId\r\n * @property {number} width\r\n * @property {number} height\r\n * @property {string} [bgColor]\r\n * @property {boolean} [mouseAction]\r\n * @property {ZoomFitEnum} [viewFit]\r\n * @property {boolean} [shouldDisplayGrid]\r\n * @property {InkStorage} [storage]\r\n *\r\n */\r\n\r\nexport default class RenderWorkerBase {\r\n\r\n  name: string;\r\n  /** canvas element ID */\r\n  canvasId = \"\";\r\n\r\n  canvasRef: React.RefObject<HTMLCanvasElement>;\r\n\r\n  /** background color */\r\n  bgColor = \"rgba(255,255,255,0)\";\r\n\r\n  /** the size when first initied */\r\n  initialSize: { width: number, height: number } = { width: 0, height: 0 };\r\n\r\n  /** the size after resize */\r\n  currSize: { width: number, height: number } = { width: 0, height: 0 };\r\n\r\n  /** FabricJs canvas */\r\n  canvasFb: fabric.Canvas = null;\r\n\r\n  /** mouse에 따라 pan, zoom이 가능한지에 대한 여부 */\r\n  mouseAction = true;\r\n\r\n  /**  mouse에 따라 pan, zoom이 가능한지에 대한 여부 */\r\n  zoomCtrlKey = false;\r\n\r\n  /** mouse drag & panning 을 위해 */\r\n  pan: { isDragging: boolean, lastPosX: number, lastPosY: number } = {\r\n    isDragging: false,\r\n    lastPosX: 0,\r\n    lastPosY: 0,\r\n  };\r\n\r\n  /** pen stroke에 따라 자동 focus를 맞추도록 */\r\n  autoFocus = true;\r\n\r\n  /** <canvas>내의 drawing canvas(fabric canvas)의 offset, 현재는 안 씀 - 2020/11/08*/\r\n  offset: { x: number, y: number } = { x: 0, y: 0 };\r\n\r\n  /** 종이 정보 */\r\n  surfaceInfo: IWritingSurfaceInfo = {\r\n    section: 3,\r\n    owner: 27,\r\n    book: 168,\r\n    page: 1,\r\n\r\n    Xmin: 3.12,   // code unit\r\n    Ymin: 3.12,\r\n    Xmax: 91.68,\r\n    Ymax: 128.36,\r\n    Mag: 1,\r\n  };\r\n\r\n  /** Ncode to Screen scale */\r\n  base_scale: number;\r\n\r\n  /** logical zoom in/out */\r\n  scale = 1;\r\n\r\n  /** zoom fit */\r\n  viewFit: ZoomFitEnum = ZoomFitEnum.ACTUAL;\r\n\r\n  /** determine whether border and grid lines displayed or not */\r\n  shouldDisplayGrid = true;\r\n\r\n  /** animation timer */\r\n  scrollAnimateTimer: number = null;\r\n  options: IRenderWorkerOption;\r\n\r\n\r\n\r\n  /**\r\n   *\r\n   * @param {RenderWorkerOption} options\r\n   */\r\n  constructor(options: IRenderWorkerOption) {\r\n    const { canvasId, canvasRef, width, height, bgColor, mouseAction, viewFit, shouldDisplayGrid } = options;\r\n\r\n    this.name = \"RenderWorkerBase\";\r\n\r\n    if (typeof canvasId !== \"string\") {\r\n      throw new Error(\"canvasId should be a string\");\r\n    }\r\n\r\n    this.canvasId = canvasId;\r\n    this.canvasRef = canvasRef;\r\n\r\n    this.initialSize = { width, height };\r\n    this.currSize = { width, height };\r\n\r\n    this.base_scale = ncodeToDisplayPixel(1);\r\n    this.scale = 1;\r\n\r\n    this.canvasFb = null;\r\n\r\n    if (bgColor !== undefined) this.bgColor = bgColor;\r\n    if (typeof (mouseAction) === \"boolean\") this.mouseAction = mouseAction;\r\n\r\n    if (viewFit) {\r\n      this.viewFit = viewFit;\r\n    }\r\n    else {\r\n      this.viewFit = ZoomFitEnum.ACTUAL;\r\n    }\r\n\r\n    if (typeof (shouldDisplayGrid) === \"boolean\") this.shouldDisplayGrid = shouldDisplayGrid;\r\n\r\n    this.options = options;\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  init = () => {\r\n    const size = this.currSize;\r\n\r\n    // let HtmlCanvas = this.canvasRef.current;\r\n    // const dpr = getDisplayRatio();\r\n    // scaleCanvas(HtmlCanvas);\r\n    const dpr = 1;\r\n\r\n    console.log(`Fabric canvas inited: size(${size.width}, ${size.height})`);\r\n\r\n    this.canvasFb = new fabric.Canvas(this.canvasId, {\r\n\r\n      backgroundColor: this.bgColor ? this.bgColor : \"rgba(255,255,0,0.5)\",\r\n      selection: false,\r\n      controlsAboveOverlay: false,\r\n      selectionLineWidth: 4,\r\n      width: size.width * dpr,\r\n      height: size.height * dpr,\r\n\r\n    });\r\n\r\n    const canvasFb = this.canvasFb;\r\n\r\n    if (this.mouseAction) {\r\n      canvasFb.on('mouse:down', this.onCanvasMouseDown);\r\n      canvasFb.on('mouse:move', this.onCanvasMouseMove);\r\n      canvasFb.on('mouse:up', this.onCanvasMousUp);\r\n      canvasFb.on('mouse:wheel', this.onCanvasMouseWheel);\r\n    }\r\n\r\n    this.drawPageLayout();\r\n  }\r\n\r\n  getSurfaceSize_CSS = (): ISize => {\r\n    const { Xmin, Xmax, Ymin, Ymax } = this.surfaceInfo;\r\n    const ncode_width = Xmax - Xmin;\r\n    const ncode_height = Ymax - Ymin;\r\n\r\n    const actual_width = ncodeToDisplayPixel(ncode_width);\r\n    const actual_height = ncodeToDisplayPixel(ncode_height);\r\n    const s: ISize = {\r\n      width: actual_width * this.scale,\r\n      height: actual_height * this.scale,\r\n    };\r\n\r\n    return s;\r\n  }\r\n\r\n  drawPageLayout = () => {\r\n    if (!this.shouldDisplayGrid) return;\r\n    const canvasFb = this.canvasFb;\r\n\r\n    // 지우기\r\n    if (this.canvasFb) {\r\n      const objects = this.canvasFb.getObjects();\r\n      const strokes = objects.filter(obj => obj.data === GRID_OBJECT_ID);\r\n\r\n      strokes.forEach((obj) => {\r\n        this.canvasFb.remove(obj);\r\n      });\r\n    }\r\n\r\n    // 그리기\r\n    const size = this.getSurfaceSize_CSS();\r\n    console.log(`drawPageLayout: ${size.width}, ${size.height}`);\r\n\r\n    // console.log(`Grid: scale=${this.base_scale} (width, height)=(${size.width}, ${size.height})`);\r\n\r\n    const ratio = 1;\r\n\r\n    const rect = new fabric.Rect({\r\n      width: size.width * ratio - 5,\r\n      height: size.height * ratio - 5,\r\n      strokeWidth: 5,\r\n      stroke: 'rgba(0,0,0,1)',\r\n      fill: 'rgb(100,100,200, 0.1)',\r\n      left: size.width * (1 - ratio) * 0.5,\r\n      top: size.height * (1 - ratio) * 0.5,\r\n      // lockMovementX: true,\r\n      // lockMovementY: true,\r\n      selectable: false,\r\n      data: GRID_OBJECT_ID,\r\n\r\n    });\r\n    canvasFb.add(rect);\r\n\r\n    for (let x = 0; x < size.width; x += 10) {\r\n      const line = new fabric.Line([x, 0, x, size.height], {\r\n        strokeWidth: 0.5,\r\n        stroke: \"rgba(0,0,0,0.1)\",\r\n        hasControls: false,\r\n        hasBorders: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        data: GRID_OBJECT_ID,\r\n      });\r\n\r\n      canvasFb.add(line);\r\n    }\r\n\r\n\r\n    for (let y = 0; y < size.height; y += 10) {\r\n      const line = new fabric.Line([0, y, size.width, y], {\r\n        strokeWidth: 0.5,\r\n        stroke: \"rgba(0,0,0,0.1)\",\r\n        hasControls: false,\r\n        hasBorders: false,\r\n        lockMovementX: true,\r\n        lockMovementY: true,\r\n        data: GRID_OBJECT_ID,\r\n      });\r\n\r\n      canvasFb.add(line);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * enable/disable mouse drag panning and zoom in/out\r\n   * default: true\r\n   *\r\n   * @public\r\n   * @param {boolean} sw\r\n   */\r\n  enableMouseAction = (sw: boolean) => {\r\n    if (this.mouseAction !== sw) {\r\n      let canvasFb = this.canvasFb;\r\n\r\n      if (sw === false) {\r\n\r\n        this.onCanvasMousUp();\r\n\r\n        canvasFb.off('mouse:down', this.onCanvasMouseDown);\r\n        canvasFb.off('mouse:move', this.onCanvasMouseMove);\r\n        canvasFb.off('mouse:up', this.onCanvasMousUp);\r\n        canvasFb.off('mouse:wheel', this.onCanvasMouseWheel);\r\n      }\r\n      else {\r\n        canvasFb.on('mouse:down', this.onCanvasMouseDown);\r\n        canvasFb.on('mouse:move', this.onCanvasMouseMove);\r\n        canvasFb.on('mouse:up', this.onCanvasMousUp);\r\n        canvasFb.on('mouse:wheel', this.onCanvasMouseWheel);\r\n      }\r\n    }\r\n    this.mouseAction = sw;\r\n  }\r\n\r\n  /**\r\n   * enable/disable auto set focus at current stroke point\r\n   * default: true\r\n   *\r\n   * @public\r\n   * @param {boolean} sw\r\n   */\r\n  enableAutoFocus = (sw: boolean) => {\r\n    this.autoFocus = sw;\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMouseDown = (opt: any) => {\r\n    let canvasFb = this.canvasFb;\r\n\r\n    let evt: MouseEvent = opt.e;\r\n\r\n    this.pan.isDragging = true;\r\n    this.pan.lastPosX = evt.clientX;\r\n    this.pan.lastPosY = evt.clientY;\r\n\r\n    canvasFb.selection = false;\r\n\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMouseMove = (opt: any) => {\r\n    let canvasFb = this.canvasFb;\r\n\r\n    if (this.pan.isDragging) {\r\n      let e: MouseEvent = opt.e;\r\n      // console.log(`Point ${e.clientX}, ${e.clientY}`);\r\n      let vpt = canvasFb.viewportTransform;\r\n      vpt[4] += e.clientX - this.pan.lastPosX;\r\n      vpt[5] += e.clientY - this.pan.lastPosY;\r\n\r\n      this.scrollBoundaryCheck();\r\n\r\n      // event 전달\r\n      this.reportCanvasChanged();\r\n      // canvas.setViewportTransform(vpt);\r\n      canvasFb.requestRenderAll();\r\n\r\n      this.pan.lastPosX = e.clientX;\r\n      this.pan.lastPosY = e.clientY;\r\n\r\n\r\n\r\n      // this.canvasBoundaryCheck();\r\n    }\r\n  }\r\n\r\n  reportCanvasChanged = () => {\r\n    let canvasFb = this.canvasFb;\r\n    let vpt = canvasFb.viewportTransform;\r\n    const offsetX = vpt[4];\r\n    const offsetY = vpt[5];\r\n\r\n    const zoom = canvasFb.getZoom();\r\n\r\n    this.options.onCanvasShapeChanged({ offsetX, offsetY, zoom });\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMousUp = (opt: any = undefined) => {\r\n    let canvasFb = this.canvasFb;\r\n\r\n\r\n    // on mouse up we want to recalculate new interaction\r\n    // for all objects, so we call setViewportTransform\r\n    canvasFb.setViewportTransform(canvasFb.viewportTransform);\r\n    this.pan.isDragging = false;\r\n    canvasFb.selection = false;\r\n\r\n\r\n    // let vpt = canvas.viewportTransform;\r\n    // console.log(vpt);\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {Object} opt\r\n   */\r\n  onCanvasMouseWheel = (opt: any) => {\r\n    let evt: MouseEvent = opt.e;\r\n    if ((!this.zoomCtrlKey) || (this.zoomCtrlKey === true && evt.ctrlKey === true)) {\r\n      let canvasFb = this.canvasFb;\r\n\r\n      let delta = opt.e.deltaY;\r\n      let zoom = canvasFb.getZoom();\r\n      zoom *= 0.999 ** delta;\r\n\r\n      this.setCanvasZoom(zoom, opt);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  scrollBoundaryCheck = () => {\r\n\r\n    // const canvasFb = this.canvasFb;\r\n    // const zoom = canvasFb.getZoom();\r\n\r\n    // // http://fabricjs.com/fabric-intro-part-5#pan_zoom\r\n    // let vpt = canvasFb.viewportTransform;\r\n\r\n    // if (vpt[4] >= 0) {\r\n    //   vpt[4] = 0;\r\n    // }\r\n    // else if (vpt[4] < canvasFb.getWidth() - this.currSize.width * zoom) {\r\n    //   vpt[4] = canvasFb.getWidth() - this.currSize.width * zoom;\r\n    // }\r\n\r\n    // if (vpt[5] >= 0) {\r\n    //   vpt[5] = 0;\r\n    // }\r\n    // else if (vpt[5] < canvasFb.getHeight() - this.currSize.height * zoom) {\r\n    //   vpt[5] = canvasFb.getHeight() - this.currSize.height * zoom;\r\n    // }\r\n\r\n    // if (zoom < 1) {\r\n    //   vpt[4] = (this.currSize.width - this.currSize.width * zoom) / 2;\r\n    //   vpt[5] = (this.currSize.height - this.currSize.height * zoom) / 2;\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {number} zoom\r\n   * @param {Object} opt\r\n   */\r\n  setCanvasZoom = (zoom: number, opt: any) => {\r\n    let canvas = this.canvasFb;\r\n\r\n    if (zoom > 20) zoom = 20;\r\n    if (zoom < 0.01) zoom = 0.01;\r\n\r\n    /** @type {fabric.Point} */\r\n    const evt: MouseEvent = opt.e;\r\n    const pt = new fabric.Point(evt.offsetX, evt.offsetY);\r\n    if (opt) canvas.zoomToPoint(pt, zoom);\r\n    else canvas.setZoom(zoom);\r\n\r\n\r\n    opt.e.preventDefault();\r\n    opt.e.stopPropagation();\r\n\r\n    this.scrollBoundaryCheck();\r\n\r\n    // event 전달\r\n    this.reportCanvasChanged();\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number, f?:number}} ncodeXY\r\n   */\r\n  protected getCanvasXY = (ncodeXY: { x: number, y: number, f?: number }) => {\r\n    const { x, y, f } = ncodeXY;\r\n    const { Xmin, Ymin } = this.surfaceInfo;\r\n\r\n    let scale = this.base_scale;\r\n\r\n    let cx = (x - Xmin) * scale + this.offset.x;\r\n    let cy = (y - Ymin) * scale + this.offset.y;\r\n\r\n    return { x: cx, y: cy, f };\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number, f?:number}} ncodeXY\r\n   */\r\n  protected getCanvasXY_scaled = (ncodeXY: { x: number, y: number, f?: number }) => {\r\n    const { x, y, f } = ncodeXY;\r\n    const { Xmin, Ymin } = this.surfaceInfo;\r\n\r\n    let scale = this.base_scale;\r\n\r\n    let cx = (x - Xmin) * scale + this.offset.x;\r\n    let cy = (y - Ymin) * scale + this.offset.y;\r\n\r\n    cx *= PATH_THICKNESS_SCALE;\r\n    cy *= PATH_THICKNESS_SCALE;\r\n\r\n    return { x: cx, y: cy, f };\r\n  }\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number}} canvasXY\r\n   */\r\n  protected getScreenXY = (canvasXY: { x: number, y: number }) => {\r\n    const { x, y } = canvasXY;\r\n\r\n    let canvasFb = this.canvasFb;\r\n    let vpt = canvasFb.viewportTransform;\r\n\r\n    let zoom = this.canvasFb.getZoom();\r\n    let offset_x = vpt[4];\r\n    let offset_y = vpt[5];\r\n\r\n\r\n    let sx = x * zoom + offset_x;\r\n    let sy = y * zoom + offset_y;\r\n\r\n    return { x: sx, y: sy };\r\n  }\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number}} screenXY\r\n   */\r\n  protected getNcodeXY = (screenXY: { x: number, y: number }) => {\r\n    const { x, y } = screenXY;\r\n\r\n    let scale_det = 1 / this.base_scale;\r\n\r\n    let nx = (x - this.offset.x) * scale_det;\r\n    let ny = (y - this.offset.y) * scale_det;\r\n\r\n    return { x: nx, y: ny };\r\n  }\r\n\r\n\r\n  /**\r\n   * \r\n   * @param mode \r\n   * @param szPaper \r\n   * @param currScale \r\n   */\r\n  protected calcScaleFactor(mode: ZoomFitEnum, szPaper: { width: number, height: number }, currScale: number): number {\r\n\r\n    const actual_width = szPaper.width * this.base_scale;\r\n    const actual_height = szPaper.height * this.base_scale;\r\n\r\n    const szCanvas = this.currSize;\r\n    let scale = 1;\r\n    switch (mode) {\r\n      case ZoomFitEnum.WIDTH:\r\n        scale = szCanvas.width / actual_width;\r\n\r\n        break;\r\n\r\n      case ZoomFitEnum.HEIGHT:\r\n        scale = szCanvas.height / actual_height;\r\n        break;\r\n\r\n      case ZoomFitEnum.FULL:\r\n        scale = Math.min(szCanvas.width / actual_width, szCanvas.height / actual_height);\r\n        break;\r\n\r\n      case ZoomFitEnum.ACTUAL:\r\n        scale = 1;\r\n        break;\r\n\r\n      default:\r\n        scale = currScale;\r\n\r\n        break;\r\n\r\n    }\r\n    return scale;\r\n  }\r\n\r\n\r\n\r\n\r\n  /**\r\n   * @protected\r\n   * @param {{x:number, y:number}} dot\r\n   */\r\n  protected focusToDot = (dot: { x: number, y: number }) => {\r\n    if (!this.autoFocus) return;\r\n    const margin_to_go_ratio = 0.25;\r\n    const canvas_xy = this.getCanvasXY(dot);\r\n    const screen_xy = this.getScreenXY(canvas_xy);\r\n\r\n    let dx = 0, dy = 0;\r\n    let shouldScroll = false;\r\n\r\n    let canvasFb = this.canvasFb;\r\n    let vpt = canvasFb.viewportTransform;\r\n    let offset_x = vpt[4];\r\n    let offset_y = vpt[5];\r\n\r\n    if (screen_xy.x < 0) {\r\n      // scroll to left\r\n      let target = this.currSize.width * margin_to_go_ratio;\r\n      dx = target - screen_xy.x;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.y < 0) {\r\n      // scroll to top\r\n      let target = this.currSize.height * margin_to_go_ratio;\r\n      dy = target - screen_xy.y;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.x > this.currSize.width) {\r\n      // scroll to right\r\n      let target = this.currSize.width * (1 - margin_to_go_ratio);\r\n      dx = target - screen_xy.x;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (screen_xy.y > this.currSize.height) {\r\n      // scroll to bottom\r\n      let target = this.currSize.height * (1 - margin_to_go_ratio);\r\n      dy = target - screen_xy.y;\r\n      shouldScroll = true;\r\n    }\r\n\r\n    if (shouldScroll) {\r\n\r\n      let new_offset_x = offset_x + dx;\r\n      let new_offset_y = offset_y + dy;\r\n\r\n      this.scrollCanvasToPoint({ x: new_offset_x, y: new_offset_y }, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {{x:number, y:number}} point\r\n   * @param {boolean} animate\r\n   */\r\n  protected scrollCanvasToPoint = (point: { x: number, y: number }, animate: boolean) => {\r\n    let canvasFb = this.canvasFb;\r\n    let vpt = canvasFb.viewportTransform;\r\n\r\n    if (animate) {\r\n      if (this.scrollAnimateTimer) {\r\n        window.clearInterval(this.scrollAnimateTimer);\r\n        this.scrollAnimateTimer = null;\r\n      }\r\n      let x0 = vpt[4];\r\n      let y0 = vpt[5];\r\n      let x1 = point.x;\r\n      let y1 = point.y;\r\n\r\n      const div = 10;\r\n      let step_x = (x1 - x0) / div;\r\n      let step_y = (y1 - y0) / div;\r\n      let count = 0;\r\n\r\n      this.scrollAnimateTimer = window.setInterval(() => {\r\n        x0 += step_x;\r\n        y0 += step_y;\r\n        vpt[4] = x0;\r\n        vpt[5] = y0;\r\n        canvasFb.requestRenderAll();\r\n\r\n        count++;\r\n        if (count === div) {\r\n          window.clearInterval(this.scrollAnimateTimer);\r\n          this.scrollAnimateTimer = null;\r\n          canvasFb.setViewportTransform(canvasFb.viewportTransform);\r\n        }\r\n      }, 20);\r\n    }\r\n    else {\r\n      vpt[4] = point.x;\r\n      vpt[5] = point.y;\r\n      this.scrollBoundaryCheck();\r\n      canvasFb.requestRenderAll();\r\n      canvasFb.setViewportTransform(canvasFb.viewportTransform);\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * @public\r\n   * @param {{width:number, height:number}} size\r\n   */\r\n  resize = (size: { width: number, height: number }) => {\r\n    console.log(`RenderWorkerBase: resized window ${size.width}, ${size.height}`);\r\n\r\n    let zoom = size.width / this.initialSize.width;\r\n    this.currSize = { ...size };\r\n\r\n    this.canvasFb.setHeight(size.height);\r\n    this.canvasFb.setWidth(size.width);\r\n\r\n    this.canvasFb.setZoom(zoom);\r\n  };\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Save\\SavePdf.tsx",["535"],"import { saveAs } from \"file-saver\";\r\nimport { degrees, PDFDocument, rgb, StandardFonts } from 'pdf-lib';\r\n\r\n// https://pdf-lib.js.org/\r\n\r\nexport async function addGraphicAndSavePdf(url: string, saveName: string) {\r\n\r\n  const existingPdfBytes = await fetch(url).then(res => res.arrayBuffer())\r\n\r\n  const pdfDoc = await PDFDocument.load(existingPdfBytes)\r\n  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica)\r\n\r\n  const pages = pdfDoc.getPages()\r\n  const firstPage = pages[0]\r\n  const { height } = firstPage.getSize()\r\n  firstPage.drawText('This text was added with JavaScript!', {\r\n    x: 5,\r\n    y: height / 2 + 300,\r\n    size: 50,\r\n    font: helveticaFont,\r\n    color: rgb(0.95, 0.1, 0.1),\r\n    rotate: degrees(-45),\r\n  })\r\n\r\n\r\n  const svgPath =\r\n    'M 0,20 L 100,160 Q 130,200 150,120 C 190,-40 200,200 300,150 L 400,90'\r\n\r\n  firstPage.moveTo(100, firstPage.getHeight() - 5)\r\n\r\n  firstPage.moveDown(25)\r\n  firstPage.drawSvgPath(svgPath)\r\n\r\n  firstPage.moveDown(200)\r\n  firstPage.drawSvgPath(svgPath, { borderColor: rgb(0, 1, 0), borderWidth: 5 })\r\n\r\n  firstPage.moveDown(200)\r\n  firstPage.drawSvgPath(svgPath, { color: rgb(1, 0, 0) })\r\n\r\n  firstPage.moveDown(200)\r\n  firstPage.drawSvgPath(svgPath, { scale: 0.5 })\r\n\r\n\r\n  const pdfBytes = await pdfDoc.save();\r\n  console.log(pdfBytes);\r\n\r\n  let blob = new Blob([pdfBytes]);\r\n  saveAs(blob, saveName);\r\n\r\n  console.log(firstPage);\r\n\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowserButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PdfPrintButton.tsx",["536"],"import React from \"react\";\r\nimport { Button, } from \"@material-ui/core\";\r\n\r\nimport { PrintPdfMain } from \"./PrintPdfMain\";\r\nimport { IPrintingProgress, IPrintOption, } from \"./PrintDataTypes\";\r\n\r\nimport NeoPdfDocument from \"../NeoPdf/NeoPdfDocument\";\r\nimport NeoPdfManager from \"../NeoPdf/NeoPdfManager\";\r\nimport { PDF_VIEWPORT_DESC } from \"../NeoPdf/NeoPdfPage\";\r\nimport { IPageOverview } from \"./PagesForPrint\";\r\n\r\n// PdfJs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${PdfJs.version}/pdf.worker.js`;\r\n// var CMAP_URL = \"./cmaps/\";\r\n// var CMAP_PACKED = true;\r\n\r\ntype Props = {\r\n  url: string,\r\n  reportProgress: Function,\r\n  printOption: IPrintOption,\r\n\r\n  children?: React.ReactNode;\r\n  color?: any;\r\n  disabled?: boolean;\r\n  disableElevation?: boolean;\r\n  disableFocusRipple?: boolean;\r\n  endIcon?: React.ReactNode;\r\n  fullWidth?: boolean;\r\n  href?: string;\r\n  size?: 'small' | 'medium' | 'large';\r\n  startIcon?: React.ReactNode;\r\n  variant?: 'text' | 'outlined' | 'contained';\r\n}\r\n\r\ninterface State {\r\n\r\n  /** PDF를 인쇄하기 위해 필요한 것 */\r\n  pdf: NeoPdfDocument,\r\n  printTrigger: number,\r\n  /** 여기까지 */\r\n\r\n  /** Sample 코드를 위한 것 */\r\n  numTotalPages: number,\r\n  /**\r\n   * printingStatus\r\n   */\r\n  /** 인쇄 준비된 페이지 수 */\r\n  numPagesPrepared: number,\r\n  /** 인쇄 준비된 종이 장 수 */\r\n  numSheetsPrepared: number,\r\n\r\n  /** 세부 단계 */\r\n  completion: number,\r\n\r\n  /** 인쇄되는 종이 장 수 */\r\n  numSheets: number,\r\n  /** 인쇄 대상 페이지 수 */\r\n  numPages: number,\r\n\r\n  status: string,\r\n}\r\n\r\n/**\r\n * Class\r\n */\r\nexport default class PdfPrintButton extends React.Component<Props, State> {\r\n  // static displayName = \"WholePageViewer\";\r\n\r\n  // static defaultProps = {\r\n  //   initialScrollOffset: 0\r\n  // };\r\n\r\n  state: State = {\r\n    /** PDF를 인쇄하기 위해 필요한 것 */\r\n    pdf: null,\r\n    // scale: 1.0,\r\n    printTrigger: 0,\r\n\r\n    /** Sample 코드를 위한 것 */\r\n    numTotalPages: 0,\r\n\r\n    numPagesPrepared: 0,\r\n    numSheetsPrepared: 0,\r\n    completion: 0,\r\n    numSheets: 0,\r\n    numPages: 0,\r\n\r\n    status: \"ready\",\r\n  };\r\n\r\n  // numPages: number = 0;\r\n\r\n  printOption: IPrintOption = null;\r\n\r\n\r\n  pagesOverview: IPageOverview[];\r\n\r\n\r\n  constructor(props: Props) {\r\n    super(props);\r\n    const { printOption } = props;\r\n    if (printOption) this.printOption = { ...printOption };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.loadPdf(this.props.url);\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: Props) {\r\n    if (this.props.url !== nextProps.url) {\r\n      this.loadPdf(nextProps.url);\r\n      return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * NeoPdfDocument에 있는 setPageOverview의 결과를 쓰도록 하자\r\n   * 2020/12/06\r\n   */\r\n  setPageOverview = async (pdf) => {\r\n    // const pdf = this.props.pdf;\r\n    this.pagesOverview = new Array(pdf.numPages + 1);\r\n    // const { pagesPerSheet } = this.printOption;\r\n\r\n    let numPortraitPages = 0;\r\n    let numLandscapePages = 0;\r\n\r\n    for (let i = 0; i < pdf.numPages; i++) {\r\n      const page = await pdf.getPageAsync(i + 1);\r\n      const vpt: PDF_VIEWPORT_DESC = page.getViewport({ scale: 1, rotation: 0 });\r\n      const { width, height } = vpt;\r\n\r\n      const landscape = width > height;\r\n      landscape ? numLandscapePages++ : numPortraitPages++;\r\n\r\n      const pageOverview = {\r\n        rotation: vpt.rotation,\r\n        landscape,\r\n        sizePu: { width, height },\r\n      }\r\n      this.pagesOverview[i] = pageOverview;\r\n    }\r\n\r\n    const printOption = this.printOption;\r\n\r\n    if (numPortraitPages >= numLandscapePages) {\r\n      printOption.direction = \"portrait\";\r\n    } else {\r\n      printOption.direction = \"landscape\";\r\n    }\r\n\r\n    console.log(`[yyy] setPageOverview - ${printOption.direction}`);\r\n  }\r\n\r\n  loadPdf = (url) => {\r\n\r\n    let loadingPromise = NeoPdfManager.getDocument({ url });\r\n    // console.log(`[yyy] `);\r\n    // console.log(`[yyy] LOAIND: ${url}`);\r\n    loadingPromise.then(\r\n      async (pdf) => {\r\n        // console.log(`[yyy] setPageOverview called`);\r\n\r\n        await this.setPageOverview(pdf);\r\n\r\n        // 디버깅용 화면 디스플레이를 위해\r\n        const numTotalPages = pdf.numPages;\r\n        console.log(`[NumPage] PDF page: ${url} - ${numTotalPages}`)\r\n        this.printOption.targetPages = Array.from({ length: numTotalPages }, (_, i) => i + 1);\r\n        // 여기까지\r\n\r\n        this.setState({ pdf, numTotalPages });\r\n      });\r\n\r\n  }\r\n\r\n  /**\r\n   * 이 함수를 dialog로 수정함으로써 프린터 옵션을 바꿀 수 있다.\r\n   */\r\n  setPrintOption = (pdf: NeoPdfDocument) => {\r\n    const numPages = pdf.numPages;\r\n\r\n    // kitty, 2020/11/24\r\n    if (this.props.url === \"./Portrait, 초등학교 4학년 4P.pdf\") {\r\n      /** 그리다 보드와 맞추기 위한 것, for 초등학교 4학년 4P.pdf */\r\n      this.printOption.magnification = 0.9158249158249159;\r\n      this.printOption.marginLeft_nu = 1.3;\r\n      this.printOption.marginTop_nu = -0.5;\r\n    }\r\n\r\n    // 모든 페이지를 인쇄\r\n    this.printOption.targetPages = Array.from({ length: numPages }, (_, i) => i + 1);\r\n\r\n    // 1,2 페이지만 인쇄\r\n    // this.printOption.targetPages = Array.from({ length: 2 }, (_, i) => i + 1);\r\n\r\n    this.printOption.debugMode = 0;\r\n  }\r\n\r\n  startPrint = () => {\r\n    if (!this.state.pdf) return;\r\n    if (this.state.status === \"printing\") return;\r\n\r\n    /** PrintPdfMain의 printTrigger를 +1 해 주면, 인쇄가 시작된다.*/\r\n    const { printTrigger } = this.state;\r\n\r\n    this.setPrintOption(this.state.pdf);\r\n    const { targetPages, pagesPerSheet } = this.printOption;\r\n\r\n    const numSheets = Math.ceil(targetPages.length / pagesPerSheet);\r\n    const numPages = targetPages.length;\r\n\r\n    this.setState({\r\n      printTrigger: printTrigger + 1,\r\n\r\n      numPagesPrepared: 0,\r\n      numSheetsPrepared: 0,\r\n      completion: 0,\r\n      numSheets,\r\n      numPages,\r\n      status: \"printing\",\r\n    });\r\n  }\r\n\r\n  updatePrintProgress = (event: IPrintingProgress) => {\r\n    const { preparedPages, numSheetsPrepared, completion } = event;\r\n    const numPagesPrepared = preparedPages.length;\r\n\r\n    this.setState({\r\n      numPagesPrepared,\r\n      numSheetsPrepared,\r\n      completion,\r\n    });\r\n\r\n    if (this.props.reportProgress) {\r\n      this.props.reportProgress({\r\n        status: \"progress\",\r\n        numPagesPrepared,\r\n        numSheetsPrepared,\r\n        completion,\r\n      })\r\n    }\r\n  }\r\n\r\n  onAfterPrint = () => {\r\n    console.log(\"END OF PRINT\");\r\n\r\n    this.setState({\r\n      status: \"completed\",\r\n    });\r\n\r\n    if (this.props.reportProgress) {\r\n      this.props.reportProgress({\r\n        status: \"completed\",\r\n        completion: 100,\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  render() {\r\n    const { pdf, printTrigger } = this.state;\r\n    const printOption = this.printOption;\r\n\r\n    // const { numPagesPrepared, numSheetsPrepared, completion, numSheets, numPages } = this.state;\r\n\r\n    // // let msg = `sheets(${numSheetsPrepared}:${completion}% / ${numSheets}), pages(${numPagesPrepared}:${completion}% / ${numPages})`;\r\n    // // if (status === \"printing\") {\r\n    // //   msg = \"Printing... \" + msg;\r\n    // // }\r\n    // // else if (status === \"completed\") {\r\n    // //   msg = \"Print completed... \" + msg;\r\n    // // }\r\n\r\n    return (\r\n      <div className=\"pdf-context\">\r\n        <Button {...this.props} onClick={this.startPrint}>\r\n          {this.props.children}\r\n        </Button>\r\n\r\n        { pdf ?\r\n          <PrintPdfMain\r\n            pdf={pdf}\r\n            pagesOverview={this.pagesOverview}\r\n            printTrigger={printTrigger}\r\n            printOption={printOption}\r\n            onAfterPrint={this.onAfterPrint}\r\n            updatePrintProgress={this.updatePrintProgress} />\r\n          : \"\"}\r\n        <hr />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationButton.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\Enums.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\utils\\JsUtils.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\Modal\\PrintOptionDialog.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\penstorage\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoDot.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\NeoPdfViewer.tsx",["537","538"],"/// <reference types=\"pdfjs-dist\" />\r\n\r\nimport React, { CSSProperties } from \"react\";\r\n// import PropTypes from \"prop-types\";\r\nimport { Page } from './Page';\r\nimport * as PdfJs from \"pdfjs-dist\";\r\n\r\nPdfJs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${PdfJs.version}/pdf.worker.js`;\r\n// const PDF_URL = 'https://mozilla.github.io/pdf.js/web/compressed.tracemonkey-pldi-09.pdf';\r\n// const PDF_URL = \"./2020학년도 서울대학교 수시모집 일반전형 면접 및 구술고사 문항.pdf\";\r\n// const PDF_URL = \"https://uploads.codesandbox.io/uploads/user/faa4155a-f802-458d-81ad-90b4709d0cf8/4ETB-10.1.1.324.5566.pdf\";\r\nconst CMAP_URL = \"pdfjs-dist/cmaps/\";\r\nconst CMAP_PACKED = true;\r\n\r\n\r\ninterface Props {\r\n  url: string,\r\n  pageNo: number,\r\n  onReportPdfInfo: Function,\r\n  position: { offsetX: number, offsetY: number, zoom: number },\r\n}\r\n\r\ninterface State {\r\n  pdf: PdfJs.PDFDocumentProxy,\r\n  scale: number,\r\n  documentZoom: number,\r\n  status: string,\r\n}\r\n\r\nexport default class NeoPdfViewer extends React.Component<Props, State> {\r\n  static displayName = \"Viewer\";\r\n  documentContainer = React.createRef();\r\n  document = React.createRef();\r\n  scroller = React.createRef();\r\n\r\n  constructor(Props: Props) {\r\n    super(Props);\r\n    this.state = {\r\n      pdf: null,\r\n      scale: 1.0,\r\n      documentZoom: 1.0,\r\n      status: \"N/A\",\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.loadDocument(this.props.url);\r\n  }\r\n\r\n  loadDocument = (url: string) => {\r\n    // const { documentZoom } = this.state;\r\n\r\n    let loadingTask = PdfJs.getDocument({\r\n      url,\r\n      cMapUrl: CMAP_URL,\r\n      cMapPacked: CMAP_PACKED,\r\n    }\r\n    );\r\n\r\n    let self = this;\r\n    this.setState({ status: \"loading\" });\r\n\r\n    loadingTask.promise.then(\r\n      (pdf: PdfJs.PDFDocumentProxy) => {\r\n        self.props.onReportPdfInfo(pdf);\r\n        // console.log(pdf);\r\n        this.setState({ pdf });\r\n        this.setState({ status: \"loaded\" });\r\n\r\n        console.log(\"pdf loaded\");\r\n      });\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\r\n    if (nextProps.url !== this.props.url) {\r\n      this.loadDocument(nextProps.url);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.state.pdf) {\r\n      const pdf = this.state.pdf;\r\n      pdf.destroy();\r\n    }\r\n  }\r\n\r\n\r\n  render() {\r\n    const { pdf } = this.state;\r\n    console.log(\"Pdf Viewer Renderer\");\r\n    console.log(this.props.position);\r\n\r\n    const pdfCanvas: CSSProperties = {\r\n      zoom: this.props.position.zoom,\r\n    }\r\n\r\n    if (pdf) {\r\n      return (\r\n        <div className=\"pdf-viewer\" style={pdfCanvas}>\r\n          <Page\r\n            pdf={pdf} index={this.props.pageNo}\r\n            key={`document-page-${this.props.pageNo}`}\r\n\r\n            position={this.props.position}\r\n          />\r\n        </div>\r\n      );\r\n\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfManager.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\DataStructure\\NeoStroke.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\StorageRenderWorker.js",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\DrawCurves.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\FileBrowser.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pageviewer\\PenBasedRenderWorker.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PrintPdfMain.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\Calibration\\CalibrationDialog.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_event.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfDocument.ts",["539","540"],"import * as PdfJs from \"pdfjs-dist\";\r\nimport { CoordinateTanslater, IPolygonArea } from \"../Coordinates\";\r\nimport { stringToDpiNum, } from \"../DataStructure/Structures\";\r\nimport { getDocumentId, } from \"../NcodePrint\";\r\nimport { IPageOverview } from \"../NcodePrint/PagesForPrint\";\r\nimport { ColorConvertMethod } from \"../NcodeSurface/CanvasColorConverter\";\r\nimport { getNcodeAtCanvasPixel, getNcodeRectAtCanvasPixel, ICellsOnSheetDesc } from \"../NcodeSurface/NcodeRasterizer\";\r\nimport { MappingItem } from \"../SurfaceMapper/MappingItem\";\r\nimport MappingStorage from \"../SurfaceMapper/MappingStorage\";\r\nimport NeoPdfPage, { IPdfPageCanvasDesc, PDF_VIEWPORT_DESC } from \"./NeoPdfPage\";\r\n\r\nPdfJs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${PdfJs.version}/pdf.worker.js`;\r\nlet CMAP_URL = \"./cmaps/\";\r\nlet CMAP_PACKED = true;\r\n\r\nexport type IGetDocumentOptions = {\r\n  url?: string,\r\n  fingerprint?: string,\r\n  cMapUrl?: string,\r\n  cMapPacked?: boolean,\r\n}\r\n\r\nexport type IPdfDocDesc = {\r\n  /** PDF url */\r\n  url: string,\r\n\r\n  /** PDF finger print */\r\n  fingerprint: string,\r\n\r\n  /** POD id = fingerprint + \"/\" + pagesPerSheet */\r\n  id: string,\r\n\r\n  /** total pages in pdf file */\r\n  numPages: number,\r\n};\r\n\r\n\r\n\r\n\r\nexport default class NeoPdfDocument {\r\n  _pdfDoc: PdfJs.PDFDocumentProxy = null;\r\n\r\n  _ready: PdfJs.PDFLoadingTask<PdfJs.PDFDocumentProxy>;\r\n\r\n  _url: string;\r\n\r\n  _fingerprint: string;\r\n\r\n  _id: string;\r\n\r\n  private _pages: NeoPdfPage[];\r\n\r\n  pagesOverview: IPageOverview[];\r\n\r\n  direction: \"portrait\" | \"landscape\";\r\n\r\n  load = async (options: IGetDocumentOptions) => {\r\n    await this.justLoad(options);\r\n\r\n    // const { url, cMapUrl, cMapPacked } = options;\r\n\r\n    // this._url = url;\r\n    // this._ready = PdfJs.getDocument(\r\n    //   {\r\n    //     url: url,\r\n    //     cMapUrl: cMapUrl ? cMapUrl : CMAP_URL,\r\n    //     cMapPacked: cMapPacked ? cMapPacked : CMAP_PACKED,\r\n    //   });\r\n\r\n    // const _pdfDoc = await this._ready.promise;\r\n    // this._pdfDoc = _pdfDoc;\r\n    // this._fingerprint = _pdfDoc.fingerprint;\r\n\r\n    // page를 로드한다\r\n    this._pages = [];\r\n    for (let i = 1; i <= this._pdfDoc.numPages; i++) {\r\n      const neoPage = new NeoPdfPage(this, i);\r\n      this._pages.push(neoPage);\r\n    }\r\n\r\n    await this.setPageOverview(this);\r\n    return this;\r\n  }\r\n\r\n  destroy = () => {\r\n    this._pages = [];\r\n    this._pdfDoc.destroy();\r\n  }\r\n\r\n  justLoad = async (options: IGetDocumentOptions) => {\r\n    const { url, cMapUrl, cMapPacked } = options;\r\n\r\n    this._url = url;\r\n    this._ready = PdfJs.getDocument(\r\n      {\r\n        url: url,\r\n        cMapUrl: cMapUrl ? cMapUrl : CMAP_URL,\r\n        cMapPacked: cMapPacked ? cMapPacked : CMAP_PACKED,\r\n      });\r\n\r\n    const pdfDoc = await this._ready.promise;\r\n    this._pdfDoc = pdfDoc;\r\n    this._fingerprint = pdfDoc.fingerprint;\r\n\r\n    return this;\r\n  }\r\n\r\n  get numPages() {\r\n    return this._pdfDoc.numPages;\r\n  }\r\n\r\n  get url() {\r\n    return this._url;\r\n  }\r\n\r\n  get fingerprint() {\r\n    return this._fingerprint;\r\n  }\r\n\r\n  getPageAsync = async (pageNo: number) => {\r\n    await this._pages[pageNo - 1]._ready;\r\n    return this._pages[pageNo - 1];\r\n  }\r\n\r\n  /** page가 로드된 것이 확실할 때만 쓸 것! */\r\n  getPage = (pageNo: number) => {\r\n    if (!this._pages[pageNo - 1]._loaded) {\r\n      throw new Error(`PDF page ${pageNo} has not been loaded`);\r\n    }\r\n\r\n    return this._pages[pageNo - 1];\r\n  }\r\n\r\n  getMetadata = async () => {\r\n    return this._pdfDoc.getMetadata();\r\n  }\r\n\r\n  public renderPages_dpi = async (pageNums: number[], dpi: number, colorConvertMode?: ColorConvertMethod)\r\n    : Promise<IPdfPageCanvasDesc[]> => {\r\n    const pdfDpi = dpi;\r\n\r\n    const promises: Promise<IPdfPageCanvasDesc>[] = [];\r\n    for (let i = 0; i < pageNums.length; i++) {\r\n      const pageNo = pageNums[i];\r\n      const neoPage = await this.getPageAsync(pageNo);\r\n      const pr = neoPage.render_dpi(i, pdfDpi).then(async (canvasDesc) => {\r\n        return await neoPage.convertColor(canvasDesc, colorConvertMode);\r\n      })\r\n      promises.push(pr);\r\n    }\r\n    const descs = await Promise.all(promises);\r\n\r\n    const pageImageDescs: IPdfPageCanvasDesc[] = new Array(descs.length);\r\n    descs.forEach(async (canvasDesc) => {\r\n      const { index } = canvasDesc;\r\n      pageImageDescs[index] = canvasDesc;\r\n      // console.log(`[Multipage] page rendered ${canvasDesc.pdfPageInfo.pageNo}, index ${index}`);\r\n    });\r\n\r\n    // let converterPromises = [];\r\n    // descs.forEach(async (canvasDesc) => {\r\n    //   const { index } = canvasDesc;\r\n    //   pageImageDescs[index] = canvasDesc;\r\n\r\n    //   const pdfCanvas = canvasDesc.canvas;\r\n    //   const converter = new CanvasColorConverter(pdfCanvas);\r\n    //   const pr = converter.convert(colorConvertMode);\r\n    //   converterPromises.push(pr);\r\n    // });\r\n    return pageImageDescs;\r\n  }\r\n\r\n\r\n  registerMappingItem = (pageImagesDesc: IPdfPageCanvasDesc[], ncodePlane: ICellsOnSheetDesc, assignNewCode: boolean) => {\r\n    for (let i = 0; i < ncodePlane.ncodeAreas.length; i++) {\r\n      const desc = pageImagesDesc[i];\r\n      const pdfRect = desc.drawnRect;\r\n      const ncode = ncodePlane.ncodeAreas[i];\r\n\r\n      const mapData = new MappingItem();\r\n\r\n      /** canvas 좌표계 */\r\n      const { x, y, unit, width, height } = pdfRect;\r\n      const dpi = stringToDpiNum(unit);\r\n\r\n      /** Ncode 좌표계 */\r\n      const pt0_nu = getNcodeAtCanvasPixel({ x, y, dpi }, ncodePlane);\r\n      const pt1_nu = getNcodeAtCanvasPixel({ x: x + width, y: y + height, dpi }, ncodePlane);\r\n\r\n      const pdfRect_nu = getNcodeRectAtCanvasPixel({ dpi, x, y, width, height }, ncodePlane);\r\n\r\n      /** 페이지에 해당하는 ncode가 인쇄된 영역 */\r\n      const r_nu = ncode.rect;\r\n      const polygon: IPolygonArea = [\r\n        { x: r_nu.x, y: r_nu.y },\r\n        { x: r_nu.x + r_nu.width, y: r_nu.y },\r\n        { x: r_nu.x + r_nu.width, y: r_nu.y + r_nu.height },\r\n        { x: r_nu.x, y: r_nu.y + r_nu.height },\r\n      ];\r\n\r\n      mapData.setNcodeArea({\r\n        pageInfo: ncode.pageInfo,\r\n        pdfDrawnRect: { ...pdfRect_nu },\r\n        npageArea: polygon,\r\n      });\r\n\r\n\r\n      /** PDF 좌표계 */\r\n      mapData.setPdfArea({\r\n        pdfPageInfo: { ...desc.pdfPageInfo },\r\n        rect: {\r\n          unit: \"pu\",\r\n          x: 0, y: 0,\r\n          width: desc.width_pu,\r\n          height: desc.height_pu,\r\n        }\r\n      });\r\n\r\n      const trans = new CoordinateTanslater();\r\n      trans.calc(mapData);\r\n      const pageNo = desc.pdfPageInfo.pageNo;\r\n      const page = this.getPage(pageNo);\r\n      page.setTranslater(trans);\r\n\r\n      if (assignNewCode) {\r\n        const st = MappingStorage.getInstance();\r\n        st.register(trans);\r\n\r\n\r\n      }\r\n      // trans.dump(`[dump-${this._url}]-${i} `);\r\n    }\r\n\r\n    if (assignNewCode) {\r\n      const st = MappingStorage.getInstance();\r\n      // st.dump(\"MAP\");\r\n    }\r\n  }\r\n\r\n  setDocumentId = (pagesPerSheet: number) => {\r\n    this._id = getDocumentId(this._fingerprint, pagesPerSheet);\r\n  }\r\n\r\n  get id() {\r\n    return this._id;\r\n  }\r\n\r\n  setPageOverview = async (pdf) => {\r\n    // const pdf = this.props.pdf;\r\n    this.pagesOverview = new Array(pdf.numPages + 1);\r\n    // const { pagesPerSheet } = this.printOption;\r\n\r\n    let numPortraitPages = 0;\r\n    let numLandscapePages = 0;\r\n\r\n    for (let i = 0; i < pdf.numPages; i++) {\r\n      const page = await pdf.getPageAsync(i + 1);\r\n      const vpt: PDF_VIEWPORT_DESC = page.getViewport({ scale: 1, rotation: 0 });\r\n      const { width, height } = vpt;\r\n\r\n      const landscape = width > height;\r\n      landscape ? numLandscapePages++ : numPortraitPages++;\r\n\r\n      const pageOverview = {\r\n        rotation: vpt.rotation,\r\n        landscape,\r\n        sizePu: { width, height },\r\n      }\r\n      this.pagesOverview[i] = pageOverview;\r\n    }\r\n\r\n\r\n    if (numPortraitPages >= numLandscapePages) {\r\n      this.direction = \"portrait\";\r\n    } else {\r\n      this.direction = \"landscape\";\r\n    }\r\n\r\n    return this.direction;\r\n  }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_const.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pen_util_func.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\renderer\\pdf\\Page.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_enum.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\neosmartpen\\pencomm\\pencomm_base.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\UtilFunc.ts",["541","542"],"export function compareObject(curr: Object, next: Object, header: string = \"\") {\r\n  for (const [key, value] of Object.entries(next)) {\r\n    if (curr[key] !== value) {\r\n      console.log(`[${header}] state[${key}] was changed, from \"${curr[key]} to \"${value}\"`);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nexport function uuidv4(): string {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    // let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n    let r = Math.random() * 16 | 0, v = c === 'x' ? r : ((r & 0x3) | 0x8);\r\n    return v.toString(16);\r\n  });\r\n}\r\n\r\n\r\nexport function getDocumentId(fingerprint: string, pagesPerSheet: number): string {\r\n  return fingerprint + \"/\" + pagesPerSheet.toString();\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceSplitter.ts",["543","544","545"],"\r\nimport { IRectDpi, ISize } from \"../DataStructure/Structures\";\r\nimport { IPrintOption, MediaSize } from \"../NcodePrint/PrintDataTypes\";\r\nimport { IAreasDesc } from \"./NcodeRasterizer\";\r\nimport { getSurfaceSize_px_600dpi } from \"./SurfaceInfo\";\r\n// import { isPortrait } from \"./SurfaceInfo\";\r\nexport const PAGES_CELL_SPACING = 120; // 600dpi px, 5.08mm\r\n\r\n// http://www.javascripter.net/math/primes/factorization.htm\r\nfunction factor(n: number) {\r\n  if (isNaN(n) || !isFinite(n) || n % 1 !== 0 || n === 0) return '' + n;\r\n  if (n < 0) return '-' + factor(-n);\r\n  let minFactor = leastFactor(n);\r\n  if (n === minFactor) return n;\r\n\r\n  const recursive = factor(n / minFactor);\r\n  // console.log(`[recursive] ${typeof recursive}`);\r\n\r\n  return [minFactor].concat(recursive);\r\n}\r\n\r\n// find the least factor in n by trial division\r\nfunction leastFactor(n: number) {\r\n  if (isNaN(n) || !isFinite(n)) return NaN;\r\n  if (n === 0) return 0;\r\n  if (n % 1 || n * n < 2) return 1;\r\n  if (n % 2 === 0) return 2;\r\n  if (n % 3 === 0) return 3;\r\n  if (n % 5 === 0) return 5;\r\n  let m = Math.sqrt(n);\r\n  for (let i = 7; i <= m; i += 30) {\r\n    if (n % i === 0) return i;\r\n    if (n % (i + 4) === 0) return i + 4;\r\n    if (n % (i + 6) === 0) return i + 6;\r\n    if (n % (i + 10) === 0) return i + 10;\r\n    if (n % (i + 12) === 0) return i + 12;\r\n    if (n % (i + 16) === 0) return i + 16;\r\n    if (n % (i + 22) === 0) return i + 22;\r\n    if (n % (i + 24) === 0) return i + 24;\r\n  }\r\n  return n;\r\n}\r\n\r\nfunction findBestCombination(factored: number[]) {\r\n  let min_left = 1, min_right = 1;\r\n\r\n  const reducer = (mul: number, curr: number) => mul * curr;\r\n\r\n  for (let i = 1; i < factored.length; i++) {\r\n    const left = factored.slice(0, i).reduce(reducer, 1);\r\n    const right = factored.slice(i, factored.length + 1).reduce(reducer, 1);\r\n\r\n    if (left > right) break;\r\n    min_left = left;\r\n    min_right = right;\r\n  }\r\n\r\n  return [min_left, min_right];\r\n}\r\n\r\nfunction findRotation(rows: number, cols: number, srcDirection: string): number {\r\n  const srcSize = getSurfaceSize_px_600dpi(MediaSize.A4, srcDirection === \"landscape\");\r\n  let rotation = 0;\r\n\r\n  const cellSize = {\r\n    width: srcSize.width / cols,\r\n    height: srcSize.height / rows,\r\n  };\r\n\r\n  let cellSize_90 = {\r\n    width: srcSize.height / cols,\r\n    height: srcSize.width / rows,\r\n  };\r\n\r\n  if (srcDirection === \"landscape\") {\r\n    cellSize_90 = {\r\n      width: srcSize.height / rows,\r\n      height: srcSize.width / cols,\r\n    };\r\n  }\r\n\r\n\r\n  const scale_x = cellSize.width / srcSize.width;\r\n  const scale_y = cellSize.height / srcSize.width;\r\n  const scale_normal = Math.min(scale_x, scale_y);\r\n\r\n  const scale_rev_x = cellSize_90.width / srcSize.width;\r\n  const scale_rev_y = cellSize_90.height / srcSize.height;\r\n  const scale_rev = Math.min(scale_rev_x, scale_rev_y);\r\n\r\n  if (scale_rev > scale_normal) {\r\n    rotation = 90;\r\n  }\r\n\r\n  return rotation;\r\n}\r\n\r\n\r\nexport function getCellMatrixShape(numItems: number, srcDirection: string): { rows: number, cols: number, rotation: number } {\r\n  const factored = [1].concat(factor(numItems));\r\n  let [rows, cols] = findBestCombination(factored);\r\n\r\n  let rotation = findRotation(rows, cols, srcDirection);\r\n\r\n  /**\r\n   * 정수 제곱 개의 cell을 가지는 경우에는 90도 돌려서 출력할 필요 없음\r\n   */\r\n  if (numItems === 1) { rows = 1; cols = 1; rotation = 0; }\r\n  else if (numItems === 4) { rows = 2; cols = 2; rotation = 0; }\r\n  else if (numItems === 9) { rows = 3; cols = 3; rotation = 0; }\r\n  else if (numItems === 16) { rows = 4; cols = 4; rotation = 0; }\r\n  else if (numItems === 25) { rows = 5; cols = 5; rotation = 0; }\r\n  /**\r\n   * 아래의 면분할 숫자들은, 각 cell을 출력할 때 90도 돌려서 출력\r\n   * 90도 돌려서 출력하는 것은 ctx.rotate를 쓰도록 한다.\r\n   *    ctx.save();\r\n   *    ctx.translate(canvas.width, 0);\r\n   *    ctx.rotate( -90 * Math.PI/180);\r\n   *    ... drawing operation ...\r\n   *    ctx.restore();\r\n   *\r\n   * rows, cols는 90도 돌아갔다고 가정하고 나눈 면을 뜻한다.\r\n   *\r\n   *    r=1, c=1\r\n   *    +-----+           r=1, c=2\r\n   *    |     |           +---+---+\r\n   *    |  1  |     =>    | 1 | 2 |\r\n   *    |     |           +---+---+\r\n   *    +-----+\r\n   */\r\n  else if (numItems === 2) { rows = 1; cols = 2; rotation = 90; }\r\n  else if (numItems === 8) { rows = 2; cols = 4; rotation = 90; }\r\n  else if (numItems === 18) { rows = 3; cols = 6; rotation = 90; }\r\n  else if (numItems === 32) { rows = 4; cols = 8; rotation = 90; }\r\n\r\n  // else if (numItems === 3) { rows = 1; cols = 3; rotation = 90; }\r\n\r\n  return { rows, cols, rotation };\r\n}\r\n\r\nexport function devideSurfaceAreaTo(printOptions: IPrintOption, szSrc: ISize, numItems: number)\r\n  : IAreasDesc {\r\n  const cellSpace = PAGES_CELL_SPACING;\r\n\r\n  let { rows, cols, rotation } = getCellMatrixShape(numItems, printOptions.direction);\r\n\r\n  // if (rotation === 90) {\r\n  //   const { width, height } = szSrc;\r\n  //   szSrc = { width: height, height: width };\r\n  // }\r\n\r\n  // sheet가 landscape이면 면을 나누는 row, col을 바꾼다.\r\n  if (printOptions.direction === \"landscape\") {\r\n    const temp = rows;\r\n    rows = cols;\r\n    cols = temp;\r\n  }\r\n\r\n  const rcSrc = { x: 0, y: 0, ...szSrc };\r\n  const areas: IRectDpi[] = devideSurfaceAreaToMxN(rcSrc, rows, cols, cellSpace);\r\n  return { rotation, areas };\r\n}\r\n\r\n\r\n\r\nfunction devideSurfaceAreaToMxN(rcSrc: IRectDpi, rows: number, cols: number, cellSpace: number): IRectDpi[] {\r\n  const retAreas = [];\r\n  const areas = devideVertical(rcSrc, rows, cellSpace);\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    const cells = devideHorizontal(areas[row], cols, cellSpace);\r\n    retAreas.push(...cells);\r\n  }\r\n\r\n  return retAreas;\r\n}\r\n\r\n\r\n/**\r\n * 영역 세로로 나누기 ( cellSpace 만큼 띄우고)\r\n */\r\nfunction devideVertical(rcSrc: IRectDpi, numItems: number, cellSpace: number): IRectDpi[] {\r\n  const areas: IRectDpi[] = new Array(0);\r\n\r\n  const width = rcSrc.width;\r\n  const height = (rcSrc.height - cellSpace * (numItems - 1)) / numItems;\r\n\r\n  const x = rcSrc.x\r\n  let y = rcSrc.y\r\n  for (let i = 0; i < numItems; i++) {\r\n    const rc = {\r\n      x: Math.floor(x),\r\n      y: Math.floor(y),\r\n      width: Math.floor(width),\r\n      height: Math.floor(height),\r\n    };\r\n    areas.push(rc);\r\n    y += height + cellSpace;\r\n  }\r\n\r\n  return areas;\r\n}\r\n\r\n\r\n\r\n/**\r\n * 영역 가로로 나누기 ( cellSpace 만큼 띄우고)\r\n */\r\nfunction devideHorizontal(rcSrc: IRectDpi, numItems: number, cellSpace: number): IRectDpi[] {\r\n  const areas: IRectDpi[] = new Array(0);\r\n\r\n  const width = (rcSrc.width - cellSpace * (numItems - 1)) / numItems;\r\n  const height = rcSrc.height;\r\n\r\n  let x = rcSrc.x\r\n  const y = rcSrc.y\r\n  for (let i = 0; i < numItems; i++) {\r\n    const rc = {\r\n      x: Math.floor(x),\r\n      y: Math.floor(y),\r\n      width: Math.floor(width),\r\n      height: Math.floor(height),\r\n    };\r\n    areas.push(rc);\r\n    x += width + cellSpace;\r\n  }\r\n\r\n  return areas;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PagesForPrint.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageOrientation.jsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingItem.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\SurfaceMapper\\MappingStorage.ts",["546","547","548","549"],"import { CoordinateTanslater, IMappingParams, IPdfPageDesc } from \"../Coordinates\";\r\nimport { INcodeSOBPxy, IPageSOBP } from \"../DataStructure/Structures\";\r\nimport { isSamePage } from \"../NcodeSurface\";\r\nimport { IPdfDocDesc } from \"../NeoPdf/NeoPdfDocument\";\r\n\r\nlet _instance: MappingStorage = null;\r\nconst LOCAL_STORAGE_ID = \"GridaBoard_codeMappingInfo_v2\";\r\n\r\nexport default class MappingStorage {\r\n  _arrMapped: IMappingParams[] = [];\r\n\r\n  private constructor() {\r\n  }\r\n\r\n  static getInstance() {\r\n    if (_instance) return _instance;\r\n\r\n    _instance = new MappingStorage();\r\n    return _instance;\r\n  }\r\n\r\n  register = (item: CoordinateTanslater) => {\r\n    const params = item.mappingParams;\r\n\r\n    let now = new Date();\r\n    let timeStr =\r\n      `${addZeros(now.getFullYear(), 2)}/` +\r\n      `${addZeros(now.getMonth() + 1, 2)}/` +\r\n      `${addZeros(now.getDate(), 2)} ` +\r\n      `${addZeros(now.getHours(), 2)}:` +\r\n      `${addZeros(now.getMinutes(), 2)}:` +\r\n      `${addZeros(now.getSeconds(), 2)}.` +\r\n      `${addZeros(now.getMilliseconds(), 4)}`;\r\n\r\n    params.timeString = timeStr; // JSON.stringify(new Date());\r\n    this._arrMapped.push(params);\r\n  }\r\n\r\n  /**\r\n   * pen down시에 새로운 SOBP라면, 관련된 PDF가 있는지 찾을 때 쓰인다\r\n   */\r\n  findPdfPage = (ncodeXy: INcodeSOBPxy) => {\r\n    // const pdfPageInfo: IPdfPageDesc = null;\r\n    // const pdfDocInfo: IPdfDocDesc = null;\r\n\r\n    // let found = -1;\r\n    // for ( let i=0; i<this._arrMapped.length; i++ ) {\r\n    //   const trans = this._arrMapped[i];\r\n    //   if ( isSamePage(ncodeXy as IPageSOBP, trans.pageInfo) ) {\r\n    //     found = i;\r\n    //     break;\r\n    //   }\r\n    // }\r\n\r\n\r\n    /** 원래는 폴리곤에 속했는지 점검해야 하지만, 현재는 같은 페이지인지만 점검한다  2020/12/06 */\r\n    const found = this._arrMapped.find(trans => isSamePage(ncodeXy, trans.pageInfo));\r\n    return found;\r\n  }\r\n\r\n  /**\r\n   * Ncode가 발행된 적이 있는지를 점검하기 위해서 쓰인다.\r\n   */\r\n  findMappedNcode = (pdfId: string) => {\r\n    const found = this._arrMapped.find(trans => pdfId === trans.pdfDesc.id);\r\n    return found;\r\n  }\r\n\r\n  dump = (prefix: string) => {\r\n    console.log(`[${prefix}]----------------------------------------------------------------------`);\r\n    const str = JSON.stringify(this._arrMapped, null, \"  \");\r\n    const arr = str.split(\"\\n\");\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n      console.log(`[${prefix}] ${arr[i]}`);\r\n    }\r\n    console.log(`[${prefix}]----------------------------------------------------------------------`);\r\n  }\r\n\r\n\r\n\r\n  storeMappingInfo = () => {\r\n    if (storageAvailable(\"localStorage\")) {\r\n      const key = LOCAL_STORAGE_ID;\r\n      const value = JSON.stringify(this._arrMapped);\r\n      // console.log(`Pdf Ncode Info Saved   ${key}: ${value}`);\r\n      localStorage.setItem(key, value);\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * app이 기동되면 반드시 처음에 load하자\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  loadMappingInfo = () => {\r\n    if (storageAvailable(\"localStorage\")) {\r\n      const key = LOCAL_STORAGE_ID;\r\n      const value = localStorage.getItem(key);\r\n\r\n      if (value) {\r\n        this._arrMapped = JSON.parse(value);\r\n\r\n        this._arrMapped.sort(function (a, b) {\r\n          if (a.timeString < b.timeString) return 1;\r\n          else if (a.timeString > b.timeString) return -1;\r\n          else return 0;\r\n        });\r\n\r\n        // const debug = JSON.stringify(this._arrMapped);\r\n        // console.log(`Pdf Ncode Info Loaded   ${key}: ${debug}`);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\nfunction storageAvailable(type) {\r\n  let storage;\r\n  try {\r\n    storage = window[type];\r\n    let x = \"__storage_test__\";\r\n    storage.setItem(x, x);\r\n    storage.removeItem(x);\r\n    return true;\r\n  } catch (e) {\r\n    return (\r\n      e instanceof DOMException &&\r\n      // Firefox를 제외한 모든 브라우저\r\n      (e.code === 22 ||\r\n        // Firefox\r\n        e.code === 1014 ||\r\n        // 코드가 존재하지 않을 수도 있기 떄문에 이름 필드도 확인합니다.\r\n        // Firefox를 제외한 모든 브라우저\r\n        e.name === \"QuotaExceededError\" ||\r\n        // Firefox\r\n        e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\r\n      // 이미 저장된 것이있는 경우에만 QuotaExceededError를 확인하십시오.\r\n      storage &&\r\n      storage.length !== 0\r\n    );\r\n  }\r\n}\r\n\r\n\r\nfunction addZeros(num, digit) {\r\n  // 자릿수 맞춰주기\r\n  let zero = \"\";\r\n  num = num.toString();\r\n  if (num.length < digit) {\r\n    for (let i = 0; i < digit - num.length; i++) {\r\n      zero += \"0\";\r\n    }\r\n  }\r\n  return zero + num;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NeoPdf\\NeoPdfPage.ts",["550","551","552"],"import * as PdfJs from \"pdfjs-dist\";\r\nimport { CoordinateTanslater, IPdfPageDesc } from \"../Coordinates\";\r\nimport { IRectDpi,  } from \"../DataStructure/Structures\";\r\nimport { uuidv4 } from \"../NcodePrint\";\r\nimport { CanvasColorConverter } from \"../NcodeSurface\";\r\nimport { ColorConvertMethod } from \"../NcodeSurface/CanvasColorConverter\";\r\nimport { PDF_DEFAULT_DPI } from \"../NcodeSurface/NcodeConstans\";\r\nimport NeoPdfDocument from \"./NeoPdfDocument\";\r\nexport type PDF_VIEWPORT_DESC = PdfJs.ViewportParameters & PdfJs.PDFPageViewport;\r\n\r\n\r\n\r\nexport interface IPdfPageCanvasDesc {\r\n  pdfPageInfo: IPdfPageDesc,\r\n\r\n  /** splitted canvas 내의 index */\r\n  index: number,\r\n\r\n  /** 그려진 canvas */\r\n  canvas: HTMLCanvasElement,\r\n  rotation: number,\r\n\r\n\r\n  width_pu: number,\r\n  height_pu: number,\r\n\r\n  drawnRect: IRectDpi,\r\n}\r\n\r\n\r\nexport default class NeoPdfPage {\r\n  _pdfPage: PdfJs.PDFPageProxy;\r\n\r\n  _ready: PdfJs.PDFPromise<PdfJs.PDFPageProxy>;\r\n\r\n  _loaded: boolean = false;\r\n\r\n  private _defaultViewport: PDF_VIEWPORT_DESC;\r\n\r\n  _pageNo: number;\r\n\r\n  _doc: NeoPdfDocument;\r\n\r\n  _translater: CoordinateTanslater;\r\n\r\n  constructor(neoPdf: NeoPdfDocument, pageNo: number) {\r\n    this._pageNo = pageNo;\r\n    this._doc = neoPdf;\r\n\r\n\r\n    this._ready = neoPdf._pdfDoc.getPage(pageNo);\r\n    this._ready.then(_pdfPage => {\r\n      this._pdfPage = _pdfPage;\r\n      this._loaded = true;\r\n      this._defaultViewport = _pdfPage.getViewport({ scale: 1 });\r\n    });\r\n  }\r\n\r\n  getPage = async () => {\r\n    await this._ready;\r\n    return this._pdfPage;\r\n  }\r\n\r\n  render = async (params: PdfJs.PDFRenderParams) => {\r\n    await this._ready;\r\n    const renderTask: PdfJs.PDFRenderTask = this._pdfPage.render(params);\r\n    const ret = await renderTask.promise;\r\n    return ret;\r\n  }\r\n\r\n  public get viewport(): PDF_VIEWPORT_DESC {\r\n    return this._defaultViewport;\r\n  }\r\n\r\n  getViewport = (params: PdfJs.ViewportParameters): PDF_VIEWPORT_DESC => {\r\n    return this._pdfPage.getViewport(params);\r\n  }\r\n\r\n\r\n  setTranslater = (translater: CoordinateTanslater) => {\r\n    this._translater = translater;\r\n  }\r\n\r\n\r\n  public render_dpi = async (index: number, dpi: number)\r\n    : Promise<IPdfPageCanvasDesc> => {\r\n\r\n    await this._ready;\r\n\r\n    const pageNo = this._pageNo;\r\n    const scratchCanvas = document.createElement(\"canvas\");\r\n    const canvas = scratchCanvas;\r\n    const uuid = uuidv4();\r\n    canvas.id = `scratchCanvas-${pageNo}-${uuid}`;\r\n\r\n    const page = this._pdfPage;\r\n\r\n    let viewport: PDF_VIEWPORT_DESC = this.viewport;\r\n    const rotation = viewport.rotation;\r\n    let ctx = canvas.getContext('2d');\r\n\r\n    const PRINT_RESOLUTION = dpi;\r\n    const PRINT_UNITS = PRINT_RESOLUTION / PDF_DEFAULT_DPI;\r\n    // const CSS_UNITS = 96.0 / PDF_DEFAULT_DPI;\r\n\r\n    canvas.width = Math.floor(viewport.width * PRINT_UNITS);\r\n    canvas.height = Math.floor(viewport.height * PRINT_UNITS);\r\n\r\n    // const cssWidth = Math.floor(viewport.width * CSS_UNITS);\r\n    // const cssHeight = Math.floor(viewport.height * CSS_UNITS);\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgb(255, 255, 255)\";\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    ctx.restore();\r\n\r\n\r\n    // return Promise.resolve({ index, canvas, rotation, pageNo });\r\n\r\n    const renderContext = {\r\n      canvasContext: ctx,\r\n      transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0],\r\n      viewport: page.getViewport({\r\n        scale: 1,\r\n        rotation: viewport.rotation\r\n      }),\r\n      intent: \"print\"\r\n    };\r\n\r\n\r\n    let renderTask = page.render(renderContext);\r\n    await renderTask.promise;\r\n\r\n    const doc = this._doc;\r\n    const result: IPdfPageCanvasDesc = {\r\n      pdfPageInfo: {\r\n        url: doc.url,\r\n        fingerprint: doc.fingerprint,\r\n        numPages: doc.numPages,\r\n        pageNo: this._pageNo,\r\n      },\r\n\r\n      index,\r\n      canvas,\r\n      rotation,\r\n\r\n      width_pu: viewport.width,\r\n      height_pu: viewport.height,\r\n      drawnRect: {\r\n        unit: \"600dpi\",\r\n        x: 0, y: 0, width: 0, height: 0,\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public convertColor = async (canvasDesc: IPdfPageCanvasDesc, colorConvertMode?: ColorConvertMethod) => {\r\n    if (colorConvertMode) {\r\n      const pdfCanvas = canvasDesc.canvas;\r\n      const converter = new CanvasColorConverter(pdfCanvas);\r\n      await converter.convert(colorConvertMode);\r\n    }\r\n\r\n    return canvasDesc;\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\DataStructure\\Structures.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\SurfaceInfo.ts",["553","554","555","556","557"],"import { paperType } from \"./NcodeSurfaceDataJson\";\r\nimport { INcodeSurfaceDesc, IPaperSize } from \"./SurfaceDataTypes\";\r\n\r\nimport { IPageSOBP, INcodeSOBPxy, ISize, UNIT_TO_DPI } from \"../DataStructure/Structures\";\r\nimport { INCH_TO_MM_SCALE, NCODE_TO_INCH_SCALE, PDF_DEFAULT_DPI } from \"./NcodeConstans\";\r\n\r\n\r\n/**\r\n *\r\n * @param pageInfo\r\n */\r\nexport function isPlatePaper(pageInfo: IPageSOBP): boolean {\r\n  const { owner, book } = pageInfo;\r\n  if (owner === 1013 && book === 2) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param coordInfo\r\n */\r\nexport function isPUI(pageInfo: INcodeSOBPxy): boolean {\r\n  const { owner, book, page, } = pageInfo;\r\n  // console.log( `isPUI: ${owner}.${book}.${page}`);\r\n  if (owner === 27 && book === 161 && page === 1) {\r\n    return true;\r\n  }\r\n\r\n  if (owner === 1013 && book === 1) {\r\n    // page === 4, Smart plate\r\n    // page === 1, Plate paper\r\n\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param pageInfo\r\n * @return paper size in NU\r\n */\r\nfunction getNPaperSize_nu(item: IPageSOBP | INcodeSurfaceDesc): ISize {\r\n  let desc = item as INcodeSurfaceDesc;\r\n\r\n  if (!item.hasOwnProperty(\"margin\")) {\r\n    const pageInfo = item as IPageSOBP;\r\n    desc = getNPaperInfo(pageInfo);\r\n  }\r\n  const margin = desc.margin;\r\n  return {\r\n    width: margin.Xmax - margin.Xmin,\r\n    height: margin.Ymax - margin.Ymin\r\n  };\r\n}\r\n\r\n\r\nfunction getNPaperSize_dpi(item: IPageSOBP | INcodeSurfaceDesc, dpi: number): ISize {\r\n  // const { section, owner, book, page } = pageInfo;\r\n  const size = getNPaperSize_nu(item);\r\n\r\n  return {\r\n    width: size.width * NCODE_TO_INCH_SCALE * dpi,\r\n    height: size.height * NCODE_TO_INCH_SCALE * dpi,\r\n  }\r\n}\r\n\r\nexport function getNPaperSize_pu(item: IPageSOBP | INcodeSurfaceDesc): ISize {\r\n  return getNPaperSize_dpi(item, PDF_DEFAULT_DPI);\r\n}\r\n\r\n\r\nexport function getMediaSize_pu(mediaType: IPaperSize): ISize {\r\n  const { width, height } = mediaType;\r\n\r\n  return {\r\n    width: width * INCH_TO_MM_SCALE * PDF_DEFAULT_DPI,\r\n    height: height * INCH_TO_MM_SCALE * PDF_DEFAULT_DPI,\r\n  }\r\n}\r\n\r\n/**\r\n * paper size를 해당 inch 단위로 돌려 준다.\r\n * @param pageInfo\r\n */\r\nexport function getNPaperInfo(pageInfo: IPageSOBP): INcodeSurfaceDesc {\r\n  const { section, owner, book } = pageInfo;\r\n\r\n\r\n  let found = paperType.paperA4_dummy;\r\n  let found_key = \"paperA4_dummy\";\r\n\r\n  let keys = Object.keys(paperType);\r\n  for (let j = 0; j < keys.length; j++) {\r\n    let key = keys[j];\r\n    let value = paperType[key];\r\n\r\n    let idx = value.books.indexOf(book);\r\n    if (idx > -1) {\r\n      if (section === value.section && owner === value.owner) {\r\n        found = value;\r\n        found_key = key;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  const desc: INcodeSurfaceDesc = {\r\n    id: found_key,\r\n    pageInfo,\r\n    margin: {\r\n      Xmin: found.Xmin,\r\n      Xmax: found.Xmax,\r\n      Ymin: found.Ymin,\r\n      Ymax: found.Ymax,\r\n    },\r\n    glyphData: \"\",\r\n  };\r\n\r\n  return desc;\r\n}\r\n\r\n\r\n\r\nexport function getSurfaceSize_dpi(size: IPaperSize, dpi: number, isLandscape: boolean = false) {\r\n  let numerator = UNIT_TO_DPI[size.unit];\r\n  const ratio = 1.0;\r\n\r\n  let width = size.width * ratio * dpi / numerator;\r\n  let height = size.height * ratio * dpi / numerator;\r\n\r\n  width = Math.floor(width);\r\n  height = Math.floor(height);\r\n\r\n  if (isLandscape) {\r\n    return {\r\n      width: height,\r\n      height: width,\r\n    };\r\n  }\r\n\r\n  return {\r\n    width: width,\r\n    height: height,\r\n  };\r\n}\r\n\r\n\r\nexport function getSurfaceSize_px_600dpi(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"600dpi\"], isLandscape);\r\n}\r\n\r\nexport function getSurfaceSize_inch(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, 1, isLandscape);\r\n}\r\n\r\nexport function getSurfaceSize_mm(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"mm\"], isLandscape);\r\n}\r\n\r\nexport function getSurfaceSize_css(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"css\"], isLandscape);\r\n}\r\n\r\n\r\nexport function getSurfaceSize_pu(size: IPaperSize, isLandscape: boolean = false) {\r\n  return getSurfaceSize_dpi(size, UNIT_TO_DPI[\"pu\"], isLandscape);\r\n}\r\n\r\nexport function isPortrait(size: ISize) {\r\n  return size.width < size.height;\r\n}\r\n\r\nexport function getCssDpi() {\r\n  return UNIT_TO_DPI[\"css\"];\r\n}\r\n\r\n\r\n\r\nexport function isSamePage(pg1: IPageSOBP, pg2: IPageSOBP): boolean {\r\n  if (pg1.page !== pg2.page || pg1.book !== pg2.book || pg1.owner !== pg2.owner || pg1.section !== pg2.section) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeRasterizer.tsx",["558","559","560","561","562","563","564","565","566"],"import { UNIT_TO_DPI, IPageSOBP, IPointDpi, IRectDpi, autoSetDpi, } from \"../DataStructure/Structures\";\r\n\r\nimport NcodeFetcher from \"./NcodeFetcher\";\r\nimport { INcodeSurfaceDesc, IPaperSize } from \"./SurfaceDataTypes\";\r\n\r\n// import expect from \"expect.js\";\r\nimport { getSurfaceSize_dpi } from \"./SurfaceInfo\";\r\nimport { devideSurfaceAreaTo, getCellMatrixShape } from \"./SurfaceSplitter\";\r\nimport { IPrintOption } from \"../NcodePrint/PrintDataTypes\";\r\nimport { NCODE_CLASS6_NUM_DOTS } from \"./NcodeConstans\";\r\n\r\n// import { PrintContextConsumer } from \"react-to-print\";\r\n\r\nconst debugNcode_w = 200;\r\nconst debugNcode_h = 500;\r\n\r\n\r\n\r\nexport function drawArrow(context: CanvasRenderingContext2D, fromx: number, fromy: number, tox: number, toy: number) {\r\n  let headlen = 100; // length of head in pixels\r\n  let dx = tox - fromx;\r\n  let dy = toy - fromy;\r\n  let angle = Math.atan2(dy, dx);\r\n\r\n  context.beginPath();\r\n  context.moveTo(fromx, fromy);\r\n  context.lineTo(tox, toy);\r\n  context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));\r\n  context.moveTo(tox, toy);\r\n  context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));\r\n  context.stroke();\r\n}\r\n\r\nconst codePos: { [key: string]: { code: number; dx: number, dy: number, } } = {\r\n  \"u\": { code: 0, dx: +1, dy: +1 },\r\n  \"d\": { code: 1, dx: -1, dy: +1 },\r\n  \"l\": { code: 2, dx: -1, dy: -1 },\r\n  \"r\": { code: 3, dx: +1, dy: -1 },\r\n  \"n\": { code: -1, dx: 0, dy: 0 },\r\n}\r\n\r\n/** (dx,dy) ~ (dw=width, dh=height) */\r\ntype IPdfPixelArea = {\r\n  dx: number,\r\n  dy: number,\r\n  dw: number,\r\n  dh: number,\r\n}\r\n\r\n\r\n\r\n/**\r\n * rotation이 90이면 회전시켜서 내용물을 그려야 한다.\r\n *\r\n * areas에 있는 값은, 회전한 다음을 가정하고 있음.\r\n *\r\n *    ctx.save();\r\n *    ctx.translate(canvas.width, 0);\r\n *    ctx.rotate( -90 * Math.PI/180);\r\n *    ... drawing operation ...\r\n *    ctx.restore(); *\r\n */\r\nexport interface IAreasDesc {\r\n  rotation: number;\r\n  areas: IRectDpi[];\r\n}\r\n\r\nexport type INcodeAreaDesc = {\r\n  success: boolean,\r\n\r\n  dpi: number,\r\n  pixelsPerDot: number,\r\n  dotsPerCell: number,\r\n\r\n  pageInfo: IPageSOBP,\r\n  rect: IRectDpi,\r\n  // x_nu: number,\r\n  // y_nu: number,\r\n  // width_nu: number,\r\n  // height_nu: number,\r\n}\r\n\r\n/**\r\n * canvasAreas.rotation이 90이면 회전시켜서 내용물을 그려야 한다.\r\n *\r\n * areas에 있는 값은, 회전한 다음을 가정하고 있음.\r\n *\r\n *    ctx.save();\r\n *    ctx.translate(canvas.width, 0);\r\n *    ctx.rotate( -90 * Math.PI/180);\r\n *    ... drawing operation ...\r\n *    ctx.restore(); *\r\n */\r\nexport type ICellsOnSheetDesc = {\r\n  canvas: HTMLCanvasElement;\r\n  canvasAreas: IAreasDesc;\r\n  ncodeAreas: INcodeAreaDesc[];\r\n}\r\n\r\nexport type ICanvasContextForCodeDraw = {\r\n  ctx: CanvasRenderingContext2D,\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n}\r\n\r\nexport type IPagesPerSheetNumbers = 1 | 4 | 9 | 16 | 25 | 2 | 8 | 18 | 32;\r\n/**\r\n * srcDirection은, PDF 파일 전체의 landscape/portrait를 넣어야 한다.\r\n */\r\nexport interface IPrepareSurfaceParam {\r\n  mediaSize: IPaperSize,\r\n  srcDirection: \"auto\" | \"portrait\" | \"landscape\",\r\n  dpi: number,\r\n  numItems: IPagesPerSheetNumbers\r\n  pageInfos: IPageSOBP[],\r\n\r\n  hasToPutNcode: boolean,\r\n\r\n  debugMode: 0 | 1 | 2 | 3,\r\n}\r\n\r\n/**\r\n * Class\r\n */\r\nexport default class NcodeRasterizer {\r\n\r\n  // private ncodeSurfaceDesc: INcodeSurfaceDesc = null;\r\n\r\n  private glyphDistancePx_canvas = 8;\r\n\r\n  printOption: IPrintOption;\r\n\r\n  // private rotation: number = 0;\r\n\r\n  fetcher: NcodeFetcher = null;\r\n\r\n\r\n  constructor(printOption: IPrintOption) {\r\n    this.printOption = { ...printOption };\r\n  }\r\n\r\n  private drawAreaArrow = (ctx, area) => {\r\n    const { x, y, width, height } = area;\r\n    // drawArrow(ctx, area.x, area.y, area.x + area.width, area.y + area.height);\r\n\r\n    ctx.save();\r\n    ctx.font = \"150px Arial\";\r\n\r\n    ctx.strokeStyle = \"rgba(255, 0, 255)\";     // 투명 캔버스\r\n    // ctx.fillStyle = \"rgb(255, 0, 0)\";     // 투명 캔버스\r\n    ctx.lineWidth = 10;\r\n    ctx.lineCap = \"round\";\r\n    ctx.strokeRect(area.x, area.y, area.width - ctx.lineWidth, area.height - ctx.lineWidth);\r\n\r\n    // ctx.strokeStyle = \"rgba(0, 0,0)\";     // 투명 캔버스\r\n    // drawArrow(ctx, area.x + 100, area.y, area.x + 100, area.y + area.height - 100);\r\n    // drawArrow(ctx, area.x, area.y + 100, area.x + area.width - 100, area.y + 100);\r\n\r\n    ctx.strokeStyle = \"rgb(0,0,255)\";\r\n    ctx.fillStyle = \"rgb(0,0, 255)\";\r\n    drawArrow(ctx, x + 50, y + 200, x + width - 100, y + 200);\r\n    ctx.fillText(\"x\", x + width / 2, y + 350);\r\n\r\n    ctx.strokeStyle = \"rgb(255,0,0)\";\r\n    ctx.fillStyle = \"rgb(255,0, 0)\";\r\n    drawArrow(ctx, x + 200, y + 50, x + 200, y + height - 100);\r\n    ctx.fillText(\"y\", x + 250, y + height / 2);\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * 이 함수 내부에서 쓰이는 모든 단위는 600dpi 인쇄를 기준으로 한 pixel 값\r\n   *\r\n   * @param mediaSize\r\n   * @param numItems\r\n   * @param srcDirection\r\n   */\r\n  public prepareNcodePlane = async (options: IPrepareSurfaceParam): Promise<ICellsOnSheetDesc> => {\r\n    const { mediaSize, srcDirection, numItems, pageInfos, hasToPutNcode } = options;\r\n    let dpi = options.dpi;\r\n    dpi = 600;  // kitty  2020/11/29, 코드 제네레이터는 600 dpi로 고정\r\n\r\n    // expect(pageInfos.length).to.be(numItems);\r\n\r\n    // temp canvas size를 구한다.\r\n    let isLandscape = (srcDirection === \"landscape\");\r\n    const isRotationNeeded = getCellMatrixShape(numItems, srcDirection).rotation === 90;\r\n    if (isRotationNeeded) isLandscape = !isLandscape;\r\n    const size = getSurfaceSize_dpi(mediaSize, dpi, isLandscape);\r\n    // let logicalSize = { ...size };\r\n\r\n\r\n\r\n    // sheet의 면을 cell로 나누고,\r\n    const entireRect = { x: 0, y: 0, ...size };\r\n    const canvasAreas = devideSurfaceAreaTo(this.printOption, entireRect, numItems);\r\n    const { areas } = canvasAreas;\r\n\r\n    // 캔버스를 준비\r\n    let canvas = document.createElement(\"canvas\");\r\n    canvas.width = size.width;\r\n    canvas.height = size.height;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgba(255, 255, 255, 0)\";     // 투명 캔버스\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n\r\n    if (options.debugMode > 0) {\r\n      ctx.strokeStyle = \"rgba(0, 255, 0, 255)\";     // 외곽\r\n      ctx.lineWidth = 70;\r\n      ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    // 좌표계의 논리적 회전이 필요하면 회전, when numItems === 2 | 8 | 18 | 32\r\n    // if (canvasAreas.rotation === 90) {\r\n    //   ctx.translate(canvas.width, 0);\r\n    //   ctx.rotate(Math.PI / 2);\r\n    // }\r\n\r\n\r\n    // 출력할 페이지/시트의 실제 출력 대상의 페이지 수 보다 적을 수 있다\r\n    const ncodeAreas = [];\r\n    for (let i = 0; i < areas.length; i++) {\r\n      // 디버깅용 화살표를 그린다. debug mode 1이상\r\n      const drawingContext: ICanvasContextForCodeDraw = { ctx, ...areas[i], };\r\n      const area = areas[i];\r\n      if (this.printOption.debugMode > 0) {\r\n        this.drawAreaArrow(ctx, area);\r\n      }\r\n\r\n      // Calibration 십자가를 그린다.\r\n      if (numItems === 1) {\r\n        this.drawCrossMark(drawingContext, null);\r\n      }\r\n\r\n      // 코드를 그린다\r\n      if (hasToPutNcode && i < pageInfos.length) {\r\n        const pageInfo = pageInfos[i];\r\n        const fetcher = new NcodeFetcher(pageInfo);\r\n        const ncodeSurfaceDesc = await fetcher.getNcodeData(pageInfos[i]);\r\n\r\n        // (left, top) margin을 세팅\r\n        if (this.printOption.marginLeft_nu === -1) {\r\n          this.printOption.marginLeft_nu = ncodeSurfaceDesc.margin.Xmin;\r\n        }\r\n\r\n        if (this.printOption.marginTop_nu === -1) {\r\n          this.printOption.marginTop_nu = ncodeSurfaceDesc.margin.Ymin;\r\n        }\r\n        // 코드를 그린다\r\n\r\n        // ctx.strokeStyle = \"rgba(0, 255, 0, 255)\";     // 투명 캔버스\r\n        // ctx.lineWidth = 70;\r\n        // ctx.strokeRect(0, 0, canvas.width, canvas.height);\r\n        const ncodeArea = await this.drawNcode(drawingContext, ncodeSurfaceDesc, dpi);\r\n        ncodeAreas.push(ncodeArea);\r\n\r\n      }\r\n    }\r\n    ctx.restore();\r\n\r\n    const result: ICellsOnSheetDesc = {\r\n      canvas,\r\n      canvasAreas,\r\n      ncodeAreas,\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public putCode = async (context: ICanvasContextForCodeDraw, pageInfo: IPageSOBP, srcMapped: IPdfPixelArea): Promise<any> => {\r\n    // return new Promise( (resolve) => resolve() );   // kitty\r\n    // this.rotation = rotation;\r\n\r\n    // 코드 정보를 받아온다\r\n    // 코드 정보를 받아올 때 나중에는 x margin, y margin도 서버에서 받아오게 해야 한다\r\n    this.fetcher = new NcodeFetcher(pageInfo);\r\n    const ncodeSurfaceDesc = await this.fetcher.getNcodeData(pageInfo);\r\n    // this.ncodeSurfaceDesc = result;\r\n\r\n    // (left, top) margin을 세팅\r\n    if (this.printOption.marginLeft_nu === -1) {\r\n      this.printOption.marginLeft_nu = ncodeSurfaceDesc.margin.Xmin;\r\n    }\r\n\r\n    if (this.printOption.marginTop_nu === -1) {\r\n      this.printOption.marginTop_nu = ncodeSurfaceDesc.margin.Ymin;\r\n    }\r\n\r\n    // 코드를 그린다\r\n    await this.drawNcode(context, ncodeSurfaceDesc, 600);\r\n  }\r\n\r\n  private drawSingleCrossMark = (context: ICanvasContextForCodeDraw, x: number, y: number) => {\r\n    const ctx = context.ctx;\r\n    const line_width = 5;\r\n    const line_len = 100;\r\n\r\n\r\n    ctx.strokeStyle = \"rgb(255, 0, 0)\";\r\n    ctx.save();\r\n\r\n    ctx.beginPath();\r\n    ctx.lineWidth = line_width;\r\n    // 2020/08/31 kitty\r\n    // canvas_context.arc(x, y, r, r, 0, Math.PI * 2, true); // Outer circle\r\n    ctx.moveTo(x, y - line_len);\r\n    ctx.lineTo(x, y + line_len);\r\n    ctx.moveTo(x - line_len, y);\r\n    ctx.lineTo(x + line_len, y);\r\n    ctx.stroke();\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  public drawCrossMark = (context: ICanvasContextForCodeDraw, srcMapped: IPdfPixelArea = null) => {\r\n\r\n    // 이전 버전과 호환성을 위해\r\n    if (srcMapped === null) {\r\n      srcMapped = { dx: 0, dy: 0, dw: context.width, dh: context.height };\r\n    }\r\n\r\n    const ratio = 0.1;\r\n    const d = srcMapped.dw * ratio;\r\n    const x0 = srcMapped.dx + d;\r\n    const y0 = srcMapped.dy + d;\r\n    const x1 = srcMapped.dx + srcMapped.dw - d;\r\n    const y1 = srcMapped.dy + srcMapped.dh - d;\r\n\r\n    this.drawSingleCrossMark(context, x0, y0);\r\n    // this.drawSingleCrossMark(canvas, x0, y1);\r\n    this.drawSingleCrossMark(context, x1, y1);\r\n    // this.drawSingleCrossMark(canvas, x1, y0);\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   * @param context\r\n   * @param code_txt\r\n   * @param y\r\n   * @param fullOfGlyphs - for debugging\r\n   */\r\n  private drawNcodeSingleLine = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs: boolean = true): Promise<void> => {\r\n    // if (this.printOption.codeDensity > 2) {\r\n    //   return this.drawNcodeSingleLine_BOLD(context, code_txt, y, fullOfGlyphs);\r\n    // }\r\n    // else {\r\n    //   return this.drawNcodeSingleLine_NORMAL(context, code_txt, y, fullOfGlyphs);\r\n    // }\r\n\r\n    return this.drawNcodeSingleLine_DOT(context, code_txt, y, width, fullOfGlyphs);\r\n  }\r\n\r\n  private drawNcodeSingleLine_DOT = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs: boolean = true): Promise<void> => {\r\n    const { ctx, x: baseX, y: baseY } = context;\r\n\r\n    const glyphStringSkipLeft = Math.round(this.printOption.marginLeft_nu * NCODE_CLASS6_NUM_DOTS);\r\n\r\n    return new Promise(resolve => {\r\n      const glyphDistancePx_canvas = this.glyphDistancePx_canvas;\r\n      /** for debugging */\r\n      if (!fullOfGlyphs) width = debugNcode_w;\r\n\r\n      ctx.fillStyle = \"rgba(0,0,0,255)\";\r\n      ctx.lineWidth = 0;\r\n\r\n      let charIndex = glyphStringSkipLeft;\r\n      for (let x = 0; x < width; x += glyphDistancePx_canvas) {\r\n        if (charIndex >= 0) {\r\n          const glyph = code_txt[charIndex];\r\n          const pos = codePos[glyph];\r\n          let dx = 0, dy = 0;\r\n          if (pos) {\r\n            dx = pos.dx;\r\n            dy = pos.dy;\r\n          }\r\n\r\n          ctx.beginPath();\r\n          ctx.rect(baseX + x + dx, baseY + y + dy, 1, 1);\r\n          ctx.fill();\r\n        }\r\n        charIndex++;\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  private drawNcodeSingleLine_NORMAL = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs: boolean = true): Promise<void> => {\r\n    const { ctx, x: baseX, y: baseY } = context;\r\n\r\n    const glyphStringSkipLeft = Math.round(this.printOption.marginLeft_nu * NCODE_CLASS6_NUM_DOTS);\r\n\r\n    return new Promise(resolve => {\r\n      const glyphDistancePx_canvas = this.glyphDistancePx_canvas;\r\n      /** for debugging */\r\n      if (!fullOfGlyphs) width = debugNcode_w;\r\n      const codeDensity = this.printOption.codeDensity;\r\n\r\n      ctx.fillStyle = \"rgba(0,0,0,255)\";\r\n      ctx.lineWidth = 0;\r\n\r\n      let charIndex = 0;\r\n      for (let x = 0; x < width; x += glyphDistancePx_canvas) {\r\n        if (charIndex + glyphStringSkipLeft >= 0) {\r\n          let glyph = code_txt[charIndex + glyphStringSkipLeft];\r\n\r\n          const pos = codePos[glyph];\r\n          let dx = 0, dy = 0;\r\n          if (pos) {\r\n            dx = pos.dx;\r\n            dy = pos.dy;\r\n          }\r\n\r\n          ctx.beginPath();\r\n          ctx.rect(baseX + x + dx, baseY + y + dy, codeDensity, codeDensity);\r\n          // ctx.rect(baseX + x + dx, baseY + y + dy, 1, 1);\r\n          ctx.fill();\r\n\r\n        }\r\n        charIndex++;\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  private drawNcodeSingleLine_BOLD = (context: ICanvasContextForCodeDraw, code_txt: string, y: number, width: number, fullOfGlyphs: boolean = true): Promise<void> => {\r\n    const { ctx, x: baseX, y: baseY } = context;\r\n\r\n    const glyphStringSkipLeft = Math.round(this.printOption.marginLeft_nu * NCODE_CLASS6_NUM_DOTS);\r\n\r\n    return new Promise(resolve => {\r\n      const glyphDistancePx_canvas = this.glyphDistancePx_canvas;\r\n      /** for debugging */\r\n      if (!fullOfGlyphs) width = debugNcode_w;\r\n      // const codeDensity = this.printOption.codeDensity;\r\n\r\n      let charIndex = 0;\r\n      for (let x = 0; x < width; x += glyphDistancePx_canvas) {\r\n        if (charIndex + glyphStringSkipLeft >= 0) {\r\n          let glyph = code_txt[charIndex + glyphStringSkipLeft];\r\n\r\n          const pos = codePos[glyph];\r\n          let dx = 0, dy = 0;\r\n          if (pos) {\r\n            dx = pos.dx;\r\n            dy = pos.dy;\r\n          }\r\n\r\n          const radius = 1.35;\r\n          ctx.beginPath();\r\n          ctx.arc(baseX + x + dx, baseY + y + dy, radius, 0, 2 * Math.PI, false);\r\n          // ctx.rect(x + dx, y + dy, codeDensity, codeDensity);\r\n          ctx.fillStyle = \"black\";\r\n          ctx.lineWidth = 0;\r\n          ctx.fill();\r\n        }\r\n        charIndex++;\r\n      }\r\n      resolve();\r\n    });\r\n  }\r\n\r\n\r\n  private drawNcode = (\r\n    context: ICanvasContextForCodeDraw,\r\n    surfaceDesc: INcodeSurfaceDesc,\r\n    dpi: number)\r\n    : Promise<INcodeAreaDesc> => {\r\n\r\n    // kitty\r\n    const DEBUG_MODE = this.printOption.debugMode;\r\n\r\n    const { glyphData } = surfaceDesc;\r\n    const { width, height } = context;\r\n    const glyphDistancePx_canvas = Math.round(dpi * 8 / 600);\r\n    const glyphStringSkipTop = Math.round(this.printOption.marginTop_nu * NCODE_CLASS6_NUM_DOTS);\r\n    const codeDrawingPromises = new Array(0);\r\n\r\n    const result: INcodeAreaDesc = {\r\n      success: false,\r\n      dpi,\r\n      pixelsPerDot: glyphDistancePx_canvas,\r\n      dotsPerCell: NCODE_CLASS6_NUM_DOTS,\r\n\r\n      pageInfo: { section: -1, owner: -1, book: -1, page: -1 },\r\n\r\n      rect: {\r\n        unit: \"nu\",\r\n        x: 0, y: 0, width: 0, height: 0,\r\n      }\r\n    };\r\n\r\n\r\n    if (glyphData.length < 1) {\r\n      console.log(\"ERROR: no ncode data given\");\r\n      return Promise.resolve(result);\r\n    }\r\n\r\n    const ctx = context.ctx;\r\n    ctx.save();\r\n    ctx.fillStyle = \"rgba(0,0,0,255)\";\r\n\r\n\r\n    try {\r\n      // const PRINT_RESOLUTION = getPrintResolution();\r\n\r\n      const glyphStrings = glyphData.split(\"\\r\\n\");\r\n      if (glyphStrings.length < 7) {\r\n        return Promise.resolve(result);\r\n      }\r\n      //  const glyph_y = codePaperInfo.Ymin * dotsInACell;\r\n      let glyph_y = glyphStringSkipTop;\r\n\r\n      let y = 0;\r\n      for (y = 0; y < debugNcode_h; y += glyphDistancePx_canvas) {\r\n        if (glyph_y >= 0) {\r\n          const codeTxtSingleLine = glyphStrings[glyph_y];\r\n          const pr = this.drawNcodeSingleLine(context, codeTxtSingleLine, y, width, true);\r\n          codeDrawingPromises.push(pr);\r\n        }\r\n        glyph_y++;\r\n      }\r\n\r\n      for (; y < height; y += glyphDistancePx_canvas) {\r\n        if (glyph_y >= 0) {\r\n          const codeTxtSingleLine = glyphStrings[glyph_y];\r\n          const pr = this.drawNcodeSingleLine(context, codeTxtSingleLine, y, width, !(DEBUG_MODE > 1));\r\n          codeDrawingPromises.push(pr);\r\n        }\r\n        glyph_y++;\r\n      }\r\n\r\n      ctx.restore();\r\n\r\n    } catch (e) {\r\n      ctx.restore();\r\n\r\n      console.error(e);\r\n      return Promise.resolve(result);\r\n    }\r\n\r\n    return new Promise(resolve => {\r\n      Promise.all(codeDrawingPromises).then(() => {\r\n        result.success = true;\r\n        result.dpi = dpi;\r\n        result.pixelsPerDot = glyphDistancePx_canvas;\r\n        result.dotsPerCell = NCODE_CLASS6_NUM_DOTS;\r\n\r\n        result.pageInfo = { ...surfaceDesc.pageInfo };\r\n        result.rect.unit = \"nu\";\r\n        result.rect.x = this.printOption.marginLeft_nu;\r\n        result.rect.y = this.printOption.marginTop_nu;\r\n        result.rect.width = Math.ceil(width / (NCODE_CLASS6_NUM_DOTS * glyphDistancePx_canvas));\r\n        result.rect.height = Math.ceil(height / (NCODE_CLASS6_NUM_DOTS * glyphDistancePx_canvas));\r\n\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n\r\n}\r\n\r\nfunction isPtInRect(x: number, y: number, rect: IRectDpi) {\r\n  const x0 = rect.x;\r\n  const x1 = x0 + rect.width;\r\n  const y0 = rect.y;\r\n  const y1 = y0 + rect.height;\r\n\r\n  if (x >= x0 && x <= x1 && y >= y0 && y <= y1) return true;\r\n  return false;\r\n}\r\n\r\nexport function getNcodeAtCanvasPixel(pt: IPointDpi, areas: ICellsOnSheetDesc)\r\n  : IPointDpi {\r\n\r\n  if (areas.ncodeAreas.length < 1) return null;\r\n\r\n  let { x, y, dpi } = pt;\r\n  const scale = areas.ncodeAreas[0].dpi / dpi;\r\n  x *= scale;\r\n  y *= scale;\r\n\r\n  for (let i = 0; i < areas.ncodeAreas.length; i++) {\r\n    const cArea = areas.canvasAreas.areas[i];\r\n\r\n    if (isPtInRect(x, y, cArea)) {\r\n      const dx_cu = x - cArea.x;\r\n      const dy_cu = y - cArea.y;\r\n\r\n      const nArea = areas.ncodeAreas[i];\r\n      const ncodeUnit = nArea.dotsPerCell * nArea.pixelsPerDot;\r\n      const dx_nu = dx_cu / ncodeUnit;\r\n      const dy_nu = dy_cu / ncodeUnit;\r\n\r\n      const x_nu = dx_nu + nArea.rect.x;\r\n      const y_nu = dy_nu + nArea.rect.y;\r\n\r\n      return { unit: \"nu\", dpi: UNIT_TO_DPI[\"nu\"], x: x_nu, y: y_nu };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function getNcodeRectAtCanvasPixel(rc: IRectDpi, areas: ICellsOnSheetDesc)\r\n  : IRectDpi {\r\n\r\n  if (areas.ncodeAreas.length < 1) return null;\r\n\r\n  rc = autoSetDpi(rc);\r\n  const scale = areas.ncodeAreas[0].dpi / rc.dpi;\r\n  let center: IPointDpi = {\r\n    x: rc.x + (rc.width / 2),\r\n    y: rc.y + (rc.height / 2),\r\n    dpi: rc.dpi,\r\n  };\r\n\r\n\r\n  const center_nu = getNcodeAtCanvasPixel(center, areas);\r\n  if (!center_nu) return null;\r\n\r\n  const nArea = areas.ncodeAreas[0];    // 0과 다른 부분면(splitted area)는 항상 같다\r\n  const ncodeUnit = nArea.dotsPerCell * nArea.pixelsPerDot;\r\n\r\n  return {\r\n    unit: \"nu\",\r\n    x: center_nu.x - (rc.width / 2 * scale / ncodeUnit),\r\n    y: center_nu.y - (rc.height / 2 * scale / ncodeUnit),\r\n    width: (rc.width * scale / ncodeUnit),\r\n    height: (rc.height * scale / ncodeUnit),\r\n  }\r\n}\r\n\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodePrint\\PageForPrint.tsx",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeConstans.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeSurfaceDataJson.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\NcodeFetcher.ts",["567","568"],"import { IPageSOBP } from \"../DataStructure/Structures\";\r\nimport * as Zlib from \"zlib\";\r\nimport { INcodeSurfaceDesc } from \"./SurfaceDataTypes\";\r\nimport { getNPaperInfo, isSamePage } from \"./SurfaceInfo\";\r\n\r\n\r\n/**\r\n * Class\r\n */\r\nexport default class NcodeFetcher {\r\n  private codeText: string = \"\";\r\n  private fetchPromise: Promise<string> = Promise.resolve(\"\");\r\n  pageInfo: IPageSOBP;\r\n\r\n  constructor(pageInfo: IPageSOBP) {\r\n    this.pageInfo = pageInfo;\r\n    this.fetchPromise = this.fetchNcodeData(pageInfo);\r\n    this.fetchPromise.then(txt => this.codeText = txt);\r\n  }\r\n\r\n\r\n  /**\r\n   * 코드 정보를 받아온다\r\n   * 코드 정보를 받아올 때 나중에는 x margin, y margin도 서버에서 받아오게 해야 한다 2020/11/26\r\n   * @param pageInfo\r\n   */\r\n  public getNcodeData = async (pageInfo: IPageSOBP): Promise<INcodeSurfaceDesc> => {\r\n    // glyph text를 받아 온다.\r\n    if (isSamePage(this.pageInfo, pageInfo)) {\r\n      console.log(\"reuse downloaded glyph data file\");\r\n      const txt = await this.fetchPromise;\r\n      this.codeText = txt;\r\n    }\r\n    else {\r\n      console.log(\"download glyph data file\");\r\n      let promise = this.fetchNcodeData(pageInfo);\r\n      this.fetchPromise = promise;\r\n      const txt = await this.fetchPromise;\r\n\r\n      this.pageInfo = pageInfo;\r\n      this.codeText = txt;\r\n    }\r\n\r\n    const result: INcodeSurfaceDesc = getNPaperInfo(pageInfo);\r\n    result.glyphData = this.codeText;\r\n\r\n    return result;\r\n  }\r\n\r\n\r\n  private fetchNcodeData = async (pageInfo: IPageSOBP): Promise<string> => {\r\n    return new Promise(async (resolve, reject) => {\r\n      // console.log(`[fetch] ${pageInfo.section}.${pageInfo.owner}.${pageInfo.book}.${pageInfo.page}`);\r\n      const url = this.getRawCodeDataUrl(pageInfo);\r\n\r\n      let blob = await fetch(url).then((r) => {\r\n\r\n        if (r.ok) {\r\n          return r.blob();\r\n        }\r\n\r\n        resolve(\"\");\r\n      });\r\n\r\n      function gunzipCallback(decompressed) {\r\n        // console.log(decompressed);\r\n        const txt = new TextDecoder(\"utf-8\").decode(decompressed);\r\n        resolve(txt);\r\n      }\r\n\r\n      if (blob != null) {\r\n        try {\r\n          const buffer = await blob.arrayBuffer();\r\n          const u8buf = new Uint8Array(buffer);\r\n          // eslint-disable-next-line\r\n          const gunzip = new Zlib.gunzip(u8buf, (err, result) => {\r\n            // console.error(err);\r\n            if (err) {\r\n              console.log(err);\r\n              resolve(\"\");\r\n            }\r\n            gunzipCallback(result);\r\n          });\r\n        } catch (e) {\r\n          resolve(\"\");\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n\r\n  private getAbsoluteURL = (base: string, relative: string): string => {\r\n    const stack = base.split(\"/\");\r\n    const parts = relative.split(\"/\");\r\n\r\n    stack.pop(); // remove current file name (or empty string)\r\n\r\n    // (omit if \"base\" is the current folder without trailing slash)\r\n    for (let i = 0; i < parts.length; i++) {\r\n      if (parts[i] === \".\") continue;\r\n      if (parts[i] === \"..\") stack.pop();\r\n      else stack.push(parts[i]);\r\n    }\r\n    return stack.join(\"/\");\r\n  }\r\n\r\n\r\n  private getRawCodeDataUrl = (pageInfo: IPageSOBP): string => {\r\n\r\n    const { section, owner, book, page } = pageInfo;\r\n\r\n    const ncode_idx = \"s\" + section + \"-o\" + owner + \"-b\" + book + \"-p\" + page;\r\n    const dir_name = \"s\" + section + \"-o\" + owner + \"-b\" + book;\r\n\r\n    const filename = \"./ncode_data/\" + dir_name + \"/\" + ncode_idx + \".code.gz\";\r\n    const doc_url = document.location.href;\r\n    const url = this.getAbsoluteURL(doc_url, filename);\r\n\r\n    return url;\r\n  }\r\n}","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\NcodeSurface\\index.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\DataTypes.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\CoordinateTanslater.ts",["569"],"import { IPoint } from \"../DataStructure/Structures\";\r\nimport * as Solve from \"./SolveTransform\";\r\nimport { TransformPoints, TransformPointPairs, TransformParameters, IMappingParams } from \"./DataTypes\";\r\nimport { MappingItem } from \"../SurfaceMapper/MappingItem\";\r\nimport { sprintf } from \"sprintf-js\";\r\n\r\nconst solveAffine = Solve.solveAffine;\r\nconst solveHomography = Solve.solveHomography;\r\nconst applyTransform = Solve.applyTransform;\r\n\r\n\r\n/** for debugging */\r\nlet _srcPts: TransformPoints = null;\r\nlet _dstPts: TransformPoints = null;\r\nlet _params: TransformParameters = null;\r\n\r\n/**\r\n * -----------------------------------------------------------------------------------\r\n * A. 우리는 다음과 같은 좌표계를 쓴다.\r\n *\r\n * 1) Ncode 좌표계\r\n * 2) PDF 좌표계\r\n * 3) Canvas 좌표계\r\n * 4) 화면 좌표계\r\n *\r\n *\r\n * 1) NU(Ncode Unit): 56/600 DPI, Ncode 좌표계는 펜에서 검출되는 좌표계를 기준으로 한다.\r\n *    - 600DPI에서 8 pixel 거리를 가지는 7개 glyph 가 하나의 Ncode\r\n *    - 1 NU = 7(glyphs) * 8(pixels) / 600 (DPI) = 56/600 Inch = 약 2.370666667 mm\r\n *\r\n *\r\n * 2) PU(Pdf Unit): 72 DPI, PDF 좌표계는 PdfJs.getViewport({scale:1})을 통해서 나오는 크기를 기준으로 하는 좌표계\r\n *    - PDF가 설계될 당시 1:1 scale의 좌표계는 72DPI\r\n *    - 1 PU = 1 pixel @ 72DPI = 1(pixel) / 72(DPI) = 1/72 Inch = 약 0.352777778 mm\r\n *\r\n * 3) CU(Canvas Unit): 96 DPI, HTML의 CSS에 의해 만들어진 좌표\r\n *    - 1 CU = 1pixel @ 96DPI = 1(pixel) / 96(DPI) = 1/96 Inch = 약 0.010416667 mm\r\n *\r\n * 4) SU(Screen Unit): 화면의 zoom과 offset에 따라 달라짐\r\n *    - zoom은 CU와 1:1일 때, 100%\r\n *    - fabric의 canvas.zoom, offset_x, offset_y에 의해 계산이 달라짐\r\n *\r\n * -----------------------------------------------------------------------------------\r\n * B. 1:1일 때, 계산 방법\r\n *\r\n * 1) NU to PU\r\n *    pu = nu * (56/600) / (1/72) = nu * 6.72\r\n *\r\n * 2) PU to CU\r\n *    cu = pu * (1/72) / (1/96) = pu * 4 / 3\r\n *\r\n * 3) NU to CU\r\n *    cu = nu * 6.72 * (4/3) = nu * 8.96\r\n *\r\n * 4) CU to SU(zoom, offset)\r\n *    su = zoom * CU + offset\r\n *\r\n * -----------------------------------------------------------------------------------\r\n * C. Transform matrix로 계산 방법\r\n *\r\n * 0) TransformMatrix를 구한다\r\n *    a) src points (Ncode Unit)의 4개 점 (affine에서는 3개 점)\r\n *    b) 각 src point에 해당하는 dst points (Pdf Unit)의 4개 점을 (affine에서는 3개 점)\r\n *    c) HomographyPoints (또는 AffinePoints)에 넣고\r\n *    d) solveHomography 또는 solveAffine으로 값을 구하고 TransformMatrix 타입의 리턴을\r\n *    e) 어딘가에 저장해 둔다. (예, transMtx)\r\n *\r\n * 1) pt in NU to pt' in PU\r\n *    pt' = applyTransform( pt, transMtx );\r\n *\r\n * 2) PU to CU\r\n *    - B-2)과 같다.\r\n *\r\n * 3) NU to CU\r\n *    - cu = applyTransform( nu, transMtx ) * 4 /3\r\n *\r\n * -----------------------------------------------------------------------------------\r\n * D. 코딩 시 변수 구별 원칙\r\n * 1) ptNu = pt at Ncode coordinate system\r\n * 2) ptPu = pt at Pdf Pixel coordinate system\r\n * 3) ptCu = pt at Fabric Canvas coordinate system\r\n * 4) ptSu = pt at screen coordinate system\r\n *\r\n *\r\n */\r\nexport default class CoordinateTanslater {\r\n  // private _params: TransformParameters = null;\r\n  // private _paramsReverse: TransformParameters = null;\r\n\r\n  private _mappingParams: IMappingParams = null;\r\n\r\n  constructor(original: CoordinateTanslater = null) {\r\n    if (original) {\r\n      const json = JSON.stringify(original._mappingParams);\r\n      this._mappingParams = JSON.parse(json);\r\n      this.calcReverse();\r\n    }\r\n  }\r\n\r\n  get mappingParams() {\r\n    return this._mappingParams;\r\n  }\r\n\r\n  /**\r\n   * calculate transform parameters (reverse\r\n   * @param points\r\n   */\r\n  public calc = (mappingItem: MappingItem) => {\r\n    this._mappingParams = mappingItem._params;\r\n\r\n    const srcPts = mappingItem.srcPts;\r\n    const dstPts = mappingItem.dstPts;\r\n\r\n    _srcPts = mappingItem.srcPts;\r\n    _dstPts = mappingItem.dstPts;\r\n\r\n    /** src:NU, dst:PU */\r\n    const pts = {\r\n      src: { ...srcPts, },\r\n      dst: { ...dstPts, }\r\n    } as TransformPointPairs;\r\n\r\n    /** src:PU, dst:NU */\r\n    const ptsReverse = {\r\n      src: { ...dstPts, },\r\n      dst: { ...srcPts, }\r\n    } as TransformPointPairs;\r\n\r\n\r\n    if (srcPts.type === \"affine\") {\r\n      this._mappingParams.h = solveAffine(pts);  // NU -> PU\r\n      this._mappingParams.h_rev = solveAffine(ptsReverse);  // PU -> NU\r\n\r\n      _params = this._mappingParams.h;\r\n      return;\r\n    }\r\n    else if (srcPts.type === \"homography\") {\r\n      this._mappingParams.h = solveHomography(pts);  // NU -> PU\r\n      this._mappingParams.h_rev = solveHomography(ptsReverse);  // PU -> NU\r\n\r\n      _params = this._mappingParams.h;\r\n      return;\r\n    }\r\n\r\n    throw Error(\"CoordinateTanslater needs '3 or 4 pairs of points' to initiate class.\");\r\n  }\r\n\r\n\r\n  /**\r\n   *\r\n   */\r\n  private calcReverse = () => {\r\n    // 아래는 임의의 숫자\r\n    const srcPts: TransformPoints = {\r\n      type: \"homography\",\r\n      unit: \"pu\",\r\n      pts: [\r\n        { x: 0, y: 0 },\r\n        { x: 100, y: 0 },\r\n        { x: 100, y: 100 },\r\n        { x: 0, y: 100 },\r\n      ]\r\n    };\r\n\r\n    // 정방향 파라메터로 역방향의 대상이 되는 점을 연산\r\n    let dstPts: TransformPoints = {\r\n      type: \"homography\",\r\n      unit: \"nu\",\r\n      pts: new Array(4),\r\n    };\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n      const dstPt = this.NUtoPU(srcPts[i]);\r\n      dstPts[i] = dstPt;\r\n    }\r\n\r\n    /** src:PU, dst:NU */\r\n    const ptsReverse = {\r\n      src: { ...dstPts, },\r\n      dst: { ...srcPts, }\r\n    } as TransformPointPairs;\r\n\r\n    this._mappingParams.h_rev = solveHomography(ptsReverse);\r\n  }\r\n\r\n  public dump = (prefix: string) => {\r\n    const { a, b, c, d, e, f, g, h } = _params;\r\n    const sp = _srcPts.pts;\r\n    const dp = _dstPts.pts;\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n      console.log(`[${prefix}] ${sprintf(\"(%6.1f, %6.1f) => (%5d, %5d)\", sp[i].x, sp[i].y, dp[i].x, dp[i].y)}`);\r\n\r\n    }\r\n\r\n\r\n    const first = sprintf(\"%7.1f %7.1f %7.1f\", a, b, c);\r\n    const second = sprintf(\"%7.2f %7.1f %7.1f\", d, e, f);\r\n    const thrid = sprintf(\"%7.1f %7.1f %7.1f\", g, h, 1);\r\n\r\n    console.log(`[${prefix}]`);\r\n    console.log(`[${prefix}]          | ${first} |`);\r\n    console.log(`[${prefix}]     H =  | ${second} |`);\r\n    console.log(`[${prefix}]          | ${thrid} |`);\r\n    console.log(`[${prefix}]`);\r\n  }\r\n\r\n  /**\r\n   * 계산된 변환행렬을 반환\r\n   *\r\n   * return {...this._params} 로 해야 하지 않을까?\r\n   * 이것 때문에 class가 메모리에 계속 남아 있으면 어떻게 하지?\r\n   */\r\n  public get params(): TransformParameters {\r\n    return this._mappingParams.h;\r\n  }\r\n\r\n  /**\r\n   * Ncode point to Pds point\r\n   * @param ptNu\r\n   */\r\n  public NUtoPU = (ptNu: IPoint): IPoint => {\r\n    const ptPu = applyTransform(ptNu, this._mappingParams.h);\r\n    return ptPu;\r\n  }\r\n\r\n  /**\r\n   * Pds point to Ncode point\r\n   * @param ptNu\r\n   */\r\n  public PUtoNU = (ptPu: IPoint): IPoint => {\r\n    const ptNu = applyTransform(ptPu, this._mappingParams.h_rev);\r\n    return ptNu;\r\n  }\r\n\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\SolveTransform.ts",["570","571"],"import { IPoint } from \"../DataStructure/Structures\";\r\nimport { EchelonMatrix } from \"./EchelonMatrix\";\r\nimport { TransformParameters, TransformPointPairs } from \"./DataTypes\";\r\nimport * as Gaussian from \"./GaussianElimination\";\r\nimport expect from \"expect.js\";\r\n/**\r\n * private\r\n * @param points\r\n */\r\nfunction initEchelonMtx_Homography(points: TransformPointPairs): EchelonMatrix {\r\n  expect(points.src.type).to.be(\"homography\");\r\n  const mtx = new EchelonMatrix(\"homography\");\r\n\r\n  // Point *src, *dst;\r\n\r\n  // [0..7][0..8]의 행렬, 가우스 소거법을 쓰기 위해서\r\n  for (let i = 0; i < 4; i++) {\r\n    let r1 = i * 2;\r\n    let r2 = r1 + 1;\r\n\r\n    const src = points.src.pts[i];\r\n    const dst = points.dst.pts[i];\r\n\r\n    /**\r\n     * x's\r\n     */\r\n    mtx.elem[r1][0] = src.x;\r\n    mtx.elem[r1][1] = src.y;\r\n    mtx.elem[r1][2] = 1;\r\n\r\n    mtx.elem[r1][3] = 0;\r\n    mtx.elem[r1][4] = 0;\r\n    mtx.elem[r1][5] = 0;\r\n\r\n    mtx.elem[r1][6] = -(src.x * dst.x);\r\n    mtx.elem[r1][7] = -(src.y * dst.x);\r\n    mtx.elem[r1][8] = dst.x;\r\n\r\n    /**\r\n     * y's\r\n     */\r\n    mtx.elem[r2][0] = 0;\r\n    mtx.elem[r2][1] = 0;\r\n    mtx.elem[r2][2] = 0;\r\n\r\n    mtx.elem[r2][3] = src.x;\r\n    mtx.elem[r2][4] = src.y;\r\n    mtx.elem[r2][5] = 1;\r\n\r\n    mtx.elem[r2][6] = -(src.x * dst.y);\r\n    mtx.elem[r2][7] = -(src.y * dst.y);\r\n    mtx.elem[r2][8] = dst.y;\r\n  }\r\n\r\n  return mtx;\r\n}\r\n\r\n/**\r\n * private\r\n * @param points\r\n */\r\nfunction initEchelonMtx_Affine(points: TransformPointPairs): EchelonMatrix {\r\n  expect(points.src.type).to.be(\"affine\");\r\n\r\n  const mtx = new EchelonMatrix(\"affine\");\r\n  // [0..7][0..8]의 행렬, 가우스 소거법을 쓰기 위해서\r\n  for (let i = 0; i < 3; i++) {\r\n    const r1 = i * 2;\r\n    const r2 = r1 + 1;\r\n\r\n    const src = points.src.pts[i];\r\n    const dst = points.dst.pts[i];\r\n\r\n    /**\r\n     * x's\r\n     */\r\n    mtx.elem[r1][0] = src.x;\r\n    mtx.elem[r1][1] = src.y;\r\n\r\n    mtx.elem[r1][2] = 0;\r\n    mtx.elem[r1][3] = 0;\r\n\r\n    mtx.elem[r1][4] = 1;\r\n    mtx.elem[r1][5] = 0;\r\n    mtx.elem[r1][6] = dst.x;\r\n\r\n    /**\r\n     * y's\r\n     */\r\n    mtx.elem[r2][0] = 0;\r\n    mtx.elem[r2][1] = 0;\r\n\r\n    mtx.elem[r2][2] = src.x;\r\n    mtx.elem[r2][3] = src.y;\r\n\r\n    mtx.elem[r2][4] = 0;\r\n    mtx.elem[r2][5] = 1;\r\n    mtx.elem[r2][6] = dst.y;\r\n  }\r\n\r\n  return mtx;\r\n}\r\n\r\n\r\n/**\r\n * public\r\n * @param points\r\n */\r\nexport function solveHomography(points: TransformPointPairs): TransformParameters {\r\n  expect(points.src.type).to.be(\"homography\");\r\n\r\n  // EchelonMatrix A;\r\n  // int n;\r\n  const mat = initEchelonMtx_Homography(points);\r\n  Gaussian.reduce(mat);\r\n\r\n  const params: TransformParameters = {\r\n    type: \"homography\",\r\n\r\n    a: mat.elem[0][8],\r\n    b: mat.elem[1][8],\r\n    c: mat.elem[2][8],\r\n\r\n    d: mat.elem[3][8],\r\n    e: mat.elem[4][8],\r\n    f: mat.elem[5][8],\r\n\r\n    g: mat.elem[6][8],\r\n    h: mat.elem[7][8],\r\n    i: 1,\r\n\r\n    tx: mat.elem[2][8],\r\n    ty: mat.elem[5][8],\r\n  };\r\n  return params;\r\n}\r\n\r\n\r\n/**\r\n * public\r\n * @param points\r\n */\r\nexport function solveAffine(points: TransformPointPairs): TransformParameters {\r\n  expect(points.src.type).to.be(\"affine\");\r\n\r\n  // _affineCalcMatrix A;\r\n  // int n;\r\n  const mat = initEchelonMtx_Affine(points);\r\n  Gaussian.reduce(mat);\r\n  const params: TransformParameters = {\r\n    type: \"affine\",\r\n    a: mat.elem[0][6],\r\n    b: mat.elem[1][6],\r\n    c: mat.elem[4][6],\r\n\r\n    d: mat.elem[2][6],\r\n    e: mat.elem[3][6],\r\n    f: mat.elem[5][6],\r\n\r\n    g: 0,\r\n    h: 0,\r\n    i: 1,\r\n\r\n    tx: mat.elem[4][6],\r\n    ty: mat.elem[5][6],\r\n  };\r\n  return params;\r\n}\r\n\r\n/**\r\n * public\r\n * @param mtx\r\n * @param pt\r\n * @return Ipoint\r\n */\r\nexport function applyTransform(pt: IPoint, params: TransformParameters): IPoint {\r\n  const { x, y } = pt;\r\n  const { a, b, c, d, e, f, g, h } = params;\r\n\r\n  const det = 1 / (g * x + h * y + 1);\r\n  const xx = (a * x + b * y + c) * det;\r\n  const yy = (d * x + e * y + f) * det;\r\n\r\n  return { x: xx, y: yy }\r\n}\r\n","F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\EchelonMatrix.ts",[],"F:\\__Work\\dotProject\\_trunk\\WWW\\GridaBoard2\\src\\NcodePrintLib\\Coordinates\\GaussianElimination.ts",[],{"ruleId":"572","severity":1,"message":"573","line":47,"column":3,"nodeType":"574","messageId":"575","endLine":47,"endColumn":56,"fix":"576"},{"ruleId":"572","severity":1,"message":"573","line":48,"column":3,"nodeType":"574","messageId":"575","endLine":48,"endColumn":54,"fix":"577"},{"ruleId":"572","severity":1,"message":"573","line":49,"column":3,"nodeType":"574","messageId":"575","endLine":49,"endColumn":60,"fix":"578"},{"ruleId":"572","severity":1,"message":"573","line":50,"column":3,"nodeType":"574","messageId":"575","endLine":50,"endColumn":54,"fix":"579"},{"ruleId":"580","severity":1,"message":"581","line":71,"column":7,"nodeType":"582","messageId":"583","endLine":71,"endColumn":16,"fix":"584"},{"ruleId":"580","severity":1,"message":"585","line":76,"column":5,"nodeType":"582","messageId":"583","endLine":76,"endColumn":10,"fix":"586"},{"ruleId":"580","severity":1,"message":"587","line":8,"column":5,"nodeType":"582","messageId":"583","endLine":8,"endColumn":6,"fix":"588"},{"ruleId":"580","severity":1,"message":"589","line":15,"column":9,"nodeType":"582","messageId":"583","endLine":15,"endColumn":14,"fix":"590"},{"ruleId":"580","severity":1,"message":"589","line":17,"column":13,"nodeType":"582","messageId":"583","endLine":17,"endColumn":18,"fix":"591"},{"ruleId":"580","severity":1,"message":"589","line":20,"column":13,"nodeType":"582","messageId":"583","endLine":20,"endColumn":18,"fix":"592"},{"ruleId":"580","severity":1,"message":"593","line":13,"column":9,"nodeType":"582","messageId":"583","endLine":13,"endColumn":10},{"ruleId":"580","severity":1,"message":"594","line":13,"column":37,"nodeType":"582","messageId":"583","endLine":13,"endColumn":38,"fix":"595"},{"ruleId":"580","severity":1,"message":"596","line":19,"column":7,"nodeType":"582","messageId":"583","endLine":19,"endColumn":10,"fix":"597"},{"ruleId":"580","severity":1,"message":"596","line":27,"column":7,"nodeType":"582","messageId":"583","endLine":27,"endColumn":10,"fix":"598"},{"ruleId":"580","severity":1,"message":"599","line":29,"column":7,"nodeType":"582","messageId":"583","endLine":29,"endColumn":11,"fix":"600"},{"ruleId":"580","severity":1,"message":"587","line":5,"column":5,"nodeType":"582","messageId":"583","endLine":5,"endColumn":6,"fix":"601"},{"ruleId":"580","severity":1,"message":"602","line":29,"column":9,"nodeType":"582","messageId":"583","endLine":29,"endColumn":17,"fix":"603"},{"ruleId":"580","severity":1,"message":"604","line":30,"column":9,"nodeType":"582","messageId":"583","endLine":30,"endColumn":18,"fix":"605"},{"ruleId":"580","severity":1,"message":"589","line":32,"column":9,"nodeType":"582","messageId":"583","endLine":32,"endColumn":14,"fix":"606"},{"ruleId":"580","severity":1,"message":"607","line":33,"column":9,"nodeType":"582","messageId":"583","endLine":33,"endColumn":12,"fix":"608"},{"ruleId":"580","severity":1,"message":"609","line":127,"column":9,"nodeType":"582","messageId":"583","endLine":127,"endColumn":22,"fix":"610"},{"ruleId":"580","severity":1,"message":"611","line":129,"column":9,"nodeType":"582","messageId":"583","endLine":129,"endColumn":23,"fix":"612"},{"ruleId":"580","severity":1,"message":"613","line":135,"column":9,"nodeType":"582","messageId":"583","endLine":135,"endColumn":15,"fix":"614"},{"ruleId":"580","severity":1,"message":"589","line":160,"column":9,"nodeType":"582","messageId":"583","endLine":160,"endColumn":14,"fix":"615"},{"ruleId":"580","severity":1,"message":"616","line":57,"column":11,"nodeType":"582","messageId":"583","endLine":57,"endColumn":17},{"ruleId":"580","severity":1,"message":"617","line":57,"column":31,"nodeType":"582","messageId":"583","endLine":57,"endColumn":36},{"ruleId":"580","severity":1,"message":"618","line":57,"column":38,"nodeType":"582","messageId":"583","endLine":57,"endColumn":47},{"ruleId":"580","severity":1,"message":"619","line":74,"column":11,"nodeType":"582","messageId":"583","endLine":74,"endColumn":17,"fix":"620"},{"ruleId":"580","severity":1,"message":"621","line":133,"column":11,"nodeType":"582","messageId":"583","endLine":133,"endColumn":27,"fix":"622"},{"ruleId":"580","severity":1,"message":"623","line":314,"column":9,"nodeType":"582","messageId":"583","endLine":314,"endColumn":17,"fix":"624"},{"ruleId":"580","severity":1,"message":"625","line":332,"column":11,"nodeType":"582","messageId":"583","endLine":332,"endColumn":23,"fix":"626"},{"ruleId":"580","severity":1,"message":"627","line":333,"column":11,"nodeType":"582","messageId":"583","endLine":333,"endColumn":22,"fix":"628"},{"ruleId":"580","severity":1,"message":"629","line":338,"column":9,"nodeType":"582","messageId":"583","endLine":338,"endColumn":13,"fix":"630"},{"ruleId":"580","severity":1,"message":"599","line":341,"column":9,"nodeType":"582","messageId":"583","endLine":341,"endColumn":13,"fix":"631"},{"ruleId":"580","severity":1,"message":"632","line":351,"column":9,"nodeType":"582","messageId":"583","endLine":351,"endColumn":19,"fix":"633"},{"ruleId":"580","severity":1,"message":"629","line":399,"column":9,"nodeType":"582","messageId":"583","endLine":399,"endColumn":13,"fix":"634"},{"ruleId":"580","severity":1,"message":"632","line":412,"column":9,"nodeType":"582","messageId":"583","endLine":412,"endColumn":19,"fix":"635"},{"ruleId":"580","severity":1,"message":"636","line":418,"column":11,"nodeType":"582","messageId":"583","endLine":418,"endColumn":21,"fix":"637"},{"ruleId":"580","severity":1,"message":"638","line":47,"column":21,"nodeType":"582","messageId":"583","endLine":47,"endColumn":27},{"ruleId":"580","severity":1,"message":"639","line":47,"column":29,"nodeType":"582","messageId":"583","endLine":47,"endColumn":35},{"ruleId":"580","severity":1,"message":"640","line":8,"column":5,"nodeType":"582","messageId":"583","endLine":8,"endColumn":14,"fix":"641"},{"ruleId":"580","severity":1,"message":"642","line":13,"column":9,"nodeType":"582","messageId":"583","endLine":13,"endColumn":13,"fix":"643"},{"ruleId":"580","severity":1,"message":"644","line":21,"column":13,"nodeType":"582","messageId":"583","endLine":21,"endColumn":20,"fix":"645"},{"ruleId":"580","severity":1,"message":"646","line":26,"column":17,"nodeType":"582","messageId":"583","endLine":26,"endColumn":23,"fix":"647"},{"ruleId":"580","severity":1,"message":"648","line":37,"column":15,"nodeType":"582","messageId":"583","endLine":37,"endColumn":20,"fix":"649"},{"ruleId":"580","severity":1,"message":"650","line":41,"column":19,"nodeType":"582","messageId":"583","endLine":41,"endColumn":23,"fix":"651"},{"ruleId":"580","severity":1,"message":"652","line":43,"column":21,"nodeType":"582","messageId":"583","endLine":43,"endColumn":27,"fix":"653"},{"ruleId":"580","severity":1,"message":"654","line":44,"column":21,"nodeType":"582","messageId":"583","endLine":44,"endColumn":35,"fix":"655"},{"ruleId":"580","severity":1,"message":"656","line":55,"column":23,"nodeType":"582","messageId":"583","endLine":55,"endColumn":40,"fix":"657"},{"ruleId":"580","severity":1,"message":"658","line":56,"column":23,"nodeType":"582","messageId":"583","endLine":56,"endColumn":36,"fix":"659"},{"ruleId":"580","severity":1,"message":"660","line":62,"column":23,"nodeType":"582","messageId":"583","endLine":62,"endColumn":34,"fix":"661"},{"ruleId":"662","severity":1,"message":"663","line":63,"column":78,"nodeType":"664","messageId":"665","endLine":64,"endColumn":20},{"ruleId":"580","severity":1,"message":"666","line":85,"column":9,"nodeType":"582","messageId":"583","endLine":85,"endColumn":12,"fix":"667"},{"ruleId":"580","severity":1,"message":"668","line":99,"column":9,"nodeType":"582","messageId":"583","endLine":99,"endColumn":20,"fix":"669"},{"ruleId":"580","severity":1,"message":"650","line":105,"column":9,"nodeType":"582","messageId":"583","endLine":105,"endColumn":13,"fix":"670"},{"ruleId":"580","severity":1,"message":"671","line":106,"column":9,"nodeType":"582","messageId":"583","endLine":106,"endColumn":17,"fix":"672"},{"ruleId":"580","severity":1,"message":"673","line":112,"column":9,"nodeType":"582","messageId":"583","endLine":112,"endColumn":20,"fix":"674"},{"ruleId":"580","severity":1,"message":"675","line":114,"column":9,"nodeType":"582","messageId":"583","endLine":114,"endColumn":13,"fix":"676"},{"ruleId":"580","severity":1,"message":"666","line":118,"column":9,"nodeType":"582","messageId":"583","endLine":118,"endColumn":12,"fix":"677"},{"ruleId":"580","severity":1,"message":"642","line":130,"column":9,"nodeType":"582","messageId":"583","endLine":130,"endColumn":13,"fix":"678"},{"ruleId":"580","severity":1,"message":"679","line":131,"column":9,"nodeType":"582","messageId":"583","endLine":131,"endColumn":21,"fix":"680"},{"ruleId":"580","severity":1,"message":"681","line":133,"column":9,"nodeType":"582","messageId":"583","endLine":133,"endColumn":16,"fix":"682"},{"ruleId":"580","severity":1,"message":"648","line":162,"column":15,"nodeType":"582","messageId":"583","endLine":162,"endColumn":20,"fix":"683"},{"ruleId":"580","severity":1,"message":"650","line":167,"column":19,"nodeType":"582","messageId":"583","endLine":167,"endColumn":23,"fix":"684"},{"ruleId":"580","severity":1,"message":"681","line":176,"column":15,"nodeType":"582","messageId":"583","endLine":176,"endColumn":22,"fix":"685"},{"ruleId":"580","severity":1,"message":"648","line":195,"column":13,"nodeType":"582","messageId":"583","endLine":195,"endColumn":18,"fix":"686"},{"ruleId":"580","severity":1,"message":"650","line":199,"column":17,"nodeType":"582","messageId":"583","endLine":199,"endColumn":21,"fix":"687"},{"ruleId":"580","severity":1,"message":"652","line":201,"column":19,"nodeType":"582","messageId":"583","endLine":201,"endColumn":25,"fix":"688"},{"ruleId":"580","severity":1,"message":"654","line":202,"column":19,"nodeType":"582","messageId":"583","endLine":202,"endColumn":33,"fix":"689"},{"ruleId":"580","severity":1,"message":"656","line":208,"column":21,"nodeType":"582","messageId":"583","endLine":208,"endColumn":38,"fix":"690"},{"ruleId":"580","severity":1,"message":"691","line":209,"column":21,"nodeType":"582","messageId":"583","endLine":209,"endColumn":28,"fix":"692"},{"ruleId":"580","severity":1,"message":"648","line":226,"column":13,"nodeType":"582","messageId":"583","endLine":226,"endColumn":18,"fix":"693"},{"ruleId":"580","severity":1,"message":"650","line":230,"column":17,"nodeType":"582","messageId":"583","endLine":230,"endColumn":21,"fix":"694"},{"ruleId":"580","severity":1,"message":"652","line":231,"column":17,"nodeType":"582","messageId":"583","endLine":231,"endColumn":23,"fix":"695"},{"ruleId":"580","severity":1,"message":"654","line":232,"column":17,"nodeType":"582","messageId":"583","endLine":232,"endColumn":31,"fix":"696"},{"ruleId":"580","severity":1,"message":"697","line":242,"column":21,"nodeType":"582","messageId":"583","endLine":242,"endColumn":34,"fix":"698"},{"ruleId":"580","severity":1,"message":"699","line":314,"column":11,"nodeType":"582","messageId":"583","endLine":314,"endColumn":19,"fix":"700"},{"ruleId":"580","severity":1,"message":"699","line":351,"column":9,"nodeType":"582","messageId":"583","endLine":351,"endColumn":17,"fix":"701"},{"ruleId":"580","severity":1,"message":"702","line":353,"column":9,"nodeType":"582","messageId":"583","endLine":353,"endColumn":24,"fix":"703"},{"ruleId":"580","severity":1,"message":"699","line":368,"column":9,"nodeType":"582","messageId":"583","endLine":368,"endColumn":17,"fix":"704"},{"ruleId":"580","severity":1,"message":"705","line":371,"column":11,"nodeType":"582","messageId":"583","endLine":371,"endColumn":24,"fix":"706"},{"ruleId":"580","severity":1,"message":"707","line":373,"column":11,"nodeType":"582","messageId":"583","endLine":373,"endColumn":14,"fix":"708"},{"ruleId":"580","severity":1,"message":"699","line":394,"column":9,"nodeType":"582","messageId":"583","endLine":394,"endColumn":17,"fix":"709"},{"ruleId":"580","severity":1,"message":"707","line":395,"column":9,"nodeType":"582","messageId":"583","endLine":395,"endColumn":12,"fix":"710"},{"ruleId":"580","severity":1,"message":"699","line":409,"column":9,"nodeType":"582","messageId":"583","endLine":409,"endColumn":17,"fix":"711"},{"ruleId":"580","severity":1,"message":"702","line":428,"column":9,"nodeType":"582","messageId":"583","endLine":428,"endColumn":24,"fix":"712"},{"ruleId":"580","severity":1,"message":"699","line":430,"column":11,"nodeType":"582","messageId":"583","endLine":430,"endColumn":19,"fix":"713"},{"ruleId":"580","severity":1,"message":"714","line":432,"column":11,"nodeType":"582","messageId":"583","endLine":432,"endColumn":16,"fix":"715"},{"ruleId":"580","severity":1,"message":"716","line":477,"column":9,"nodeType":"582","messageId":"583","endLine":477,"endColumn":15,"fix":"717"},{"ruleId":"580","severity":1,"message":"617","line":506,"column":9,"nodeType":"582","messageId":"583","endLine":506,"endColumn":14,"fix":"718"},{"ruleId":"580","severity":1,"message":"719","line":508,"column":9,"nodeType":"582","messageId":"583","endLine":508,"endColumn":11,"fix":"720"},{"ruleId":"580","severity":1,"message":"721","line":509,"column":9,"nodeType":"582","messageId":"583","endLine":509,"endColumn":11,"fix":"722"},{"ruleId":"580","severity":1,"message":"617","line":523,"column":9,"nodeType":"582","messageId":"583","endLine":523,"endColumn":14,"fix":"723"},{"ruleId":"580","severity":1,"message":"699","line":541,"column":9,"nodeType":"582","messageId":"583","endLine":541,"endColumn":17,"fix":"724"},{"ruleId":"580","severity":1,"message":"707","line":542,"column":9,"nodeType":"582","messageId":"583","endLine":542,"endColumn":12,"fix":"725"},{"ruleId":"580","severity":1,"message":"726","line":544,"column":9,"nodeType":"582","messageId":"583","endLine":544,"endColumn":13,"fix":"727"},{"ruleId":"580","severity":1,"message":"728","line":545,"column":9,"nodeType":"582","messageId":"583","endLine":545,"endColumn":17,"fix":"729"},{"ruleId":"580","severity":1,"message":"730","line":546,"column":9,"nodeType":"582","messageId":"583","endLine":546,"endColumn":17,"fix":"731"},{"ruleId":"580","severity":1,"message":"732","line":549,"column":9,"nodeType":"582","messageId":"583","endLine":549,"endColumn":11,"fix":"733"},{"ruleId":"580","severity":1,"message":"734","line":550,"column":9,"nodeType":"582","messageId":"583","endLine":550,"endColumn":11,"fix":"735"},{"ruleId":"580","severity":1,"message":"736","line":563,"column":9,"nodeType":"582","messageId":"583","endLine":563,"endColumn":18,"fix":"737"},{"ruleId":"580","severity":1,"message":"738","line":565,"column":9,"nodeType":"582","messageId":"583","endLine":565,"endColumn":11,"fix":"739"},{"ruleId":"580","severity":1,"message":"740","line":566,"column":9,"nodeType":"582","messageId":"583","endLine":566,"endColumn":11,"fix":"741"},{"ruleId":"580","severity":1,"message":"699","line":628,"column":9,"nodeType":"582","messageId":"583","endLine":628,"endColumn":17,"fix":"742"},{"ruleId":"580","severity":1,"message":"707","line":629,"column":9,"nodeType":"582","messageId":"583","endLine":629,"endColumn":12,"fix":"743"},{"ruleId":"580","severity":1,"message":"728","line":630,"column":9,"nodeType":"582","messageId":"583","endLine":630,"endColumn":17,"fix":"744"},{"ruleId":"580","severity":1,"message":"730","line":631,"column":9,"nodeType":"582","messageId":"583","endLine":631,"endColumn":17,"fix":"745"},{"ruleId":"580","severity":1,"message":"746","line":635,"column":11,"nodeType":"582","messageId":"583","endLine":635,"endColumn":17,"fix":"747"},{"ruleId":"580","severity":1,"message":"746","line":642,"column":11,"nodeType":"582","messageId":"583","endLine":642,"endColumn":17,"fix":"748"},{"ruleId":"580","severity":1,"message":"746","line":649,"column":11,"nodeType":"582","messageId":"583","endLine":649,"endColumn":17,"fix":"749"},{"ruleId":"580","severity":1,"message":"746","line":656,"column":11,"nodeType":"582","messageId":"583","endLine":656,"endColumn":17,"fix":"750"},{"ruleId":"580","severity":1,"message":"751","line":663,"column":11,"nodeType":"582","messageId":"583","endLine":663,"endColumn":23,"fix":"752"},{"ruleId":"580","severity":1,"message":"753","line":664,"column":11,"nodeType":"582","messageId":"583","endLine":664,"endColumn":23,"fix":"754"},{"ruleId":"580","severity":1,"message":"699","line":676,"column":9,"nodeType":"582","messageId":"583","endLine":676,"endColumn":17,"fix":"755"},{"ruleId":"580","severity":1,"message":"707","line":677,"column":9,"nodeType":"582","messageId":"583","endLine":677,"endColumn":12,"fix":"756"},{"ruleId":"580","severity":1,"message":"757","line":686,"column":11,"nodeType":"582","messageId":"583","endLine":686,"endColumn":13,"fix":"758"},{"ruleId":"580","severity":1,"message":"759","line":687,"column":11,"nodeType":"582","messageId":"583","endLine":687,"endColumn":13,"fix":"760"},{"ruleId":"580","severity":1,"message":"761","line":690,"column":11,"nodeType":"582","messageId":"583","endLine":690,"endColumn":17,"fix":"762"},{"ruleId":"580","severity":1,"message":"763","line":691,"column":11,"nodeType":"582","messageId":"583","endLine":691,"endColumn":17,"fix":"764"},{"ruleId":"580","severity":1,"message":"726","line":727,"column":9,"nodeType":"582","messageId":"583","endLine":727,"endColumn":13,"fix":"765"},{"ruleId":"580","severity":1,"message":"766","line":47,"column":7,"nodeType":"582","messageId":"583","endLine":47,"endColumn":11,"fix":"767"},{"ruleId":"580","severity":1,"message":"768","line":159,"column":9,"nodeType":"582","messageId":"583","endLine":159,"endColumn":23,"fix":"769"},{"ruleId":"580","severity":1,"message":"770","line":53,"column":9,"nodeType":"582","messageId":"583","endLine":53,"endColumn":20,"fix":"771"},{"ruleId":"580","severity":1,"message":"642","line":60,"column":9,"nodeType":"582","messageId":"583","endLine":60,"endColumn":13,"fix":"772"},{"ruleId":"580","severity":1,"message":"773","line":13,"column":5,"nodeType":"582","messageId":"583","endLine":13,"endColumn":13,"fix":"774"},{"ruleId":"580","severity":1,"message":"775","line":14,"column":5,"nodeType":"582","messageId":"583","endLine":14,"endColumn":16,"fix":"776"},{"ruleId":"580","severity":1,"message":"593","line":14,"column":9,"nodeType":"582","messageId":"583","endLine":14,"endColumn":10},{"ruleId":"580","severity":1,"message":"594","line":14,"column":37,"nodeType":"582","messageId":"583","endLine":14,"endColumn":38,"fix":"777"},{"ruleId":"580","severity":1,"message":"778","line":13,"column":7,"nodeType":"582","messageId":"583","endLine":13,"endColumn":16,"fix":"779"},{"ruleId":"580","severity":1,"message":"780","line":30,"column":7,"nodeType":"582","messageId":"583","endLine":30,"endColumn":8,"fix":"781"},{"ruleId":"580","severity":1,"message":"782","line":145,"column":21,"nodeType":"582","messageId":"583","endLine":145,"endColumn":29},{"ruleId":"662","severity":1,"message":"783","line":12,"column":25,"nodeType":"664","messageId":"665","endLine":13,"endColumn":4},{"ruleId":"580","severity":1,"message":"784","line":25,"column":9,"nodeType":"582","messageId":"583","endLine":25,"endColumn":12,"fix":"785"},{"ruleId":"580","severity":1,"message":"786","line":26,"column":9,"nodeType":"582","messageId":"583","endLine":26,"endColumn":16,"fix":"787"},{"ruleId":"580","severity":1,"message":"788","line":130,"column":9,"nodeType":"582","messageId":"583","endLine":130,"endColumn":10,"fix":"789"},{"ruleId":"580","severity":1,"message":"790","line":98,"column":9,"nodeType":"582","messageId":"583","endLine":98,"endColumn":36,"fix":"791"},{"ruleId":"580","severity":1,"message":"792","line":100,"column":9,"nodeType":"582","messageId":"583","endLine":100,"endColumn":12,"fix":"793"},{"ruleId":"580","severity":1,"message":"794","line":131,"column":9,"nodeType":"582","messageId":"583","endLine":131,"endColumn":19,"fix":"795"},{"ruleId":"580","severity":1,"message":"796","line":101,"column":7,"nodeType":"582","messageId":"583","endLine":101,"endColumn":11,"fix":"797"},{"ruleId":"580","severity":1,"message":"798","line":103,"column":9,"nodeType":"582","messageId":"583","endLine":103,"endColumn":12,"fix":"799"},{"ruleId":"580","severity":1,"message":"800","line":104,"column":9,"nodeType":"582","messageId":"583","endLine":104,"endColumn":14,"fix":"801"},{"ruleId":"580","severity":1,"message":"802","line":106,"column":9,"nodeType":"582","messageId":"583","endLine":106,"endColumn":12,"fix":"803"},{"ruleId":"580","severity":1,"message":"804","line":134,"column":7,"nodeType":"582","messageId":"583","endLine":134,"endColumn":16,"fix":"805"},{"ruleId":"580","severity":1,"message":"806","line":20,"column":7,"nodeType":"582","messageId":"583","endLine":20,"endColumn":14,"fix":"807"},{"ruleId":"580","severity":1,"message":"808","line":21,"column":7,"nodeType":"582","messageId":"583","endLine":21,"endColumn":9,"fix":"809"},{"ruleId":"580","severity":1,"message":"810","line":22,"column":7,"nodeType":"582","messageId":"583","endLine":22,"endColumn":9,"fix":"811"},{"ruleId":"580","severity":1,"message":"812","line":23,"column":7,"nodeType":"582","messageId":"583","endLine":23,"endColumn":12,"fix":"813"},{"ruleId":"580","severity":1,"message":"716","line":203,"column":9,"nodeType":"582","messageId":"583","endLine":203,"endColumn":15,"fix":"814"},{"ruleId":"580","severity":1,"message":"815","line":411,"column":15,"nodeType":"582","messageId":"583","endLine":411,"endColumn":20,"fix":"816"},{"ruleId":"580","severity":1,"message":"815","line":446,"column":15,"nodeType":"582","messageId":"583","endLine":446,"endColumn":20,"fix":"817"},{"ruleId":"580","severity":1,"message":"818","line":584,"column":15,"nodeType":"582","messageId":"583","endLine":584,"endColumn":18},{"ruleId":"580","severity":1,"message":"819","line":618,"column":7,"nodeType":"582","messageId":"583","endLine":618,"endColumn":24,"fix":"820"},{"ruleId":"580","severity":1,"message":"821","line":36,"column":11,"nodeType":"582","messageId":"583","endLine":36,"endColumn":18,"fix":"822"},{"ruleId":"580","severity":1,"message":"766","line":56,"column":11,"nodeType":"582","messageId":"583","endLine":56,"endColumn":15,"fix":"823"},{"ruleId":"580","severity":1,"message":"824","line":166,"column":9,"nodeType":"582","messageId":"583","endLine":166,"endColumn":32,"fix":"825"},{"ruleId":"580","severity":1,"message":"826","line":18,"column":9,"nodeType":"582","messageId":"583","endLine":18,"endColumn":11,"fix":"827"},{"ruleId":"580","severity":1,"message":"828","line":19,"column":9,"nodeType":"582","messageId":"583","endLine":19,"endColumn":11,"fix":"829"},"no-var","Unexpected var, use let or const instead.","VariableDeclaration","unexpectedVar",{"range":"830","text":"831"},{"range":"832","text":"831"},{"range":"833","text":"831"},{"range":"834","text":"831"},"prefer-const","'note_info' is never reassigned. Use 'const' instead.","Identifier","useConst",{"range":"835","text":"836"},"'_pens' is never reassigned. Use 'const' instead.",{"range":"837","text":"836"},"'$' is never reassigned. Use 'const' instead.",{"range":"838","text":"836"},"'$elem' is never reassigned. Use 'const' instead.",{"range":"839","text":"836"},{"range":"840","text":"836"},{"range":"841","text":"836"},"'r' is never reassigned. Use 'const' instead.","'v' is never reassigned. Use 'const' instead.",{"range":"842","text":"836"},"'dpr' is never reassigned. Use 'const' instead.",{"range":"843","text":"836"},{"range":"844","text":"836"},"'rect' is never reassigned. Use 'const' instead.",{"range":"845","text":"836"},{"range":"846","text":"836"},"'norm_img' is never reassigned. Use 'const' instead.",{"range":"847","text":"836"},"'hover_img' is never reassigned. Use 'const' instead.",{"range":"848","text":"836"},{"range":"849","text":"836"},"'$c2' is never reassigned. Use 'const' instead.",{"range":"850","text":"836"},"'document' is never reassigned. Use 'const' instead.",{"range":"851","text":"836"},"'isInFullScreen' is never reassigned. Use 'const' instead.",{"range":"852","text":"836"},"'docElm' is never reassigned. Use 'const' instead.",{"range":"853","text":"836"},{"range":"854","text":"836"},"'pageId' is never reassigned. Use 'const' instead.","'scale' is never reassigned. Use 'const' instead.","'playState' is never reassigned. Use 'const' instead.","'filter' is never reassigned. Use 'const' instead.",{"range":"855","text":"836"},"'pageStrokesCount' is never reassigned. Use 'const' instead.",{"range":"856","text":"836"},"'renderer' is never reassigned. Use 'const' instead.",{"range":"857","text":"836"},"'parentHeight' is never reassigned. Use 'const' instead.",{"range":"858","text":"836"},"'parentWidth' is never reassigned. Use 'const' instead.",{"range":"859","text":"836"},"'size' is never reassigned. Use 'const' instead.",{"range":"860","text":"836"},{"range":"861","text":"836"},"'penManager' is never reassigned. Use 'const' instead.",{"range":"862","text":"836"},{"range":"863","text":"836"},{"range":"864","text":"836"},"'inkStorage' is never reassigned. Use 'const' instead.",{"range":"865","text":"836"},"'pdfUrl' is never reassigned. Use 'const' instead.","'pageNo' is never reassigned. Use 'const' instead.","'FOLDER_ID' is never reassigned. Use 'const' instead.",{"range":"866","text":"836"},"'self' is never reassigned. Use 'const' instead.",{"range":"867","text":"836"},"'folders' is never reassigned. Use 'const' instead.",{"range":"868","text":"836"},"'folder' is never reassigned. Use 'const' instead.",{"range":"869","text":"836"},"'files' is never reassigned. Use 'const' instead.",{"range":"870","text":"836"},"'file' is never reassigned. Use 'const' instead.",{"range":"871","text":"836"},"'fileId' is never reassigned. Use 'const' instead.",{"range":"872","text":"836"},"'getFileRequest' is never reassigned. Use 'const' instead.",{"range":"873","text":"836"},"'currentMappingObj' is never reassigned. Use 'const' instead.",{"range":"874","text":"836"},"'newMappingObj' is never reassigned. Use 'const' instead.",{"range":"875","text":"836"},"'contentBlob' is never reassigned. Use 'const' instead.",{"range":"876","text":"836"},"@typescript-eslint/no-empty-function","Unexpected empty function.","FunctionExpression","unexpected","'xhr' is never reassigned. Use 'const' instead.",{"range":"877","text":"836"},"'fileContent' is never reassigned. Use 'const' instead.",{"range":"878","text":"836"},{"range":"879","text":"836"},"'metadata' is never reassigned. Use 'const' instead.",{"range":"880","text":"836"},"'accessToken' is never reassigned. Use 'const' instead.",{"range":"881","text":"836"},"'form' is never reassigned. Use 'const' instead.",{"range":"882","text":"836"},{"range":"883","text":"836"},{"range":"884","text":"836"},"'access_token' is never reassigned. Use 'const' instead.",{"range":"885","text":"836"},"'request' is never reassigned. Use 'const' instead.",{"range":"886","text":"836"},{"range":"887","text":"836"},{"range":"888","text":"836"},{"range":"889","text":"836"},{"range":"890","text":"836"},{"range":"891","text":"836"},{"range":"892","text":"836"},{"range":"893","text":"836"},{"range":"894","text":"836"},"'content' is never reassigned. Use 'const' instead.",{"range":"895","text":"836"},{"range":"896","text":"836"},{"range":"897","text":"836"},{"range":"898","text":"836"},{"range":"899","text":"836"},"'docInitParams' is never reassigned. Use 'const' instead.",{"range":"900","text":"836"},"'canvasFb' is never reassigned. Use 'const' instead.",{"range":"901","text":"836"},{"range":"902","text":"836"},"'evt' is never reassigned. Use 'const' instead.",{"range":"903","text":"836"},{"range":"904","text":"836"},"'e' is never reassigned. Use 'const' instead.",{"range":"905","text":"836"},"'vpt' is never reassigned. Use 'const' instead.",{"range":"906","text":"836"},{"range":"907","text":"836"},{"range":"908","text":"836"},{"range":"909","text":"836"},{"range":"910","text":"836"},{"range":"911","text":"836"},"'delta' is never reassigned. Use 'const' instead.",{"range":"912","text":"836"},"'canvas' is never reassigned. Use 'const' instead.",{"range":"913","text":"836"},{"range":"914","text":"836"},"'cx' is never reassigned. Use 'const' instead.",{"range":"915","text":"836"},"'cy' is never reassigned. Use 'const' instead.",{"range":"916","text":"836"},{"range":"917","text":"836"},{"range":"918","text":"836"},{"range":"919","text":"836"},"'zoom' is never reassigned. Use 'const' instead.",{"range":"920","text":"836"},"'offset_x' is never reassigned. Use 'const' instead.",{"range":"921","text":"836"},"'offset_y' is never reassigned. Use 'const' instead.",{"range":"922","text":"836"},"'sx' is never reassigned. Use 'const' instead.",{"range":"923","text":"836"},"'sy' is never reassigned. Use 'const' instead.",{"range":"924","text":"836"},"'scale_det' is never reassigned. Use 'const' instead.",{"range":"925","text":"836"},"'nx' is never reassigned. Use 'const' instead.",{"range":"926","text":"836"},"'ny' is never reassigned. Use 'const' instead.",{"range":"927","text":"836"},{"range":"928","text":"836"},{"range":"929","text":"836"},{"range":"930","text":"836"},{"range":"931","text":"836"},"'target' is never reassigned. Use 'const' instead.",{"range":"932","text":"836"},{"range":"933","text":"836"},{"range":"934","text":"836"},{"range":"935","text":"836"},"'new_offset_x' is never reassigned. Use 'const' instead.",{"range":"936","text":"836"},"'new_offset_y' is never reassigned. Use 'const' instead.",{"range":"937","text":"836"},{"range":"938","text":"836"},{"range":"939","text":"836"},"'x1' is never reassigned. Use 'const' instead.",{"range":"940","text":"836"},"'y1' is never reassigned. Use 'const' instead.",{"range":"941","text":"836"},"'step_x' is never reassigned. Use 'const' instead.",{"range":"942","text":"836"},"'step_y' is never reassigned. Use 'const' instead.",{"range":"943","text":"836"},{"range":"944","text":"836"},"'blob' is never reassigned. Use 'const' instead.",{"range":"945","text":"836"},"'loadingPromise' is never reassigned. Use 'const' instead.",{"range":"946","text":"836"},"'loadingTask' is never reassigned. Use 'const' instead.",{"range":"947","text":"836"},{"range":"948","text":"836"},"'CMAP_URL' is never reassigned. Use 'const' instead.",{"range":"949","text":"836"},"'CMAP_PACKED' is never reassigned. Use 'const' instead.",{"range":"950","text":"836"},{"range":"951","text":"836"},"'minFactor' is never reassigned. Use 'const' instead.",{"range":"952","text":"836"},"'m' is never reassigned. Use 'const' instead.",{"range":"953","text":"836"},"'rotation' is never reassigned. Use 'const' instead.","Unexpected empty constructor.","'now' is never reassigned. Use 'const' instead.",{"range":"954","text":"836"},"'timeStr' is never reassigned. Use 'const' instead.",{"range":"955","text":"836"},"'x' is never reassigned. Use 'const' instead.",{"range":"956","text":"836"},"'viewport' is never reassigned. Use 'const' instead.",{"range":"957","text":"836"},"'ctx' is never reassigned. Use 'const' instead.",{"range":"958","text":"836"},"'renderTask' is never reassigned. Use 'const' instead.",{"range":"959","text":"836"},"'keys' is never reassigned. Use 'const' instead.",{"range":"960","text":"836"},"'key' is never reassigned. Use 'const' instead.",{"range":"961","text":"836"},"'value' is never reassigned. Use 'const' instead.",{"range":"962","text":"836"},"'idx' is never reassigned. Use 'const' instead.",{"range":"963","text":"836"},"'numerator' is never reassigned. Use 'const' instead.",{"range":"964","text":"836"},"'headlen' is never reassigned. Use 'const' instead.",{"range":"965","text":"836"},"'dx' is never reassigned. Use 'const' instead.",{"range":"966","text":"836"},"'dy' is never reassigned. Use 'const' instead.",{"range":"967","text":"836"},"'angle' is never reassigned. Use 'const' instead.",{"range":"968","text":"836"},{"range":"969","text":"836"},"'glyph' is never reassigned. Use 'const' instead.",{"range":"970","text":"836"},{"range":"971","text":"836"},"'dpi' is never reassigned. Use 'const' instead.","'center' is never reassigned. Use 'const' instead.",{"range":"972","text":"836"},"'promise' is never reassigned. Use 'const' instead.",{"range":"973","text":"836"},{"range":"974","text":"836"},"'dstPts' is never reassigned. Use 'const' instead.",{"range":"975","text":"836"},"'r1' is never reassigned. Use 'const' instead.",{"range":"976","text":"836"},"'r2' is never reassigned. Use 'const' instead.",{"range":"977","text":"836"},[1707,1710],"let",[1764,1767],[1819,1822],[1880,1883],[2547,2550],"const",[2626,2629],[313,316],[547,550],[603,606],[708,711],[416,419],[575,578],[795,798],[886,889],[95,98],[656,659],[709,712],[765,768],[797,800],[3732,3735],[3776,3779],[4136,4139],[4988,4991],[1832,1835],[3928,3931],[8810,8813],[9405,9408],[9450,9453],[9577,9580],[9657,9660],[9983,9986],[11240,11243],[11512,11515],[11723,11726],[191,194],[325,328],[633,636],[832,835],[1180,1183],[1375,1378],[1469,1472],[1508,1511],[1976,1979],[2046,2049],[2283,2286],[2978,2981],[3489,3492],[3740,3743],[3803,3806],[4034,4037],[4148,4151],[4314,4317],[4775,4778],[4797,4800],[4858,4861],[5670,5673],[5871,5874],[6108,6111],[6628,6631],[6776,6779],[6866,6869],[6903,6906],[7116,7119],[7184,7187],[7648,7651],[7796,7799],[7830,7833],[7865,7868],[8219,8222],[7931,7934],[8892,8895],[8929,8932],[9214,9217],[9285,9288],[9378,9381],[9859,9862],[9894,9897],[10217,10220],[10681,10684],[10804,10807],[10843,10846],[12020,12023],[12733,12736],[12769,12772],[12819,12822],[13168,13171],[13593,13596],[13628,13631],[13673,13676],[13714,13717],[13742,13745],[13774,13777],[13809,13812],[14063,14066],[14107,14110],[14154,14157],[15526,15529],[15561,15564],[15604,15607],[15632,15635],[15717,15720],[15902,15905],[16108,16111],[16321,16324],[16488,16491],[16529,16532],[16846,16849],[16881,16884],[17140,17143],[17165,17168],[17215,17218],[17252,17255],[18193,18196],[1313,1316],[3669,3672],[1493,1496],[1623,1626],[800,803],[828,831],[481,484],[565,568],[1064,1067],[704,707],[731,734],[3592,3595],[2462,2465],[2557,2560],[3470,3473],[2359,2362],[2442,2445],[2466,2469],[2501,2504],[3063,3066],[754,757],[804,807],[829,832],[854,857],[5716,5719],[12553,12556],[13760,13763],[18613,18616],[1069,1072],[1699,1702],[4863,4866],[586,589],[607,610]]